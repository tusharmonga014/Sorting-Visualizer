{"version":3,"sources":["defaults/index.js","components/ArrayBars/ArrayBars.jsx","components/ArrayBars/ArrayBars.js","components/ControlBar/ControlBar.jsx","reducers/algorithmRedcuer/index.js","reducers/utilities/swapValuesInArray.js","reducers/utilities/setValueInArrayUsingSplice.js","reducers/arrayReducer/index.js","reducers/index.js","reducers/speedReducer/index.js","reducers/currenltyCheckingReducer/index.js","reducers/pivotReducer/index.js","reducers/sortedArrayReducer/index.js","reducers/sortingRunStatus/index.js","store/index.js","actions/array/index.js","actions/currentlyChecking/index.js","actions/sortedArray/index.js","algorithms/helpers/getSortingRunStatus.js","algorithms/helpers/checkCurrentStatus.js","algorithms/helpers/getTimeDelay.js","algorithms/helpers/sleep.js","algorithms/helpers/continueAfterDelayIfNotStopped.js","algorithms/allAlgorithms/bubbleSort.js","actions/sortingRunStatus/index.js","algorithms/allAlgorithms/mergeSort.js","actions/pivot/index.js","algorithms/allAlgorithms/quickSort.js","algorithms/allAlgorithms/heapSort.js","algorithms/allAlgorithms/insertionSort.js","algorithms/ALGORITHMS.js","algorithms/getAlgorithmById.js","algorithms/sort.js","components/ControlBar/ControlBar.js","actions/algorithm/index.js","actions/speed/index.js","components/SortingVisualizer/SortingVisualizer.jsx","components/App.js","index.js"],"names":["ARRAY_MAX_VALUE","window","screen","width","MAX_ARRAY_SIZE","DEFAULT_ARRAY_SIZE","MARGIN_BETWEEN_BARS","arraySize","SCREEN_PERCENTAGE_TO_OCCUPY","ArrayBars","getMarginBetweenBars","getBarsDisplayAreaWidth","screenWidth","Math","floor","getBarWidth","barsDisplayAreaWidth","marginBetween","showBarHeight","event","barId","target","id","barIdForHeightDisplay","bar","document","getElementById","barHeightDisplayBox","style","opacity","removeAttribute","zIndex","hideBarHeight","setAttribute","this","props","array","currentlyChecking","pivot","sortedArray","sortingRunStatus","length","barWidth","displayBarHeight","className","map","idx","backgroundColor","includes","hidden","height","marginLeft","onMouseOver","onMouseLeave","Component","connect","state","algorithm","dispatch","ControlBar","resetArray","generateArray","changeArraySize","value","changeAlgorithm","selectedAlgo","innerText","name","changeSpeed","selectedSpeed","Number","disableArrayAlgorithmInputs","buttonsToBeDisabled","getElementsByClassName","buttonDisablingIterator","disableArrayAlgorithmTexts","textsToBeDisabled","textDisablingIterator","classList","remove","add","enableArrayAlgorithmInputs","buttonsToBeEnabled","buttonEnablingIterator","enableArrayAlgorithmTexts","textsToBeEnabled","textEnablingIterator","hideStartSortingButton","showStartSortingButton","showPauseButton","hidePauseButton","showContinueButton","hideContinueButton","showStopSortinButton","hideStopSortingButton","manageControlBarFeaturesWhenSortingStarts","manageControlBarFeaturesWhenSortingStops","startSorting","pauseSorting","continueSorting","stopSorting","handleIfSortingCompleted","algorithms","defaultAlgorithm","onClick","type","this_algorithm","min","max","defaultValue","onChange","initialState","checkIfIndexOutOfBounds","index","console","error","swapValuesInArray","firstIdx","secondIdx","temp","setValueInArrayUsingSplice","replaceCounter","splice","rootReducer","combineReducers","action","payload","data","speed","concat","store","createStore","__REDUX_DEVTOOLS_EXTENSION__","swapValues","setValue","setCurrentlyChecking","setSortedArray","addToSortedArray","getCurrentSortingRunStatus","getState","a","Promise","resolve","reject","setInterval","checkCurrentSortingRunStatus","getTimeDelay","setTimeout","sleep","then","catch","finalCheckResult","continueAfterDelayIfNotStopped","localArray","outerLoopIterator","innerLoopIterator","merge","leftIdx","midIdx","rightIdx","n1","n2","leftLocalArray","Array","rightLocalArray","i","j","k","mergeSortRecursive","parseInt","mergeSort","setPivot","partition","startIdx","endIdx","pivotValue","pivotIdx","quickSortRecursive","heapify","nodeIndex","largest","right","left","HeapSort","extractElementIterator","iterator","backwardIterator","insertionSort","ALGORITHMS","function","getAlgorithmById","algorithmId","algorithmsIterator","log","sort","getRandomValue","lowerLimit","upperLimit","random","empty_CurrentlyArray_and_SortedArray","randomGeneratedArray","push","generateRandomArray","setAlgorithm","SortingVisualizer","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.d4cf94a4.chunk.js","sourcesContent":["/**\r\n * Array's lowest value\r\n */\r\nconst ARRAY_MIN_VALUE = 40;\r\n/**\r\n * Array's largest value\r\n * ARRAY_MAX_VALUE > 500 will overlap with Control-Bar\r\n */\r\nconst ARRAY_MAX_VALUE = window.screen.width <= 700 ? 350 : 425;\r\n\r\n/**\r\n * Sorting speed range\r\n * SORTING_SPEED_LOWER_LIMIT is 0 always\r\n */\r\nconst SORTING_SPEED_UPPER_LIMIT = 500;\r\nconst DEFAULT_SELECTED_SPEED = 500;\r\n\r\n/**\r\n * Minimum array length\r\n */\r\nconst MIN_ARRAY_SIZE = 10;\r\n/**\r\n * Maximum array length\r\n */\r\nconst MAX_ARRAY_SIZE = window.screen.width <= 600 ? 100 : 200;\r\nconst DEFAULT_ARRAY_SIZE = MAX_ARRAY_SIZE / 1.5;\r\n\r\n/**\r\n * Bar colour when its neither sorted \r\n * nor in the process of being sorted\r\n */\r\nconst BAR__COLOUR_DEFAULT = 'rgb(0, 204, 255)';\r\n// const BAR__COLOUR_DEFAULT = 'rgb(0, 255, 145)';\r\n/**\r\n * Bar colour when its in the process for sorting\r\n */\r\nconst BAR_COLOUR_WHILE_CHECKING = 'blue';\r\n/**\r\n * Bar colour when it has been sorted\r\n */\r\nconst BAR_COLOUR_SORTED = 'purple';\r\n/**\r\n * Bar colour when it is pivot\r\n */\r\nconst BAR_COLOUR_PIVOT = 'rgb(102, 255, 51)';\r\n\r\n\r\n/**\r\n * Default selected sorting algorithm Id\r\n * shown in dropdown algo selector\r\n */\r\nconst DEFAULT_SELECTED_ALGORITHM_ID = 0;\r\n\r\n/**\r\n * tells margin between bars\r\n * @param {*} arraySize the length of array \r\n * @returns space between each bar depending upon the arraySize\r\n */\r\nconst MARGIN_BETWEEN_BARS = (arraySize) => {\r\n    return arraySize <= 10 ? 4\r\n        : arraySize <= 50 ? 2\r\n            : 1\r\n};\r\n\r\n/**\r\n * tells the amount of screen to occupy\r\n * @param {*} arraySize the length of the array\r\n * @returns the amount of screen to occupy in \r\n *          terms of decimal from 0-1 where \r\n *          0 shows empty space and\r\n *          1 shows full screen \r\n */\r\nconst SCREEN_PERCENTAGE_TO_OCCUPY = (arraySize) => {\r\n    return window.screen.width <= 600 ? 0.80\r\n        : arraySize <= 16 ? 0.50\r\n            : 0.66;\r\n}\r\n\r\n/**\r\n * .............................\r\n * EXPORTS\r\n * ............................. \r\n */\r\nexport {\r\n    ARRAY_MIN_VALUE,\r\n    ARRAY_MAX_VALUE,\r\n    SORTING_SPEED_UPPER_LIMIT,\r\n    DEFAULT_SELECTED_SPEED,\r\n    MIN_ARRAY_SIZE,\r\n    MAX_ARRAY_SIZE,\r\n    DEFAULT_ARRAY_SIZE,\r\n    BAR__COLOUR_DEFAULT,\r\n    BAR_COLOUR_WHILE_CHECKING,\r\n    BAR_COLOUR_SORTED,\r\n    BAR_COLOUR_PIVOT,\r\n    DEFAULT_SELECTED_ALGORITHM_ID,\r\n    MARGIN_BETWEEN_BARS,\r\n    SCREEN_PERCENTAGE_TO_OCCUPY\r\n}","import React, { Component } from \"react\"\r\nimport { BAR_COLOUR_PIVOT, BAR_COLOUR_SORTED, BAR_COLOUR_WHILE_CHECKING, BAR__COLOUR_DEFAULT, MARGIN_BETWEEN_BARS, SCREEN_PERCENTAGE_TO_OCCUPY } from \"../../defaults\";\r\nimport \"./ArrayBars.css\";\r\n\r\nclass ArrayBars extends Component {\r\n\r\n    getMarginBetweenBars = (arraySize) => {\r\n        const marginBetween = MARGIN_BETWEEN_BARS(arraySize);\r\n        return marginBetween;\r\n    }\r\n\r\n    getBarsDisplayAreaWidth = (arraySize) => {\r\n        const screenWidth = window.screen.width;\r\n        const barsDisplayAreaWidth = Math.floor(screenWidth * SCREEN_PERCENTAGE_TO_OCCUPY(arraySize));\r\n        return barsDisplayAreaWidth;\r\n    }\r\n\r\n    getBarWidth = (arraySize, barsDisplayAreaWidth, marginBetween) => {\r\n        const barWidth = (barsDisplayAreaWidth - (marginBetween * arraySize)) / arraySize;\r\n        return barWidth;\r\n    }\r\n\r\n    showBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes 0.5 when mouse enters the bar,\r\n         * Height Display Box becomes visible,\r\n         * Z-index of box is set to 1 to bring it forward than bar\r\n         */\r\n        bar.style.opacity = 0.5;\r\n        barHeightDisplayBox.removeAttribute('hidden');\r\n        barHeightDisplayBox.style.zIndex = 1;\r\n    }\r\n\r\n    hideBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes normal when mouse leaves the bar,\r\n         * Height Display Box again becomes hidden,\r\n         * Z-index of box is again set to 0 to prevent its area\r\n         * from stopping mouse over effect for its bar\r\n         */\r\n        bar.style.opacity = 1;\r\n        barHeightDisplayBox.setAttribute('hidden', true);\r\n        barHeightDisplayBox.style.zIndex = 0;\r\n    }\r\n\r\n    render() {\r\n\r\n        const { array, currentlyChecking, pivot, sortedArray, sortingRunStatus } = this.props;\r\n\r\n        const arraySize = array.length;\r\n        const barsDisplayAreaWidth = this.getBarsDisplayAreaWidth(arraySize);\r\n        const marginBetween = this.getMarginBetweenBars(arraySize);\r\n        const barWidth = this.getBarWidth(arraySize, barsDisplayAreaWidth, marginBetween);\r\n        const displayBarHeight = window.screen.width >= 500 && arraySize < 23 ? true : false;\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"bars\" style={{ width: barsDisplayAreaWidth }}>\r\n                    {\r\n                        array.length > 0 && array.map((bar, idx) => {\r\n                            let backgroundColor = idx === pivot ? BAR_COLOUR_PIVOT : BAR__COLOUR_DEFAULT;\r\n                            backgroundColor = sortedArray.includes(idx) || sortingRunStatus === 'COMPLETED' ? BAR_COLOUR_SORTED : backgroundColor;\r\n                            backgroundColor = currentlyChecking.includes(idx) && sortingRunStatus !== 'COMPLETED' ? BAR_COLOUR_WHILE_CHECKING : backgroundColor;\r\n                            const barIdForHeightDisplay = 'bar' + idx;\r\n\r\n                            return (\r\n                                <div key={idx}>\r\n\r\n                                    {/* bar height display box */}\r\n                                    <div\r\n                                        id={barIdForHeightDisplay}\r\n                                        className=\"bar-height-display\"\r\n                                        hidden>\r\n                                        {bar}\r\n                                    </div>\r\n\r\n                                    {/* bar */}\r\n                                    <div\r\n                                        id={idx}\r\n                                        className=\"bar\"\r\n                                        style={{ width: barWidth, height: bar, backgroundColor: backgroundColor, marginLeft: marginBetween }}\r\n                                        onMouseOver={this.showBarHeight}\r\n                                        onMouseLeave={this.hideBarHeight}>\r\n                                        {displayBarHeight ? bar : ''}\r\n                                    </div>\r\n\r\n                                </div>\r\n                            );\r\n                        })\r\n                    }\r\n                </div >\r\n\r\n                <div className='base-block bg-dark text-center'></div>\r\n\r\n            </div >\r\n        )\r\n    }\r\n}\r\n\r\nexport default ArrayBars;","import ArrayBars from \"./ArrayBars.jsx\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const currentlyChecking = state.currentlyChecking;\r\n    const pivot = state.pivot;\r\n    const sortedArray = state.sortedArray;\r\n    const sortingRunStatus = state.sortingRunStatus;\r\n    return { array, algorithm, currentlyChecking, pivot, sortedArray, sortingRunStatus };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n})\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ArrayBars);","import React, { Component } from \"react\";\r\nimport { DEFAULT_ARRAY_SIZE, DEFAULT_SELECTED_SPEED, MAX_ARRAY_SIZE, MIN_ARRAY_SIZE, SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\nimport \"./ControlBar.css\";\r\n\r\nclass ControlBar extends Component {\r\n\r\n  /**\r\n   * Generates a new Array of given length\r\n   * @param {number} arraySize length for new Array\r\n   */\r\n  resetArray = (arraySize) => {\r\n    this.props.generateArray(arraySize);\r\n  }\r\n\r\n  /**\r\n   * Changes and generates a new array of selected length\r\n   * @param {event} event Event which trigerred the function\r\n   */\r\n  changeArraySize = (event) => {\r\n    this.resetArray(event.target.value);\r\n  }\r\n\r\n  /**\r\n   * Changes the algorithm \r\n   * @param {Object} selectedAlgo Selected algorithm object\r\n   */\r\n  changeAlgorithm = (selectedAlgo) => {\r\n    document.getElementById('dropdown-algo-selector').innerText = selectedAlgo.name;\r\n    this.props.changeAlgorithm(selectedAlgo);\r\n  }\r\n\r\n  /**\r\n  * Changes the algorithm \r\n  * @param {event} event Event which trigerred the function\r\n  */\r\n  changeSpeed = (event) => {\r\n    const selectedSpeed = (Number)(event.target.value);\r\n    this.props.changeSpeed(selectedSpeed);\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar inputs for \r\n   * Array and Algorithm slelection\r\n   */\r\n  disableArrayAlgorithmInputs = () => {\r\n    const buttonsToBeDisabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonDisablingIterator = 0; buttonDisablingIterator < buttonsToBeDisabled.length; buttonDisablingIterator++) {\r\n      buttonsToBeDisabled[buttonDisablingIterator].setAttribute('disabled', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's input-label-texts on the control bar\r\n   */\r\n  disableArrayAlgorithmTexts = () => {\r\n    const textsToBeDisabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textDisablingIterator = 0; textDisablingIterator < textsToBeDisabled.length; textDisablingIterator++) {\r\n      textsToBeDisabled[textDisablingIterator].classList.remove('text-white');\r\n      textsToBeDisabled[textDisablingIterator].classList.add('text-muted');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables the control bar inputs for \r\n   * Array and Algorithm slelection\r\n   */\r\n  enableArrayAlgorithmInputs = () => {\r\n    const buttonsToBeEnabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonEnablingIterator = 0; buttonEnablingIterator < buttonsToBeEnabled.length; buttonEnablingIterator++) {\r\n      buttonsToBeEnabled[buttonEnablingIterator].removeAttribute('disabled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables the control bar's input-label-texts on the control bar\r\n   */\r\n  enableArrayAlgorithmTexts = () => {\r\n    const textsToBeEnabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textEnablingIterator = 0; textEnablingIterator < textsToBeEnabled.length; textEnablingIterator++) {\r\n      textsToBeEnabled[textEnablingIterator].classList.remove('text-muted');\r\n      textsToBeEnabled[textEnablingIterator].classList.add('text-white');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hides start sort button on the control bar\r\n   */\r\n  hideStartSortingButton = () => {\r\n    const startSortingButton = document.getElementById('btn-sort');\r\n    startSortingButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows start sort button on the control bar\r\n   */\r\n  showStartSortingButton = () => {\r\n    const startSortingButton = document.getElementById('btn-sort');\r\n    startSortingButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Shows pause button on the control bar\r\n   */\r\n  showPauseButton = () => {\r\n    const pauseButton = document.getElementById('btn-pause');\r\n    pauseButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides pause button on the control bar\r\n   */\r\n  hidePauseButton = () => {\r\n    const pauseButton = document.getElementById('btn-pause');\r\n    pauseButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows continue button on the control bar\r\n   */\r\n  showContinueButton = () => {\r\n    const continueButton = document.getElementById('btn-continue');\r\n    continueButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides continue button on the control bar\r\n   */\r\n  hideContinueButton = () => {\r\n    const continueButton = document.getElementById('btn-continue');\r\n    continueButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows the stop sort button on the control bar\r\n   */\r\n  showStopSortinButton = () => {\r\n    const stopSortingButton = document.getElementById('btn-stop-sort');\r\n    stopSortingButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides stop sort button on the control bar\r\n   */\r\n  hideStopSortingButton = () => {\r\n    const stopSortingButton = document.getElementById('btn-stop-sort');\r\n    stopSortingButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Disables Array and Algorithm related features\r\n   * and enables Sorting realted features\r\n   */\r\n  manageControlBarFeaturesWhenSortingStarts = () => {\r\n    this.disableArrayAlgorithmInputs();\r\n    this.disableArrayAlgorithmTexts();\r\n    this.hideStartSortingButton();\r\n    this.showPauseButton();\r\n    this.showStopSortinButton();\r\n  }\r\n\r\n  /**\r\n   * Enables Array and Algorithm related features\r\n   * and enables Sorting realted features\r\n   */\r\n  manageControlBarFeaturesWhenSortingStops = () => {\r\n    this.enableArrayAlgorithmInputs();\r\n    this.enableArrayAlgorithmTexts();\r\n    this.hidePauseButton();\r\n    this.hideContinueButton();\r\n    this.hideStopSortingButton();\r\n    this.showStartSortingButton();\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's feature \r\n   * and starts sorting\r\n   */\r\n  startSorting = () => {\r\n    this.manageControlBarFeaturesWhenSortingStarts();\r\n    this.props.startSorting();\r\n  }\r\n\r\n  /**\r\n   * Pauses the sorting\r\n   */\r\n  pauseSorting = () => {\r\n    this.props.pauseSorting();\r\n    this.hidePauseButton();\r\n    this.showContinueButton();\r\n  }\r\n\r\n  /**\r\n   * Continues the paused sorting process\r\n   */\r\n  continueSorting = () => {\r\n    this.hideContinueButton();\r\n    this.showPauseButton();\r\n    this.props.continueSorting();\r\n  }\r\n\r\n  /**\r\n   * Stops the current storting process\r\n   */\r\n  stopSorting = () => {\r\n    this.manageControlBarFeaturesWhenSortingStops();\r\n    this.props.stopSorting();\r\n  }\r\n\r\n  /**\r\n   * Checks if sorting is completed\r\n   * and calls the required control\r\n   * bar manager functions\r\n   */\r\n  handleIfSortingCompleted = () => {\r\n    this.props.sortingRunStatus === 'COMPLETED' && this.manageControlBarFeaturesWhenSortingStops();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetArray(DEFAULT_ARRAY_SIZE);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { array, algorithms, defaultAlgorithm } = this.props;\r\n    const arraySize = array.length;\r\n\r\n    this.handleIfSortingCompleted();\r\n\r\n    return (\r\n      <div className='nav navbar navbar-dark bg-dark text-center pt-2 pb-2'>\r\n        <div className='navbar navbar-brand col-sm-12 col-md-6 col-lg-4 text-center m-0 p-0'>\r\n          <h2>SORTING VISUALIZER</h2>\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-6 col-lg-3 m-0 p-0\">\r\n          <button className='btn btn-white btn-round mt-1 mb-1 mr-2 input-disable-when-running  array-algo-button'\r\n            onClick={() => { this.resetArray(arraySize) }}>\r\n            Generate New Array\r\n          </button>\r\n\r\n          <div className=\"btn-group array-algo-button\">\r\n            <button\r\n              type=\"button\"\r\n              id=\"dropdown-algo-selector\"\r\n              className=\"btn btn-success dropdown-toggle input-disable-when-running col-12\"\r\n              data-toggle=\"dropdown\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded=\"false\">\r\n              {defaultAlgorithm.name}\r\n            </button>\r\n            <div className=\"dropdown-menu\">\r\n              <h1 className=\"dropdown-header text-large\">Select Algorithm</h1>\r\n              {\r\n                algorithms.map((this_algorithm) => {\r\n                  return (\r\n                    <div key={this_algorithm.id}>\r\n                      <div className=\"dropdown-divider\"></div>\r\n                      <button className=\"dropdown-item\"\r\n                        onClick={() => this.changeAlgorithm(this_algorithm)}>\r\n                        {this_algorithm.name}\r\n                      </button>\r\n                    </div>\r\n                  );\r\n                })\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className='col-md-12 col-lg-3 row slider-controls text-justify-end'>\r\n          <div className='text-white text-center text-disable-when-running slider-controls col-sm-4 col-md-6 col-lg-6 mt-1 mb-1'>\r\n            Array Size :\r\n          </div>\r\n          <input\r\n            className='input-disable-when-running text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6 mt-1 mb-1'\r\n            type=\"range\"\r\n            min={MIN_ARRAY_SIZE}\r\n            max={MAX_ARRAY_SIZE}\r\n            defaultValue={DEFAULT_ARRAY_SIZE}\r\n            onChange={this.changeArraySize}\r\n          />\r\n          <div className='text-white text-center text-disable-when-running slider-controls col-sm-4 col-md-6 col-lg-6 mb-1'>\r\n            Sorting Speed :\r\n          </div>\r\n          <input\r\n            className='input-disable-when-running text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6 mb-1'\r\n            type=\"range\"\r\n            min=\"1\"\r\n            max={SORTING_SPEED_UPPER_LIMIT}\r\n            defaultValue={DEFAULT_SELECTED_SPEED}\r\n            onChange={this.changeSpeed}\r\n          />\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-12 col-lg-2 text-center mt-1 mb-1\">\r\n          <button\r\n            id=\"btn-sort\"\r\n            className=\"btn btn-success\"\r\n            onClick={this.startSorting}>\r\n            START SORTING\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-pause\"\r\n            className=\"btn btn-default btn-when-running mr-1\"\r\n            onClick={this.pauseSorting}\r\n            hidden>\r\n            Pause\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-continue\"\r\n            className=\"btn btn-default btn-when-running mr-1\"\r\n            onClick={this.continueSorting}\r\n            hidden>Continue\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-stop-sort\"\r\n            className=\"btn btn-danger btn-when-running\"\r\n            onClick={this.stopSorting}\r\n            hidden>\r\n            Stop\r\n          </button>\r\n\r\n        </div>\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default ControlBar;","import { DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults\";\r\n\r\nlet initialState = {\r\n    id: DEFAULT_SELECTED_ALGORITHM_ID\r\n}\r\n\r\nexport const algorithm = (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case 'SET_ALGORITHM':\r\n            return action.payload;\r\n        default: return state;\r\n    }\r\n}","function checkIfIndexOutOfBounds(index, arraySize) {\r\n    if (index < 0 || index >= arraySize) {\r\n        console.error(index + \" passed for swapping is out of bounds for \" + arraySize + \", can't swap values.\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Swaps the values in given array\r\n * @param {Array} array Array whose values need to be swapped \r\n * @param {number} firstIdx first index\r\n * @param {number} secondIdx second index\r\n */\r\nexport function swapValuesInArray(array, firstIdx, secondIdx) {\r\n\r\n    const arraySize = array.length;\r\n\r\n    // first and second index both should be in range 0 to (arraySize - 1)\r\n    if (checkIfIndexOutOfBounds(firstIdx, arraySize) || checkIfIndexOutOfBounds(secondIdx, arraySize)) {\r\n        return array;\r\n    }\r\n\r\n    let temp = array[firstIdx];\r\n    array[firstIdx] = array[secondIdx];\r\n    array[secondIdx] = temp;\r\n\r\n    return array;\r\n}","/**\r\n * Returns the array with value inserted at given index\r\n * @param {Array} array Array in which value needs to be inserted\r\n * @param {Number} index Index at wich value gets inserted\r\n * @param {Number} replaceCounter Number of indices to replace after given index by the given value\r\n * @param {*} value Value which is to be inserted\r\n * @returns Array with value inserted at index \r\n */\r\nexport function setValueInArrayUsingSplice(array, index, replaceCounter, value) {\r\n    array.splice(index, replaceCounter, value);\r\n    return array;\r\n}","import { setValueInArrayUsingSplice, swapValuesInArray } from \"../utilities\";\r\n\r\nexport const array = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_ARRAY':\r\n            return action.payload;\r\n        case 'SWAP_VALUES':\r\n            return swapValuesInArray(state, action.payload.firstIdx, action.payload.secondIdx);\r\n        case 'SET_VALUE':\r\n            return setValueInArrayUsingSplice(state, action.payload.id, 1, action.payload.data);\r\n        default: return state;\r\n    }\r\n}","import { combineReducers } from \"redux\";\r\nimport { algorithm } from \"./algorithmRedcuer\";\r\nimport { array } from \"./arrayReducer\";\r\nimport { currentlyChecking } from \"./currenltyCheckingReducer\";\r\nimport { speed } from \"./speedReducer\";\r\nimport { pivot } from \"./pivotReducer\";\r\nimport { sortedArray } from \"./sortedArrayReducer\";\r\nimport { sortingRunStatus } from \"./sortingRunStatus\";\r\n\r\nconst rootReducer = combineReducers({\r\n    array,\r\n    algorithm,\r\n    speed,\r\n    currentlyChecking,\r\n    pivot,\r\n    sortedArray,\r\n    sortingRunStatus,\r\n});\r\n\r\nexport default rootReducer;","import { DEFAULT_SELECTED_SPEED } from \"../../defaults\";\r\n\r\nexport const speed = (state = DEFAULT_SELECTED_SPEED, action) => {\r\n    switch (action.type) {\r\n        case 'SET_SPEED':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","/**\r\n * It denotes the array of indices currently \r\n * being checked by the algorithm for sorting\r\n */\r\nexport const currentlyChecking = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_CURRENTLYCHECKING':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const pivot = (state = -1, action) => {\r\n    switch (action.type) {\r\n        case 'SET_PIVOT':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortedArray = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_SORTEDARRAY':\r\n            return action.payload;\r\n        case 'ADD_TO_SORTEDARRAY':\r\n            return state.concat(action.payload);\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortingRunStatus = (state = 'NOT_RUNNING', action) => {\r\n    switch (action.type) {\r\n        case 'STARTED':\r\n            return 'STARTED';\r\n        case 'CONTINUED':\r\n            return 'CONTINUED';\r\n        case 'PAUSED':\r\n            return 'PAUSED';\r\n        case 'STOPPED':\r\n            return 'STOPPED';\r\n        case 'COMPLETED':\r\n            return 'COMPLETED';\r\n        case 'REFRESH':\r\n            return 'NOT_RUNNING';\r\n\r\n        default: return state;\r\n    }\r\n}","import rootReducer from \"../reducers\";\r\nimport { createStore } from \"redux\";\r\n\r\nexport const store = createStore(\r\n    rootReducer,\r\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);","export const setArray = (payload) => {\r\n    return {\r\n        type: 'SET_ARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * Swaps the value at firstIdx with secondIdx \r\n * in store's state Array\r\n * @param {number} firstIdx first index\r\n * @param {number} secondIdx second index\r\n */\r\nexport const swapValues = (firstIdx, secondIdx) => {\r\n    return {\r\n        type: 'SWAP_VALUES',\r\n        payload: {\r\n            firstIdx: firstIdx,\r\n            secondIdx: secondIdx\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sets value at specific index in store's State Array\r\n * @param {number} index Index at which value needs to be stored,\r\n * @param {*} value The value which needs to be inserted\r\n * @returns An action object with type and payload\r\n */\r\nexport const setValue = (index, value) => {\r\n    return {\r\n        type: 'SET_VALUE',\r\n        payload: {\r\n            id: index,\r\n            data: value\r\n        }\r\n    }\r\n}\r\n","export const setCurrentlyChecking = (payload) => {\r\n    return {\r\n        type: 'SET_CURRENTLYCHECKING',\r\n        payload: payload\r\n    }\r\n};\r\n","/**\r\n * Sets the sort array as provided array\r\n * @param {Array} payload takes an array to best set as sortedArray\r\n */\r\nexport const setSortedArray = (payload) => {\r\n    return {\r\n        type: 'SET_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * Adds the given element to sortedArray\r\n * @param {*} payload element to be added in sortedArray\r\n */\r\nexport const addToSortedArray = (payload) => {\r\n    return {\r\n        type: 'ADD_TO_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\"\r\n\r\n/**\r\n * Returns the sortingRunStatus in store's state\r\n * @returns sortingRunStatus\r\n */\r\nfunction getCurrentSortingRunStatus() {\r\n    // Gets the current state object in store\r\n    const state = store.getState();\r\n\r\n    // Gets the sortingRunStatus from state object\r\n    const status = state.sortingRunStatus;\r\n    return status;\r\n}\r\n\r\nexport default getCurrentSortingRunStatus;","import getCurrentSortingRunStatus from \"./getSortingRunStatus\";\r\n\r\nasync function checkCurrentSortingRunStatus() {\r\n    if (getCurrentSortingRunStatus() === 'PAUSED') {\r\n        return new Promise((resolve, reject) => {\r\n            setInterval(() => {\r\n                if (getCurrentSortingRunStatus() === 'CONTINUED')\r\n                    resolve();\r\n                else if (getCurrentSortingRunStatus() === 'STOPPED')\r\n                    reject();\r\n            }, 10);\r\n\r\n        });\r\n    } else if (getCurrentSortingRunStatus() === 'STOPPED') {\r\n        return new Promise((resolve, reject) => reject());\r\n    } else {\r\n        return new Promise(resolve => resolve());\r\n    }\r\n}\r\n\r\nexport default checkCurrentSortingRunStatus;","import { store } from \"../../store\";\r\nimport { SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\n\r\n/**\r\n * @returns the timedelay between each step,\r\n *          so if speed is 10 and speed range is 0-100\r\n *          timedelay will be of 90ms\r\n */\r\nfunction getTimeDelay() {\r\n    const state = store.getState();\r\n    const speed = state.speed;\r\n    return SORTING_SPEED_UPPER_LIMIT - speed;\r\n}\r\n\r\nexport default getTimeDelay;","import getTimeDelay from \"./getTimeDelay\";\r\n\r\nasync function sleep() {\r\n    await new Promise((resolve) => {\r\n        setTimeout(() => resolve(), getTimeDelay());\r\n    });\r\n}\r\n\r\nexport default sleep;","import checkCurrentSortingRunStatus from \"./checkCurrentStatus\";\r\nimport sleep from \"./sleep\";\r\n\r\n/**\r\n * Checks if not paused or stopped and moves when after delay time\r\n * @returns True for continuing, False for stopping\r\n */\r\nasync function continueAfterDelayIfNotStopped() {\r\n\r\n    // Checking if Paused or Stopped\r\n    let checkFurther = await checkCurrentSortingRunStatus()\r\n        .then(() => true)\r\n        .catch(() => false);\r\n    if (!checkFurther)\r\n        return false;\r\n\r\n    // Delaying accroding to selected speed\r\n    await sleep();\r\n\r\n    // Checking if Paused or Stopped\r\n    let finalCheckResult = await checkCurrentSortingRunStatus()\r\n        .then(() => true)\r\n        .catch(() => false);\r\n\r\n    return finalCheckResult;\r\n}\r\n\r\nexport default continueAfterDelayIfNotStopped;","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \".././helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * Performs Bubble Sort on the store's Array\r\n */\r\nasync function bubbleSort() {\r\n\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // Bubble Sort Algorithm \r\n\r\n    // Outer loop\r\n    for (let outerLoopIterator = 0; outerLoopIterator < arraySize - 1; outerLoopIterator++) {\r\n        let innerLoopIterator = 0;\r\n\r\n        //Inner loop\r\n        for (innerLoopIterator = 0; innerLoopIterator < arraySize - outerLoopIterator - 1; innerLoopIterator++) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            // Setting the current indices which are being checked to currentlyChecking\r\n            store.dispatch(setCurrentlyChecking([innerLoopIterator, innerLoopIterator + 1]));\r\n\r\n            if (localArray[innerLoopIterator] > localArray[innerLoopIterator + 1]) {\r\n\r\n                // Check if stopped or paused - delay accoring to selected speed - again check\r\n                continueSort = await continueAfterDelayIfNotStopped();\r\n                // Return if stopped\r\n                if (!continueSort)\r\n                    return;\r\n\r\n                // Swaps the values in store's state Array\r\n                store.dispatch(swapValues(innerLoopIterator, innerLoopIterator + 1));\r\n            }\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n        }\r\n\r\n        // Adding the 'j' which has been sorted to sortedArray\r\n        store.dispatch(addToSortedArray(innerLoopIterator));\r\n    }\r\n\r\n    // Removing the first bar as currentlyChecking\r\n    store.dispatch(setCurrentlyChecking([]));\r\n\r\n    // First bar needs to be marked explicitly as \r\n    // it doesn't go inside inner loop\r\n    store.dispatch(addToSortedArray(0));\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default bubbleSort;","export const sortingStarted = () => {\r\n    return {\r\n        type: 'STARTED'\r\n    }\r\n};\r\n\r\nexport const sortingContinued = () => {\r\n    return {\r\n        type: 'CONTINUED'\r\n    }\r\n};\r\n\r\nexport const sortingPaused = () => {\r\n    return {\r\n        type: 'PAUSED'\r\n    }\r\n};\r\n\r\nexport const sortingStopped = () => {\r\n    return {\r\n        type: 'STOPPED'\r\n    }\r\n};\r\n\r\nexport const sortingCompleted = () => {\r\n    return {\r\n        type: 'COMPLETED'\r\n    }\r\n}\r\n\r\nexport const sortingRefresh = () => {\r\n    return {\r\n        type: 'REFRESH'\r\n    }\r\n}","import { setValue } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { setSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport { store } from \"../../store\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\nimport sleep from \"../helpers/sleep\";\r\n\r\n/**\r\n * MERGE_SORT (arr[] , l, r)\r\n * \r\n *   If r > l\r\n *      1. Find the middle point to divide the array into two halves:\r\n *          middle m = l + (r - l) / 2\r\n *      2. Call mergeSort for first half:\r\n *          Call mergeSort(arr, l, m)\r\n *      3. Call mergeSort for second half:\r\n *          Call mergeSort(arr, m + 1, r)\r\n *      4. Merge the two halves sorted in step 2 and 3:\r\n *          Call merge(arr, l, m, r)\r\n */\r\n\r\n/**\r\n * Merges two subarrays of localArray[].\r\n * First subarray is localArray[l..m]\r\n * Second subarray is localArray[m+1..r]\r\n * @param {*} localArray Original Array \r\n * @param {*} leftIdx Starting index for first subarray\r\n * @param {*} midxIdx Ending Index (inclusive) for first subarray\r\n * @param {*} rightIdx Ending Index (inclusive) for second subarray \r\n *                      which start from midIdx + 1\r\n */\r\nasync function merge(localArray, leftIdx, midIdx, rightIdx) {\r\n\r\n    // Sizes of two subarray\r\n    var n1 = midIdx - leftIdx + 1;\r\n    var n2 = rightIdx - midIdx;\r\n\r\n    // Creating temp arrays\r\n    var leftLocalArray = new Array(n1);\r\n    var rightLocalArray = new Array(n2);\r\n\r\n    // Copy data to temp arrays\r\n    for (let i = 0; i < n1; i++)\r\n        leftLocalArray[i] = localArray[[leftIdx + i]];\r\n    for (let j = 0; j < n2; j++)\r\n        rightLocalArray[j] = localArray[midIdx + 1 + j];\r\n\r\n    /**\r\n     *  ..................................................\r\n     *\r\n     *  MERGING THE TEMP ARRAYS BACK INTO localArray[l..r]\r\n     * (Using Merge-K-Sorted-LinkedLists Algorithm)\r\n     * \r\n     *  ..................................................\r\n     */\r\n\r\n    // Initial index of first subarray\r\n    let i = 0;\r\n\r\n    // Initial index of second subarray\r\n    let j = 0;\r\n\r\n    // Initial index of merged subarray\r\n    let k = leftIdx;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    while (i < n1 && j < n2) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * i : leftIdx + 1, j : midIdx + j + 1 because : \r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([leftIdx + i, midIdx + j + 1]));\r\n\r\n        if (leftLocalArray[i] <= rightLocalArray[j]) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            store.dispatch(setValue(k, leftLocalArray[i]));\r\n\r\n            i++;\r\n        }\r\n        else {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            store.dispatch(setValue(k, rightLocalArray[j]));\r\n\r\n            j++;\r\n        }\r\n\r\n        k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // leftLocalArray[], if there are any\r\n    while (i < n1) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Delays according to selected speed\r\n        await sleep();\r\n\r\n        /**\r\n         * i : leftIdx + 1 because : \r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([leftIdx + i]));\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        store.dispatch(setValue(k, leftLocalArray[i]));\r\n\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // rightLocalArrau[], if there are any\r\n    while (j < n2) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * j : midIdx + j + 1 because : \r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([midIdx + j + 1]));\r\n\r\n        // Delays according to selected speed\r\n        await sleep();\r\n\r\n        store.dispatch(setValue(k, rightLocalArray[j]));\r\n\r\n        j++;\r\n        k++;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sorts the array from leftIdx to rightIdx using MergeSort Algorithm\r\n * @param {*} localArray Original Array whose subarray is to be sorted\r\n * @param {*} leftIdx Starting index of subarray\r\n * @param {*} rightIdx Ending Index (inclusive) of subarray \r\n */\r\nasync function mergeSortRecursive(localArray, leftIdx, rightIdx) {\r\n    if (leftIdx >= rightIdx) {\r\n        return;//returns recursively\r\n    }\r\n\r\n    /**\r\n     * Middle index\r\n     */\r\n    const midIdx = leftIdx + parseInt((rightIdx - leftIdx) / 2);\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = await checkCurrentSortingRunStatus()\r\n        .then(async () => {\r\n            await mergeSortRecursive(localArray, leftIdx, midIdx)\r\n            await mergeSortRecursive(localArray, midIdx + 1, rightIdx);\r\n            await merge(localArray, leftIdx, midIdx, rightIdx);\r\n            return true;\r\n        })\r\n        .catch(() => false);\r\n\r\n    // Aborting and returing if Stopped\r\n    if (!continueSort)\r\n        return;\r\n}\r\n\r\n/**\r\n * Perform Merge Sort on the store's Array\r\n */\r\nasync function mergeSort() {\r\n\r\n    /** \r\n      * Gets current state object\r\n      */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    // Performing merge sort on the array\r\n    await mergeSortRecursive(localArray, 0, arraySize - 1);\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default mergeSort;","export const setPivot = (payload) => {\r\n    return {\r\n        type: 'SET_PIVOT',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray, setSortedArray } from \"../../actions/sortedArray\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setPivot } from \"../../actions/pivot\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\n\r\n/**\r\n * \r\n * @param {Array} localArray Copy of the array on which we want to we want to perform Quick Sort\r\n * @param {number} startIdx Starting index \r\n * @param {number} endIdx Ending index \r\n * @returns Pivot index\r\n */\r\nasync function partition(localArray, startIdx, endIdx) {\r\n\r\n    // Taking the last element as the pivot\r\n    /**\r\n     * Value at selected(last element) pivot\r\n     */\r\n    const pivotValue = localArray[endIdx];\r\n    store.dispatch(setPivot(endIdx));\r\n\r\n    /**\r\n     * Shows uptill where the value is smaller than pivotValue\r\n     */\r\n    let pivotIdx = startIdx;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    for (let idx = startIdx; idx < endIdx; idx++) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        store.dispatch(setCurrentlyChecking([idx, pivotIdx]));\r\n\r\n        if (localArray[idx] <= pivotValue) {\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            // Swapping the value\r\n            store.dispatch(swapValues(idx, pivotIdx));\r\n\r\n            // Moving to next element\r\n            pivotIdx++;\r\n        }\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n\r\n    // Check if stopped or paused - delay accoring to selected speed - again check\r\n    continueSort = await continueAfterDelayIfNotStopped();\r\n    // Return if stopped\r\n    if (!continueSort)\r\n        return;\r\n\r\n    // Putting the pivot value in the middle\r\n    store.dispatch(swapValues(endIdx, pivotIdx));\r\n\r\n    return pivotIdx;\r\n};\r\n\r\nasync function quickSortRecursive(localArray, startIdx, endIdx) {\r\n    // Base case or terminating case\r\n    if (startIdx >= endIdx) {\r\n        return;\r\n    }\r\n\r\n    // Returns pivotIndex\r\n    const pivotIdx = await partition(localArray, startIdx, endIdx);\r\n\r\n    store.dispatch(addToSortedArray(pivotIdx));\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = await checkCurrentSortingRunStatus()\r\n        .then(async () => {\r\n            // Recursively apply the same logic to the left and right subarrays\r\n            store.dispatch(addToSortedArray(pivotIdx));\r\n            await quickSortRecursive(localArray, startIdx, pivotIdx - 1);\r\n            // Marking first index for this part as sorted\r\n            store.dispatch(addToSortedArray(startIdx));\r\n            await quickSortRecursive(localArray, pivotIdx + 1, endIdx);\r\n            // Marking first index for this part as sorted\r\n            store.dispatch(addToSortedArray(pivotIdx + 1));\r\n        })\r\n        .catch(() => false);\r\n    // Aborting and returing if Stopped\r\n    if (!continueSort)\r\n        return;\r\n}\r\n\r\n/**\r\n * Performs quick sort on the store's state array\r\n */\r\nasync function quickSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    // Performing quick sort on the array\r\n    await quickSortRecursive(localArray, 0, arraySize - 1);\r\n\r\n    // Remove the pivot regardless of whether sort was completed or stoped\r\n    store.dispatch(setPivot(null));\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default quickSort;","import { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray, setSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport { store } from \"../../store\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n\r\n/**\r\n * Since a Binary Heap is a Complete Binary Tree, it can be easily represented\r\n * as an array and the array-based representation is space-efficient.\r\n * If the parent node is stored at index I, the left child can be\r\n * calculated by 2 * I + 1 and the right child by 2 * I + 2\r\n * (assuming the indexing starts at 0).\r\n */\r\n\r\n/**\r\n * HEAP SORT Algorithm for sorting in increasing order:\r\n *  1. Build a max heap from the input data.\r\n *  2. At this point, the largest item is stored at the root of the heap.\r\n *     Replace it with the last item of the heap followed by reducing the\r\n *     size of heap by one. Finally, heapify the root of the tree.\r\n *  3. Repeat step 2 while the size of the heap is greater than 1.\r\n */\r\n\r\n/**\r\n * Heapifies a subtree rooted with node i which is\r\n * an index in localArray. arraySize is size of heap\r\n * @param {Array} localArray An array which represents heap\r\n * @param {Number} nodeIndex An index which represents root node of the subtree\r\n * @param {Number} arraySize Size of the heap array\r\n */\r\nasync function heapify(localArray, nodeIndex, arraySize) {\r\n    let largest = nodeIndex; // Initialize largest as root\r\n    const left = 2 * nodeIndex + 1; // left = 2*i + 1\r\n    const right = 2 * nodeIndex + 2; // right = 2*i + 2\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // If left child is larger than root\r\n    if (left < arraySize && localArray[left] > localArray[largest])\r\n        largest = left;\r\n\r\n    // If right child is larger than largest so far\r\n    if (right < arraySize && localArray[right] > localArray[largest])\r\n        largest = right;\r\n\r\n\r\n    // Check if stopped or paused - delay accoring to selected speed - again check\r\n    continueSort = await continueAfterDelayIfNotStopped();\r\n    // Return if stopped\r\n    if (!continueSort)\r\n        return;\r\n\r\n    /**\r\n     * left and right are being currently checked and also\r\n     * need to check to make sure currently checking doesn't \r\n     * show more than current heap size\r\n     */\r\n    store.dispatch(setCurrentlyChecking([largest, nodeIndex]));\r\n\r\n    // If largest is not root\r\n    if (largest !== nodeIndex) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Swaps the values in store's state Array\r\n        store.dispatch(swapValues(largest, nodeIndex));\r\n\r\n        // Recursively heapify the affected sub-tree\r\n        await heapify(localArray, largest, arraySize);\r\n    }\r\n}\r\n/**\r\n * Helpeer function for implementing heap sort on localArray\r\n * @param {Array} localArray An array which represents heap\r\n */\r\nasync function HeapSort(localArray) {\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = localArray.length;\r\n\r\n    // Build heap (rearrange localArray)\r\n    for (let nodeIndex = Math.floor(arraySize / 2) - 1; nodeIndex >= 0; nodeIndex--) {\r\n        /**\r\n         * Aborts the sort if value is false\r\n         */\r\n        let continueSort = await checkCurrentSortingRunStatus()\r\n            .then(async () => {\r\n                await heapify(localArray, nodeIndex, arraySize);\r\n                return true;\r\n            })\r\n            .catch(() => false);\r\n        // Aborting and returing if Stopped\r\n        if (!continueSort)\r\n            return;\r\n    }\r\n\r\n    // One by one extract an element from heap\r\n    for (let extractElementIterator = arraySize - 1; extractElementIterator > 0; extractElementIterator--) {\r\n\r\n        /**\r\n         * Aborts the sort if value is false\r\n         */\r\n        let continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Move current root to end\r\n        store.dispatch(swapValues(0, extractElementIterator));\r\n\r\n\r\n        // Emptying the currently checking array to prevent having a single bar as marked each time\r\n        store.dispatch(setCurrentlyChecking([]));\r\n\r\n        // Add the last moved bar to sorted Array\r\n        store.dispatch(addToSortedArray(extractElementIterator));\r\n\r\n        // Call max heapify on the reduced heap\r\n        continueSort = await checkCurrentSortingRunStatus()\r\n            .then(async () => {\r\n                await heapify(localArray, 0, extractElementIterator);\r\n                return true;\r\n            })\r\n            .catch(() => false);\r\n        // Aborting and returing if Stopped\r\n        if (!continueSort)\r\n            return;\r\n    }\r\n}\r\n\r\n/**\r\n * Performs Heap Sort on the store's Array\r\n */\r\nasync function heapSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    // We perform the Heap Sort on store's state array\r\n    await HeapSort(localArray);\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default heapSort;","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n// Function to sort an array using insertion sort\r\nasync function insertionSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // Insetion Sort Algorithm\r\n\r\n    for (let iterator = 0; iterator < arraySize; iterator++) {\r\n        /**\r\n         * Backward moving iterator for current element\r\n         */\r\n        let backwardIterator = iterator;\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Current element is marked\r\n        store.dispatch(setCurrentlyChecking([backwardIterator]));\r\n\r\n        /**\r\n         * Adding the current element's index to sortedArray as\r\n         * all array including this position is sorted\r\n         */\r\n        store.dispatch(addToSortedArray(iterator));\r\n\r\n        /**\r\n         * Keep swpping the current element with previous \r\n         * elements untill it reaches the correct position\r\n         * i.e. previous element is smaller or equal to it\r\n         */\r\n        while (backwardIterator > 0 && localArray[backwardIterator - 1] > localArray[backwardIterator]) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            /**\r\n             * Swapping the currentElement with \r\n             * previous element as it is bigger\r\n             */\r\n            store.dispatch(swapValues(backwardIterator - 1, backwardIterator));\r\n\r\n            // Current element is marked as it has now moved to one previous postition\r\n            store.dispatch(setCurrentlyChecking([backwardIterator - 1]));\r\n\r\n            backwardIterator--;\r\n        }\r\n    }\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default insertionSort;\r\n","import bubbleSort from \"./allAlgorithms/bubbleSort\";\r\nimport mergeSort from \"./allAlgorithms/mergeSort\";\r\nimport quickSort from \"./allAlgorithms/quickSort\";\r\nimport heapSort from \"./allAlgorithms/heapSort\";\r\nimport insertionSort from \"./allAlgorithms/insertionSort\";\r\n\r\n/**\r\n * An array of objects where each \r\n * object is a sorting algorithm\r\n */\r\nconst ALGORITHMS = [\r\n    {\r\n        id: 0,\r\n        name: 'Merge Sort',\r\n        value: 'MERGE_SORT',\r\n        function: mergeSort\r\n    },\r\n    {\r\n        id: 1,\r\n        name: 'Bubble Sort',\r\n        value: 'BUBBLE_SORT',\r\n        function: bubbleSort\r\n    },\r\n    {\r\n        id: 2,\r\n        name: 'Heap Sort',\r\n        value: 'HEAP_SORT',\r\n        function: heapSort\r\n    },\r\n    {\r\n        id: 3,\r\n        name: 'Insertion Sort',\r\n        value: 'INSERTION_SORT',\r\n        function: insertionSort\r\n    },\r\n    {\r\n        id: 4,\r\n        name: 'Quick Sort',\r\n        value: 'QUICK_SORT',\r\n        function: quickSort\r\n    },\r\n    {\r\n        id: 5,\r\n        name: 'Selection Sort',\r\n        value: 'SELECTION_SORT',\r\n        // function: ()\r\n    }\r\n]\r\n\r\nexport default ALGORITHMS;","import ALGORITHMS from \"./ALGORITHMS\";\r\n\r\n/**\r\n * Return algorithm object of specified Id\r\n * @param {*} algorithmId Algorithm Id\r\n * @returns Algorithm object\r\n */\r\nfunction getAlgorithmById(algorithmId) {\r\n\r\n    // If valid algorithm is selected, return its object\r\n    for (let algorithmsIterator = 0; algorithmsIterator < ALGORITHMS.length; algorithmsIterator++) {\r\n        if (ALGORITHMS[algorithmsIterator].id === algorithmId) {\r\n            return ALGORITHMS[algorithmsIterator];\r\n        }\r\n    }\r\n\r\n    // If algorithm Id doesn't match with any present Ids\r\n    console.log('No matching algorithm found with Id : \"' + algorithmId + '\"');\r\n    return {};\r\n}\r\n\r\nexport default getAlgorithmById;","import { store } from \"../store\";\r\nimport { sortingStarted } from \"../actions/sortingRunStatus\";\r\nimport ALGORITHMS from \"./ALGORITHMS\";\r\nimport getAlgorithmById from \"./getAlgorithmById\";\r\n\r\n/**\r\n * Starts the sorting process\r\n */\r\nfunction sort() {\r\n    /**\r\n     * Store's state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * Algorithm object in store's state\r\n     */\r\n    let algorithm = state.algorithm;\r\n\r\n    /**\r\n     * As when default is selected, it only has id in its object,\r\n     * so we can get the whole object by this id\r\n     */\r\n    algorithm = getAlgorithmById(algorithm.id);\r\n\r\n    if (ALGORITHMS.includes(algorithm)) {\r\n        // If valid algorithm is selected, call its function\r\n        store.dispatch(sortingStarted());\r\n        algorithm.function();\r\n    } else {\r\n        // If not valid algorithm, show error\r\n        console.error(\"No sorting algorithm selected, can't sort\");\r\n        return;\r\n    }\r\n}\r\n\r\nexport default sort;","import ControlBar from \"./ControlBar.jsx\";\r\nimport { connect } from \"react-redux\";\r\nimport { ARRAY_MIN_VALUE, ARRAY_MAX_VALUE, DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults/index.js\";\r\nimport { ALGORITHMS, getAlgorithmById, sort } from \"../../algorithms\"\r\nimport { setArray } from \"../../actions/array\";\r\nimport { setSpeed } from \"../../actions/speed/index.js\";\r\nimport { setSortedArray } from \"../../actions/sortedArray/index.js\";\r\nimport { setAlgorithm } from \"../../actions/algorithm\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking/index.js\";\r\nimport { sortingContinued, sortingPaused, sortingRefresh, sortingStopped } from \"../../actions/sortingRunStatus/index.js\";\r\n\r\n/**\r\n * Return a random value in specified range\r\n * @param {*} lowerLimit Least possible random number\r\n * @param {*} upperLimit Maximum possible random number\r\n * @returns A random number between lowerLimit and UpperLimit (both inclusive)\r\n */\r\nconst getRandomValue = (lowerLimit, upperLimit) => {\r\n    return Math.floor(Math.random() * (upperLimit + 1)) + lowerLimit;\r\n}\r\n\r\n/**\r\n * Returns a random array pf specified Length\r\n * @param {*} arraySize Length of the array to be formed\r\n * @returns A random values array of length = arraySize\r\n */\r\nconst generateRandomArray = (arraySize) => {\r\n    const array = [];\r\n    const lowerLimit = ARRAY_MIN_VALUE;\r\n    const upperLimit = ARRAY_MAX_VALUE;\r\n    for (var i = 0; i < arraySize; i++) {\r\n        array.push(getRandomValue(lowerLimit, upperLimit));\r\n    }\r\n    return array;\r\n}\r\n\r\n/**\r\n * Takes the dispatch method as argument \r\n * and dispatches the methods for reseting \r\n * sortedArray and currentlyChecking array\r\n */\r\nconst empty_CurrentlyArray_and_SortedArray = (dispatch) => {\r\n    dispatch(setCurrentlyChecking([]));\r\n    dispatch(setSortedArray([]));\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const sortingRunStatus = state.sortingRunStatus;\r\n    const algorithms = ALGORITHMS;\r\n    const defaultAlgorithm = getAlgorithmById(DEFAULT_SELECTED_ALGORITHM_ID);\r\n    return { array, algorithm, sortingRunStatus, algorithms, defaultAlgorithm };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n    /**\r\n     * Generats a random array of given size and sets it through dispatch\r\n     * @param {*} arraySize Length of the array to be generated\r\n     */\r\n    generateArray: (arraySize) => {\r\n        const randomGeneratedArray = generateRandomArray(arraySize);\r\n        dispatch(setArray(randomGeneratedArray));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Changes the algorithm through dispatch\r\n     * @param {*} selectedAlgo New algorithm to be set \r\n     */\r\n    changeAlgorithm: (selectedAlgo) => {\r\n        dispatch(setAlgorithm(selectedAlgo));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Changes the sorting display speed of algorithm\r\n     * @param {*} selectedSpeed Selected Speed\r\n     */\r\n    changeSpeed: (selectedSpeed) => {\r\n        dispatch(setSpeed(selectedSpeed));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Starts the sorting\r\n     */\r\n    startSorting: () => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        sort();\r\n    },\r\n\r\n    /**\r\n     * Pauses the current sorting process\r\n     * by dispatching the sortingPaused\r\n     */\r\n    pauseSorting: () => {\r\n        dispatch(sortingPaused());\r\n    },\r\n\r\n    /**\r\n     * Continues the paused sorting process\r\n     * by dispatching sortingContinued\r\n     */\r\n    continueSorting: () => {\r\n        dispatch(sortingContinued());\r\n    },\r\n\r\n    /**\r\n     * Stops the current sorting process\r\n     * by dispatching sortingStopped\r\n     */\r\n    stopSorting: () => {\r\n        dispatch(sortingStopped());\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n    }\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ControlBar);","import { getAlgorithmById } from \"../../algorithms\";\r\nimport { DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults\";\r\n\r\nexport const setAlgorithm = (payload = getAlgorithmById(DEFAULT_SELECTED_ALGORITHM_ID)) => {\r\n    return {\r\n        type: 'SET_ALGORITHM',\r\n        payload: payload\r\n    }\r\n};\r\n","export const setSpeed = (payload) => {\r\n    return {\r\n        type: 'SET_SPEED',\r\n        payload: payload\r\n    }\r\n};\r\n","import React from \"react\";\r\nimport ArrayBars from \"../ArrayBars/ArrayBars\";\r\nimport ControlBar from \"../ControlBar/ControlBar\";\r\n\r\nfunction SortingVisualizer() {\r\n    return (\r\n        <div>\r\n            <ControlBar />\r\n            <ArrayBars />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SortingVisualizer;","import React from \"react\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <SortingVisualizer />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport { store } from './store';\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n\n  //wrapping the app around store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}