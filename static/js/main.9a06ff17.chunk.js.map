{"version":3,"sources":["defaults/index.js","components/ArrayBars/ArrayBars.jsx","components/ArrayBars/ArrayBars.js","components/ControlBar/ControlBar.jsx","utilities/getNewArrayWithSwappedValues.js","utilities/setValueInArrayUsingSplice.js","reducers/arrayReducer/index.js","reducers/index.js","reducers/algorithmRedcuer/index.js","reducers/speedReducer/index.js","reducers/currenltyCheckingReducer/index.js","reducers/pivotReducer/index.js","reducers/sortedArrayReducer/index.js","store/index.js","actions/array/index.js","actions/currentlyChecking/index.js","actions/sortedArray/index.js","algorithms/helpers/getTimeDelay.js","algorithms/helpers/storeDispatch.js","algorithms/bubbleSort.js","algorithms/mergeSort.js","actions/pivot/index.js","algorithms/quickSort.js","actions/speed/index.js","components/ControlBar/ControlBar.js","actions/algorithm/index.js","algorithms/index.js","components/SortingVisualizer/SortingVisualizer.jsx","components/App.js","index.js"],"names":["DEFAULT_SELECTED_ALGORITHM","MARGIN_BETWEEN_BARS","arraySize","SCREEN_PERCENTAGE_TO_OCCUPY","ArrayBars","getMarginBetweenBars","getBarsDisplayAreaWidth","screenWidth","window","screen","width","Math","floor","getBarWidth","barsDisplayAreaWidth","marginBetween","this","props","array","currentlyChecking","pivot","sortedArray","length","barWidth","displayBarHeight","className","style","map","bar","idx","backgroundColor","includes","id","height","marginLeft","Component","connect","state","algorithm","dispatch","ControlBar","resetArray","generateArray","changeArraySize","event","target","value","getAlgorithmNameInTitleCase","console","error","changeAlgorithm","selectedAlgo","selectedAlgoTitleCase","document","getElementById","innerText","changeSpeed","selectedSpeed","Number","startSorting","sort","onClick","type","min","max","defaultValue","onChange","checkIfIndexOutOfBounds","index","getNewArrayWithSwappedValues","swappingIndicesArray","firstIdx","secondIdx","firstIdxValue","secondIdxValue","arrayWithSwappedValues","swappingIterator","push","setValueInArrayUsingSplice","replaceCounter","splice","rootReducer","combineReducers","action","payload","data","speed","concat","store","createStore","__REDUX_DEVTOOLS_EXTENSION__","swapValues","setValue","setCurrentlyChecking","setSortedArray","addToSortedArray","getTimeDelay","getState","storeDispatch","storeElementPayload","storeElementReducer","updateArrayAfterTimeDelay","i","j","needToSwap","addToSorted","timeDelayIterator","setTimeout","currentIndicesArray","bubbleSort","localArray","slice","temp","Queue","QueueObject","k","mergeSortRecursive","leftIdx","rightIdx","midIdx","parseInt","n1","n2","leftLocalArray","Array","rightLocalArray","merge","mergeSort","allIndicesArray","setPivot","indices","quickSortRecursive","startIdx","endIdx","pivotIdx","pivotValue","partition","quickSort","getRandomValue","lowerLimit","upperLimit","random","empty_CurrentlyArray_and_SortedArray","randomGeneratedArray","generateRandomArray","SortingVisualizer","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.9a06ff17.chunk.js","sourcesContent":["/**\r\n * Array's lowest value\r\n */\r\nconst ARRAY_MIN_VALUE = 10;\r\n/**\r\n * Array's largest value\r\n * ARRAY_MAX_VALUE > 500 will overlap with Control-Bar\r\n */\r\nconst ARRAY_MAX_VALUE = 450;\r\n\r\n/**\r\n * Sorting speed range\r\n * SORTING_SPEED_LOWER_LIMIT is 0 always\r\n */\r\nconst SORTING_SPEED_UPPER_LIMIT = 800;\r\nconst DEFAULT_SELECTED_SPEED = 600;\r\n\r\n/**\r\n * Minimum array length\r\n */\r\nconst MIN_ARRAY_SIZE = 10;\r\n/**\r\n * Maximum array length\r\n */\r\nconst MAX_ARRAY_SIZE = 200;\r\nconst DEFAULT_ARRAY_SIZE = 100;\r\n\r\n/**\r\n * Bar colour when its neither sorted \r\n * nor in the process of being sorted\r\n */\r\nconst BAR__COLOUR_DEFAULT = 'rgb(0, 204, 255)';\r\n/**\r\n * Bar colour when its in the process for sorting\r\n */\r\nconst BAR_COLOUR_WHILE_CHECKING = 'blue';\r\n/**\r\n * Bar colour when it has been sorted\r\n */\r\nconst BAR_COLOUR_SORTED = 'purple';\r\n/**\r\n * Bar colour when it is pivot\r\n */\r\nconst BAR_COLOUR_PIVOT = 'rgb(102, 255, 51)';\r\n\r\n\r\n/**\r\n * Default selected sorting algorithm\r\n * shown in dropdown algo selector\r\n */\r\nconst DEFAULT_SELECTED_ALGORITHM = 'BUBBLE_SORT';\r\n\r\n/**\r\n * tells margin between bars\r\n * @param {*} arraySize the length of array \r\n * @returns space between each bar depending upon the arraySize\r\n */\r\nconst MARGIN_BETWEEN_BARS = (arraySize) => {\r\n    return arraySize <= 10 ? 4 : arraySize <= 50 ? 2 : 1\r\n};\r\n\r\n/**\r\n * tells the amount of screen to occupy\r\n * @param {*} arraySize the length of the array\r\n * @returns the amount of screen to occupy in \r\n *          terms of decimal from 0-1 where \r\n *          0 shows empty space and\r\n *          1 shows full screen \r\n */\r\nconst SCREEN_PERCENTAGE_TO_OCCUPY = (arraySize) => {\r\n    return arraySize <= 10 ? 0.33 : arraySize <= 50 ? 0.50 : 0.66;\r\n}\r\n\r\n/**\r\n * .............................\r\n * EXPORTS\r\n * ............................. \r\n */\r\nexport {\r\n    ARRAY_MIN_VALUE,\r\n    ARRAY_MAX_VALUE,\r\n    SORTING_SPEED_UPPER_LIMIT,\r\n    DEFAULT_SELECTED_SPEED,\r\n    MIN_ARRAY_SIZE,\r\n    MAX_ARRAY_SIZE,\r\n    DEFAULT_ARRAY_SIZE,\r\n    BAR__COLOUR_DEFAULT,\r\n    BAR_COLOUR_WHILE_CHECKING,\r\n    BAR_COLOUR_SORTED,\r\n    BAR_COLOUR_PIVOT,\r\n    DEFAULT_SELECTED_ALGORITHM,\r\n    MARGIN_BETWEEN_BARS,\r\n    SCREEN_PERCENTAGE_TO_OCCUPY\r\n}","import React, { Component } from \"react\"\r\nimport { BAR_COLOUR_PIVOT, BAR_COLOUR_SORTED, BAR_COLOUR_WHILE_CHECKING, BAR__COLOUR_DEFAULT, MARGIN_BETWEEN_BARS, SCREEN_PERCENTAGE_TO_OCCUPY } from \"../../defaults\";\r\nimport \"./ArrayBars.css\";\r\n\r\nclass ArrayBars extends Component {\r\n\r\n    getMarginBetweenBars = (arraySize) => {\r\n        const marginBetween = MARGIN_BETWEEN_BARS(arraySize);\r\n        return marginBetween;\r\n    }\r\n\r\n    getBarsDisplayAreaWidth = (arraySize) => {\r\n        const screenWidth = window.screen.width;\r\n        const barsDisplayAreaWidth = Math.floor(screenWidth * SCREEN_PERCENTAGE_TO_OCCUPY(arraySize));\r\n        return barsDisplayAreaWidth;\r\n    }\r\n\r\n    getBarWidth = (arraySize, barsDisplayAreaWidth, marginBetween) => {\r\n        const barWidth = (barsDisplayAreaWidth - (marginBetween * arraySize)) / arraySize;\r\n        return barWidth;\r\n    }\r\n\r\n    render() {\r\n\r\n        const { array, currentlyChecking, pivot, sortedArray } = this.props;\r\n\r\n        const arraySize = array.length;\r\n        const barsDisplayAreaWidth = this.getBarsDisplayAreaWidth(arraySize);\r\n        const marginBetween = this.getMarginBetweenBars(arraySize);\r\n        const barWidth = this.getBarWidth(arraySize, barsDisplayAreaWidth, marginBetween);\r\n        const displayBarHeight = arraySize < 23 ? true : false;\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"bars\" style={{ width: barsDisplayAreaWidth }}>\r\n                    {\r\n                        array.length > 0 && array.map((bar, idx) => {\r\n                            let backgroundColor = currentlyChecking.includes(idx) ? BAR_COLOUR_WHILE_CHECKING : BAR__COLOUR_DEFAULT;\r\n                            backgroundColor = idx === pivot ? BAR_COLOUR_PIVOT : backgroundColor;\r\n                            backgroundColor = sortedArray.includes(idx) ? BAR_COLOUR_SORTED : backgroundColor;\r\n                            return (\r\n                                <div \r\n                                id={idx} \r\n                                className=\"bar\" \r\n                                style={{ width: \r\n                                barWidth, height: bar, \r\n                                backgroundColor: backgroundColor, \r\n                                marginLeft: marginBetween }} key={idx}>\r\n                                    {displayBarHeight ? bar : ''}\r\n                                </div>\r\n                            );\r\n                        })\r\n                    }\r\n                </div >\r\n\r\n                <div className='base-block bg-dark text-center'></div>\r\n\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default ArrayBars;","import ArrayBars from \"./ArrayBars.jsx\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const currentlyChecking = state.currentlyChecking;\r\n    const pivot = state.pivot;\r\n    const sortedArray = state.sortedArray;\r\n    return { array, algorithm, currentlyChecking, pivot, sortedArray };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n})\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ArrayBars);","import React, { Component } from \"react\";\r\nimport { DEFAULT_ARRAY_SIZE, DEFAULT_SELECTED_SPEED, MAX_ARRAY_SIZE, MIN_ARRAY_SIZE, SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\nimport \"./ControlBar.css\";\r\n\r\nclass ControlBar extends Component {\r\n\r\n  resetArray = (arraySize) => {\r\n    this.props.generateArray(arraySize);\r\n  }\r\n\r\n  changeArraySize = (event) => {\r\n    this.resetArray(event.target.value);\r\n  }\r\n\r\n  /**\r\n   * Returns the algorithm name in Title Case\r\n   * @param {*} algorithm The algorithm whose name is to be returned in Title Case\r\n   * @returns Algorithm name in Title Case\r\n   */\r\n  getAlgorithmNameInTitleCase = (algorithm) => {\r\n    switch (algorithm) {\r\n      case 'BUBBLE_SORT': return 'Bubble Sort';\r\n      case 'MERGE_SORT': return 'Merge Sort';\r\n      case 'QUICK_SORT': return 'Quick Sort';\r\n      default: {\r\n        console.error('No algorithm provided for conversion to title case');\r\n      }\r\n    }\r\n  }\r\n\r\n  changeAlgorithm = (event) => {\r\n    const selectedAlgo = event.target.value;\r\n    this.props.changeAlgorithm(selectedAlgo);\r\n    const selectedAlgoTitleCase = this.getAlgorithmNameInTitleCase(selectedAlgo);\r\n    document.getElementById(\"dropdown-algo-selector\").innerText = selectedAlgoTitleCase;\r\n  }\r\n\r\n  changeSpeed = (event) => {\r\n    const selectedSpeed = (Number)(event.target.value);\r\n    this.props.changeSpeed(selectedSpeed);\r\n  }\r\n\r\n  startSorting = () => {\r\n    this.props.sort();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetArray(DEFAULT_ARRAY_SIZE);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { array } = this.props;\r\n    const arraySize = array.length;\r\n\r\n    return (\r\n      <div className='nav navbar navbar-dark bg-dark text-center p-3'>\r\n        <div className='navbar navbar-brand col-3 text-center m-0 p-0'>\r\n          <h2>SORTING VISUALIZER</h2>\r\n        </div>\r\n\r\n        <div className=\"col-3  text-center\">\r\n          <button className='generate-array-button btn btn-white btn-round mr-2'\r\n            onClick={() => { this.resetArray(arraySize) }}>\r\n            Generate New Array\r\n          </button>\r\n\r\n          <div className=\"btn-group\">\r\n            <button\r\n              type=\"button\"\r\n              id=\"dropdown-algo-selector\"\r\n              className=\"btn btn-success dropdown-toggle\"\r\n              data-toggle=\"dropdown\" \r\n              aria-haspopup=\"true\"\r\n              aria-expanded=\"false\">\r\n              Bubble Sort\r\n            </button>\r\n            <div className=\"dropdown-menu\">\r\n            <h1 className=\"dropdown-header text-large\">Select Algorithm</h1>\r\n              <button\r\n                className=\"dropdown-item\"\r\n                value='BUBBLE_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Bubble Sort\r\n              </button>\r\n              <div className=\"dropdown-divider\"></div>\r\n              <button className=\"dropdown-item\"\r\n                value='MERGE_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Merge Sort\r\n              </button>\r\n              <div className=\"dropdown-divider\"></div>\r\n              <button\r\n                className=\"dropdown-item\"\r\n                value='QUICK_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Quick Sort\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"col-2 text-center row\">\r\n          <div className='text-white col-12'>Array Size</div>\r\n          <div className='text-white col-12'>Sorting Speed</div>\r\n          <div className='col-3 text-right'></div>\r\n        </div>\r\n\r\n        <div className='col-2 row'>\r\n          <input\r\n            className='array-size-range-button mb-1'\r\n            type=\"range\"\r\n            min={MIN_ARRAY_SIZE}\r\n            max={MAX_ARRAY_SIZE}\r\n            defaultValue={DEFAULT_ARRAY_SIZE}\r\n            onChange={this.changeArraySize}\r\n          />\r\n          <input\r\n            className='sorting-speed-range-button mt-1'\r\n            type=\"range\"\r\n            min=\"1\"\r\n            max={SORTING_SPEED_UPPER_LIMIT}\r\n            defaultValue={DEFAULT_SELECTED_SPEED}\r\n            onChange={this.changeSpeed}\r\n          />\r\n        </div>\r\n\r\n        <button\r\n          className=\"btn btn-success mr-4 col-2\"\r\n          onClick={this.startSorting}>\r\n          START SORTING\r\n        </button>\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default ControlBar;","function checkIfIndexOutOfBounds(index, arraySize) {\r\n    if (index < 0 || index >= arraySize) {\r\n        console.error(index + \" passed for swapping is out of bounds for \" + arraySize + \", can't swap values.\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} array Array whose values need to be swapped \r\n * @param {*} swappingIndicesArray An Array of 2 indices whose values are to be swapped\r\n * @returns A new array with swapped values\r\n */\r\nexport function getNewArrayWithSwappedValues(array, swappingIndicesArray) {\r\n\r\n    // show error if exactly 2 indices are not passed\r\n    if (swappingIndicesArray.length !== 2) {\r\n        console.error(\"An array of 2 indices required for swapping instead recieved \" + swappingIndicesArray.length + \" values , can't swap values\");\r\n        return array;\r\n    }\r\n\r\n    const arraySize = array.length;\r\n\r\n    let firstIdx = swappingIndicesArray[0];\r\n    let secondIdx = swappingIndicesArray[1];\r\n\r\n    // first and second index both should be in range 0 to (arraySize - 1)\r\n    if (checkIfIndexOutOfBounds(firstIdx, arraySize) || checkIfIndexOutOfBounds(secondIdx, arraySize)) {\r\n        return array;\r\n    }\r\n\r\n    let firstIdxValue = null;\r\n    let secondIdxValue = null;\r\n    const arrayWithSwappedValues = [];\r\n\r\n    // loop to traverse on original array\r\n    for (var swappingIterator = 0; swappingIterator < arraySize; swappingIterator++) {\r\n        /**\r\n         * store the values of first and second indices and\r\n         * copy rest all indices values\r\n         */\r\n        if (swappingIterator === firstIdx)\r\n            firstIdxValue = array[swappingIterator];\r\n        else if (swappingIterator === secondIdx)\r\n            secondIdxValue = array[swappingIterator];\r\n\r\n        arrayWithSwappedValues.push(array[swappingIterator]);\r\n    }\r\n\r\n    arrayWithSwappedValues[firstIdx] = secondIdxValue;\r\n    arrayWithSwappedValues[secondIdx] = firstIdxValue;\r\n\r\n    return arrayWithSwappedValues;\r\n}","/**\r\n * Returns the array with value inserted at given index\r\n * @param {Array} array Array in which value needs to be inserted\r\n * @param {Number} index Index at wich value gets inserted\r\n * @param {Number} replaceCounter Number of indices to replace after given index by the given value\r\n * @param {*} value Value which is to be inserted\r\n * @returns Array with value inserted at index \r\n */\r\nexport function setValueInArrayUsingSplice(array, index, replaceCounter, value) {\r\n    array.splice(index, replaceCounter, value);\r\n    return array;\r\n}","import { getNewArrayWithSwappedValues, setValueInArrayUsingSplice } from \"../../utilities\";\r\n\r\nexport const array = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_ARRAY':\r\n            return action.payload;\r\n        case 'SWAP_VALUES':\r\n            return getNewArrayWithSwappedValues(state, action.payload)\r\n        case 'SET_VALUE':\r\n            return setValueInArrayUsingSplice(state, action.payload.id, 1, action.payload.data);\r\n        default: return state;\r\n    }\r\n}","import { combineReducers } from \"redux\";\r\nimport { algorithm } from \"./algorithmRedcuer\";\r\nimport { array } from \"./arrayReducer\";\r\nimport { currentlyChecking } from \"./currenltyCheckingReducer\";\r\nimport { speed } from \"./speedReducer\";\r\nimport { pivot } from \"./pivotReducer\";\r\nimport { sortedArray } from \"./sortedArrayReducer\";\r\n\r\nconst rootReducer = combineReducers({\r\n    array,\r\n    algorithm,\r\n    speed,\r\n    currentlyChecking,\r\n    pivot,\r\n    sortedArray\r\n});\r\n\r\nexport default rootReducer;","import { DEFAULT_SELECTED_ALGORITHM } from \"../../defaults\";\r\n\r\nexport const algorithm = (state = DEFAULT_SELECTED_ALGORITHM, action) => {\r\n    switch (action.type) {\r\n        case 'SET_ALGORITHM':\r\n            return  action.payload;\r\n        default: return state;\r\n    }\r\n}","import { DEFAULT_SELECTED_SPEED } from \"../../defaults\";\r\n\r\nexport const speed = (state = DEFAULT_SELECTED_SPEED, action) => {\r\n    switch (action.type) {\r\n        case 'SET_SPEED':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","/**\r\n * It denotes the array of indices currently \r\n * being checked by the algorithm for sorting\r\n */\r\nexport const currentlyChecking = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_CURRENTLYCHECKING':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const pivot = (state = -1, action) => {\r\n    switch (action.type) {\r\n        case 'SET_PIVOT':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortedArray = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_SORTEDARRAY':\r\n            return action.payload;\r\n        case 'ADD_TO_SORTEDARRAY':\r\n            return state.concat(action.payload);\r\n        default: return state;\r\n    }\r\n}","import rootReducer from \"../reducers\";\r\nimport { createStore } from \"redux\";\r\n\r\nexport const store = createStore(\r\n    rootReducer,\r\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);","export const setArray = (payload) => {\r\n    return {\r\n        type: 'SET_ARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * \r\n * @param {*} payload An array of indices i, j \r\n * where swapping needs to be done as :\r\n * Array[i] <-> Array[j]\r\n */\r\nexport const swapValues = (payload) => {\r\n    return {\r\n        type: 'SWAP_VALUES',\r\n        payload: payload\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sets value at specific index in store's State Array\r\n * @param {Object} payload\r\n * index : Index at which value needs to be stored,\r\n * value : The value which needs to be inserted\r\n * @returns An action object with type and payload\r\n */\r\nexport const setValue = (payload) => {\r\n    return {\r\n        type: 'SET_VALUE',\r\n        payload: {\r\n            id: payload.index,\r\n            data: payload.value\r\n        }\r\n    }\r\n}\r\n","export const setCurrentlyChecking = (payload) => {\r\n    return {\r\n        type: 'SET_CURRENTLYCHECKING',\r\n        payload: payload\r\n    }\r\n};\r\n","export const setSortedArray = (payload) => {\r\n    return {\r\n        type: 'SET_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\nexport const addToSortedArray = (payload) => {\r\n    return {\r\n        type: 'ADD_TO_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\";\r\nimport { SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\n\r\n/**\r\n * @returns the timedelay between each step,\r\n *          so if speed is 10 and speed range is 0-100\r\n *          timedelay will be of 90ms\r\n */\r\nexport function getTimeDelay() {\r\n    const state = store.getState();\r\n    const speed = state.speed;\r\n    return SORTING_SPEED_UPPER_LIMIT - speed;\r\n}","import { store } from \"../../store\";\r\n\r\n/**\r\n * @param {*} storeElementPayload The payload for the store element whose state needs to be updated\r\n * @param {*} storeElementReducer The reducer for that specific change to the element\r\n */\r\nexport function storeDispatch(storeElementPayload, storeElementReducer) {\r\n    store.dispatch(storeElementReducer(storeElementPayload));\r\n}","import { store } from \"../store\";\r\nimport { swapValues } from \"../actions/array\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../actions/sortedArray\";\r\nimport { getTimeDelay, storeDispatch } from \"./helpers\";\r\n\r\n/**\r\n * Executes and updates the array with dispatches after timeDelays\r\n * @param {number} i Main iterator in bubble sort\r\n * @param {number} j Checking iterator in bubble sort\r\n * @param {number} arraySize Length of the array\r\n * @param {boolean} needToSwap Represents whether value at j index was swapped with (j + 1)'s value\r\n * @param {boolean} addToSorted Shows whether its the last j value which has been sorted\r\n * @param {number} timeDelayIterator An increasing value which prevents running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(i, j, arraySize, needToSwap, addToSorted, timeDelayIterator) {\r\n\r\n    setTimeout(() => {\r\n\r\n        const currentIndicesArray = [j, j + 1];\r\n\r\n        storeDispatch(currentIndicesArray, setCurrentlyChecking);\r\n\r\n        if (needToSwap) {\r\n            storeDispatch(currentIndicesArray, swapValues);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n\r\n        if (addToSorted) {\r\n            storeDispatch(j + 1, addToSortedArray);\r\n            /**\r\n             * As the bar at 0th position also needs \r\n             * to be added to sortedArray, which doesn't \r\n             * get called from inside j loop\r\n             */\r\n            if (i === arraySize - 2) {\r\n                storeDispatch(0, addToSortedArray);\r\n            }\r\n        }\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n\r\n};\r\n\r\n/**\r\n * Performs Bubble Sort on the store's Array\r\n */\r\nfunction bubbleSort() {\r\n\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * setTimeout() function inside a loop stacks up and\r\n     * executes only after the loopand all the iterations \r\n     * start together at same time\r\n     * \r\n     * To prevent simultaneous executions of setTimeouts,\r\n     * we pass an iterator with increasing values.\r\n     */\r\n    let timeDelayIterator = 0;\r\n\r\n\r\n    /**\r\n     * Its a copy of store's state Array.\r\n     * Here .slice() is really important as\r\n     * it gives us a deep copy else whatever changes\r\n     * we make in the loop, they will get updated immediately\r\n     */\r\n    const localArray = state.array.slice();\r\n    const arraySize = state.array.length;\r\n\r\n    // bubble sort algorithm \r\n    for (var i = 0; i < arraySize - 1; i++) {\r\n        for (var j = 0; j < arraySize - i - 1; j++) {\r\n\r\n            let needToSwap = false;\r\n            let addToSorted = false;\r\n\r\n            if (localArray[j] > localArray[j + 1]) {\r\n                /**\r\n                 * We make changes to our localArray according to bubbleSort,\r\n                 * then  setTimeout, which was stacked up, follows those \r\n                 * chnanges of swapping\r\n                 */\r\n                let temp = localArray[j];\r\n                localArray[j] = localArray[j + 1];\r\n                localArray[j + 1] = temp;\r\n                needToSwap = true;\r\n            }\r\n\r\n            if (j === arraySize - i - 2) {\r\n                addToSorted = true;\r\n            }\r\n\r\n            /** \r\n             * Timer() uses j's value to update currentlyChecking and if \r\n             * needToSwap is true then also swaps array using j's value\r\n             * THIS ALL HAPPENS AFTER THESE LOOPS HAVE EXECUTED\r\n             */\r\n            updateArrayAfterTimeDelay(i, j, arraySize, needToSwap, addToSorted, timeDelayIterator);\r\n\r\n            timeDelayIterator += 2;\r\n\r\n        }\r\n    }\r\n}\r\n\r\nexport default bubbleSort;","import { setValue } from \"../actions/array\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { setSortedArray } from \"../actions/sortedArray\";\r\nimport { store } from \"../store\";\r\nimport { getTimeDelay, storeDispatch } from \"./helpers\";\r\n\r\n/**\r\n * \r\n * **********************************************************\r\n *\r\n * We perform the merge sort on a copy of store's state Array\r\n * and keep a track of changes in array and the indices which \r\n * were compared while merging two subarrays\r\n * \r\n * **********************************************************\r\n * \r\n * Then we update our state array step-by-step according \r\n * to our tracked changes\r\n * \r\n * **********************************************************\r\n * \r\n */\r\n\r\n/**\r\n * -- We didn't need a queue in Bubble Sort because it wasn't recursive --\r\n * \r\n * This keeps a track of changes in the array an the indices\r\n * It stores an object for each change,\r\n * k : index which needs to be updated\r\n * value : value with which array[k] will be updated with\r\n * firstIdx : index for first subarray,\r\n * secondIdx : index for second subarray\r\n */\r\nlet Queue = [];\r\n\r\n/**\r\n * It takes an object and a timeDelayIterator as arguments and update the\r\n * store's state Array after delayed time\r\n * @param {*} QueueObject The Object which contains one specific change\r\n * @param {*} timeDelayIterator An increasing value which prevents \r\n * running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(QueueObject, timeDelayIterator) {\r\n    setTimeout(() => {\r\n\r\n        const { k, value, firstIdx, secondIdx } = QueueObject;\r\n        const indices = [firstIdx, secondIdx];\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        storeDispatch(indices, setCurrentlyChecking);\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n\r\n        /**\r\n         * Updating value at k index in array\r\n         */\r\n        storeDispatch({ index: k, value: value }, setValue);\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n}\r\n\r\n/**\r\n * MERGE_SORT (arr[] , l, r)\r\n * \r\n *   If r > l\r\n *      1. Find the middle point to divide the array into two halves:\r\n *          middle m = l + (r - l) / 2\r\n *      2. Call mergeSort for first half:\r\n *          Call mergeSort(arr, l, m)\r\n *      3. Call mergeSort for second half:\r\n *          Call mergeSort(arr, m + 1, r)\r\n *      4. Merge the two halves sorted in step 2 and 3:\r\n *          Call merge(arr, l, m, r)\r\n */\r\n\r\n/**\r\n * Merges two subarrays of localArray[].\r\n * First subarray is localArray[l..m]\r\n * Second subarray is localArray[m+1..r]\r\n * @param {*} localArray Original Array \r\n * @param {*} leftIdx Starting index for first subarray\r\n * @param {*} midxIdx Ending Index (inclusive) for first subarray\r\n * @param {*} rightIdx Ending Index (inclusive) for second subarray \r\n *                      which start from midIdx + 1\r\n */\r\nfunction merge(localArray, leftIdx, midIdx, rightIdx) {\r\n\r\n    // Sizes of two subarray\r\n    var n1 = midIdx - leftIdx + 1;\r\n    var n2 = rightIdx - midIdx;\r\n\r\n    // Creating temp arrays\r\n    var leftLocalArray = new Array(n1);\r\n    var rightLocalArray = new Array(n2);\r\n\r\n    // Copy data to temp arrays\r\n    for (let i = 0; i < n1; i++)\r\n        leftLocalArray[i] = localArray[[leftIdx + i]];\r\n    for (let j = 0; j < n2; j++)\r\n        rightLocalArray[j] = localArray[midIdx + 1 + j];\r\n\r\n    /**\r\n     *  ..................................................\r\n     *\r\n     *  MERGING THE TEMP ARRAYS BACK INTO localArray[l..r]\r\n     * (Using Merge-K-Sorted-LinkedLists Algorithm)\r\n     * \r\n     *  ..................................................\r\n     */\r\n\r\n    // Initial index of first subarray\r\n    var i = 0;\r\n\r\n    // Initial index of second subarray\r\n    var j = 0;\r\n\r\n    // Initial index of merged subarray\r\n    var k = leftIdx;\r\n\r\n    while (i < n1 && j < n2) {\r\n        if (leftLocalArray[i] <= rightLocalArray[j]) {\r\n            localArray[k] = leftLocalArray[i];\r\n            Queue.push({\r\n                k: k,\r\n                value: leftLocalArray[i],\r\n                firstIdx: leftIdx + i,\r\n                secondIdx: midIdx + 1 + j\r\n            });\r\n            i++;\r\n        }\r\n        else {\r\n            localArray[k] = rightLocalArray[j];\r\n            Queue.push({\r\n                k: k,\r\n                value: rightLocalArray[j],\r\n                firstIdx: leftIdx + i,\r\n                secondIdx: midIdx + 1 + j\r\n            });\r\n            j++;\r\n        }\r\n\r\n        k++;\r\n    }\r\n\r\n    /**\r\n     * Reason for IMPORTANT in below steps : \r\n     * Pushing the changes for even one \r\n     * subarray is important as, if not done then \r\n     * at last if some changes were made to array, \r\n     * they will not get recorded, but such changes \r\n     * 'in between' will get updated by next merge changes\r\n     */\r\n\r\n    // Copy the remaining elements of\r\n    // leftLocalArray[], if there are any\r\n    while (i < n1) {\r\n        localArray[k] = leftLocalArray[i];\r\n        // IMPORTANT\r\n        Queue.push({\r\n            k: k,\r\n            value: leftLocalArray[i],\r\n            firstIdx: leftIdx + i,\r\n            secondIdx: -1\r\n        });\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // rightLocalArrau[], if there are any\r\n    while (j < n2) {\r\n        localArray[k] = rightLocalArray[j];\r\n        // IMPORTANT \r\n        Queue.push({\r\n            k: k,\r\n            value: rightLocalArray[j],\r\n            firstIdx: -1,\r\n            secondIdx: midIdx + 1 + j\r\n        });\r\n        j++;\r\n        k++;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sorts the array from leftIdx to rightIdx using MergeSort Algorithm\r\n * @param {*} localArray Original Array whose subarray is to be sorted\r\n * @param {*} leftIdx Starting index of subarray\r\n * @param {*} rightIdx Ending Index (inclusive) of subarray \r\n */\r\nfunction mergeSortRecursive(localArray, leftIdx, rightIdx) {\r\n    if (leftIdx >= rightIdx) {\r\n        return;//returns recursively\r\n    }\r\n    var midIdx = leftIdx + parseInt((rightIdx - leftIdx) / 2);\r\n    mergeSortRecursive(localArray, leftIdx, midIdx);\r\n    mergeSortRecursive(localArray, midIdx + 1, rightIdx);\r\n    merge(localArray, leftIdx, midIdx, rightIdx);\r\n}\r\n\r\n/**\r\n * Perform Merge Sort on the store's Array\r\n */\r\nfunction mergeSort() {\r\n\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * Its a copy of store's state Array.\r\n     * Here .slice() is really important as\r\n     * it gives us a deep copy else whatever changes\r\n     * we make in the loop, they will get updated immediately\r\n     */\r\n    const localArray = state.array.slice();\r\n\r\n    // So that it clears prevoius memory.. as it is a global variable maintaining memory across files\r\n    Queue = [];\r\n\r\n    // We perform the merge sort on a copy of store's state Array\r\n    mergeSortRecursive(localArray, 0, state.array.length - 1);\r\n\r\n    // Stores all indices of the array which will be used for filling sortedArray\r\n    const allIndicesArray = [];\r\n\r\n    // Performing the Queued changes in the array\r\n    for (var i = 0; i < Queue.length; i++) {\r\n        /**\r\n        * setTimeout() function inside a loop stacks up and\r\n        * executes only after the loop and all the iterations \r\n        * start together at same time\r\n        * \r\n        * To prevent simultaneous executions of setTimeouts,\r\n        * we pass an iterator with increasing values.\r\n        */\r\n        //i is passed as timeDealyIterator\r\n        updateArrayAfterTimeDelay(Queue[i], i + 2);\r\n\r\n        /**\r\n         * On last iteration, adding another setTimeout()\r\n         * to the list of setTimeouts to fill sortedArray\r\n         */\r\n        // Adding current index to allIndicesArray\r\n        allIndicesArray.push(i);\r\n        // THIS EXECUTES AFTER ALL THE OTHER setTimeout ABOVE IN LOOP\r\n        if (i === Queue.length - 1) {\r\n            setTimeout(() => {\r\n                storeDispatch(allIndicesArray, setSortedArray);\r\n            }, getTimeDelay() * (i + 2));\r\n        }\r\n    }\r\n}\r\n\r\nexport default mergeSort;","export const setPivot = (payload) => {\r\n    return {\r\n        type: 'SET_PIVOT',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../store\";\r\nimport { storeDispatch, getTimeDelay } from \"./helpers\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { setSortedArray } from \"../actions/sortedArray\";\r\nimport { swapValues } from \"../actions/array\";\r\nimport { setPivot } from \"../actions/pivot\";\r\n\r\n/**\r\n * \r\n * **********************************************************\r\n *\r\n * We perform the quick sort on a copy of store's state Array\r\n * and keep a track of changes in array and the indices which \r\n * were compared while merging two subarrays\r\n * \r\n * **********************************************************\r\n * \r\n * Then we update our state array step-by-step according \r\n * to our tracked changes\r\n * \r\n * **********************************************************\r\n * \r\n */\r\n\r\n/**\r\n * -- We didn't need a queue in Bubble Sort because it wasn't recursive --\r\n * \r\n * This keeps a track of changes in the array an the indices\r\n * It stores an object for each change,\r\n * firstIdx : index for first subarray,\r\n * secondIdx : index for second subarray\r\n * pivot : currently selected pivot point\r\n */\r\nlet Queue = [];\r\n\r\n/**\r\n * It takes an object and a timeDelayIterator as arguments and update the\r\n * store's state Array after delayed time\r\n * @param {*} QueueObject The Object which contains one specific change\r\n * @param {*} timeDelayIterator An increasing value which prevents \r\n * running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(QueueObject, timeDelayIterator) {\r\n    setTimeout(() => {\r\n\r\n        const { firstIdx, secondIdx, pivot } = QueueObject;\r\n        const indices = [firstIdx, secondIdx];\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        storeDispatch(indices, setCurrentlyChecking);\r\n        storeDispatch(pivot, setPivot);\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n        \r\n        /**\r\n         * Updating array with changed array\r\n         */\r\n        storeDispatch(indices, swapValues);\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} localArray Copy of the array on which we want to we want to perform Quick Sort\r\n * @param {number} startIdx Starting index \r\n * @param {number} endIdx Ending index \r\n * @returns Pivot index\r\n */\r\nfunction partition(localArray, startIdx, endIdx) {\r\n\r\n    // Taking the last element as the pivot\r\n    /**\r\n     * Value at selected(last element) pivot\r\n     */\r\n    const pivotValue = localArray[endIdx];\r\n\r\n    /**\r\n     * Shows uptill where the value is smaller than pivotValue\r\n     */\r\n    let pivotIdx = startIdx;\r\n    for (let idx = startIdx; idx < endIdx; idx++) {\r\n        if (localArray[idx] < pivotValue) {\r\n            // Swapping elements\r\n            [localArray[idx], localArray[pivotIdx]] = [localArray[pivotIdx], localArray[idx]];\r\n            // Moving to next element\r\n            pivotIdx++;\r\n            Queue.push({\r\n                firstIdx: idx,\r\n                secondIdx: pivotIdx - 1,\r\n                pivot: endIdx\r\n            })\r\n        }\r\n    }\r\n\r\n    // Putting the pivot value in the middle\r\n    [localArray[pivotIdx], localArray[endIdx]] = [localArray[endIdx], localArray[pivotIdx]]\r\n    Queue.push({\r\n        firstIdx: pivotIdx,\r\n        secondIdx: endIdx,\r\n        pivot: -1\r\n    })\r\n\r\n    return pivotIdx;\r\n};\r\n\r\nfunction quickSortRecursive(localArray, startIdx, endIdx) {\r\n    // Base case or terminating case\r\n    if (startIdx >= endIdx) {\r\n        return;\r\n    }\r\n\r\n    // Returns pivotIndex\r\n    const pivotIdx = partition(localArray, startIdx, endIdx);\r\n\r\n    // Recursively apply the same logic to the left and right subarrays\r\n    quickSortRecursive(localArray, startIdx, pivotIdx - 1);\r\n    quickSortRecursive(localArray, pivotIdx + 1, endIdx);\r\n}\r\n\r\nfunction quickSort() {\r\n\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n    * Its a copy of store's state Array.\r\n    * Here .slice() is really important as\r\n    * it gives us a deep copy else whatever changes\r\n    * we make in the loop, they will get updated immediately\r\n    */\r\n    let localArray = state.array.slice();\r\n\r\n    // So that it clears prevoius memory.. as it is a global variable maintaining memory across files\r\n    Queue = [];\r\n\r\n    // We perform the quick sort on a copy of store's state Array\r\n    quickSortRecursive(localArray, 0, localArray.length - 1);\r\n\r\n    // Stores all indices of the array which will be used for filling sortedArray\r\n    const allIndicesArray = [];\r\n\r\n    // Performing the Queued changes in the array\r\n    for (var i = 0; i < Queue.length; i++) {\r\n        /**\r\n        * setTimeout() function inside a loop stacks up and\r\n        * executes only after the loop and all the iterations \r\n        * start together at same time\r\n        * \r\n        * To prevent simultaneous executions of setTimeouts,\r\n        * we pass an iterator with increasing values.\r\n        */\r\n        //i is passed as timeDealyIterator\r\n        updateArrayAfterTimeDelay(Queue[i], i + 2);\r\n\r\n        /**\r\n         * On last iteration, adding another setTimeout()\r\n         * to the list of setTimeouts to fill sortedArray\r\n         */\r\n        // Adding current index to allIndicesArray\r\n        allIndicesArray.push(i);\r\n        // THIS EXECUTES AFTER ALL THE OTHER setTimeout ABOVE IN LOOP\r\n        if (i === Queue.length - 1) {\r\n            setTimeout(() => {\r\n                storeDispatch(allIndicesArray, setSortedArray);\r\n            }, getTimeDelay() * (i + 2));\r\n        }\r\n    }\r\n}\r\n\r\nexport default quickSort;","export const setSpeed = (payload) => {\r\n    return {\r\n        type: 'SET_SPEED',\r\n        payload: payload\r\n    }\r\n};\r\n","import ControlBar from \"./ControlBar.jsx\";\r\nimport { connect } from \"react-redux\";\r\nimport { ARRAY_MIN_VALUE, ARRAY_MAX_VALUE } from \"../../defaults/index.js\";\r\nimport sort from \"../../algorithms\"\r\nimport { setArray } from \"../../actions/array\";\r\nimport { setSpeed } from \"../../actions/speed/index.js\";\r\nimport { setSortedArray } from \"../../actions/sortedArray/index.js\";\r\nimport { setAlgorithm } from \"../../actions/algorithm\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking/index.js\";\r\n\r\n/**\r\n * Return a random value in specified range\r\n * @param {*} lowerLimit Least possible random number\r\n * @param {*} upperLimit Larget possible random number\r\n * @returns A random number between lowerLimit and UpperLimit (both inclusive)\r\n */\r\nconst getRandomValue = (lowerLimit, upperLimit) => {\r\n    return Math.floor(Math.random() * (upperLimit + 1)) + lowerLimit;\r\n}\r\n\r\n/**\r\n * Returns a random array pf specified Length\r\n * @param {*} arraySize Length of the array to be formed\r\n * @returns A random values array of length = arraySize\r\n */ \r\nconst generateRandomArray = (arraySize) => {\r\n    const array = [];\r\n    const lowerLimit = ARRAY_MIN_VALUE;\r\n    const upperLimit = ARRAY_MAX_VALUE;\r\n    for (var i = 0; i < arraySize; i++) {\r\n        array.push(getRandomValue(lowerLimit, upperLimit));\r\n    }\r\n    return array;\r\n}\r\n\r\n/**\r\n * Takes the dispatch method as argument \r\n * and dispatches the methods for reseting \r\n * sortedArray and currentlyChecking array\r\n */\r\nconst empty_CurrentlyArray_and_SortedArray = (dispatch) => {\r\n    dispatch(setCurrentlyChecking([]));\r\n    dispatch(setSortedArray([]));\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    return { array, algorithm }\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n    /**\r\n     * Generats a random array of given size and sets it through dispatch\r\n     * @param {*} arraySize Length of the array to be generated\r\n     */\r\n    generateArray: (arraySize) => {\r\n        const randomGeneratedArray = generateRandomArray(arraySize);\r\n        dispatch(setArray(randomGeneratedArray));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n    },\r\n\r\n    /**\r\n     * Changes the algorithm through dispatch\r\n     * @param {*} selectedAlgo New algorithm to be set \r\n     */\r\n    changeAlgorithm: (selectedAlgo) => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(setAlgorithm(selectedAlgo));\r\n    },\r\n\r\n    /**\r\n     * Changes the sorting display speed of algorithm\r\n     * @param {*} selectedSpeed Selected Speed\r\n     */\r\n    changeSpeed: (selectedSpeed) => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(setSpeed(selectedSpeed));\r\n    },\r\n\r\n    /**\r\n     * Starts the sorting\r\n     */\r\n    sort: () => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        sort();\r\n    }\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ControlBar);","export const setAlgorithm = (payload) => {\r\n    return {\r\n        type: 'SET_ALGORITHM',\r\n        payload: payload\r\n    }\r\n};\r\n","import bubbleSort from \"./bubbleSort\";\r\nimport mergeSort from \"./mergeSort\";\r\nimport quickSort from \"./quickSort\";\r\nimport { store } from \"../store\";\r\n\r\nexport default function sort() {\r\n\r\n    const state = store.getState();\r\n\r\n    const algorithm = state.algorithm;\r\n\r\n    switch (algorithm) {\r\n        \r\n        case 'BUBBLE_SORT': {\r\n            bubbleSort();\r\n            break;\r\n        }\r\n        case 'MERGE_SORT': {\r\n            mergeSort();\r\n            break;\r\n        }\r\n        case 'QUICK_SORT': {\r\n            quickSort();\r\n            break;\r\n        }\r\n        default: {\r\n            console.error(\"No sorting algorithm selected, can't sort\");\r\n            return;\r\n        }\r\n    }\r\n\r\n}","import React from \"react\";\r\nimport ArrayBars from \"../ArrayBars/ArrayBars\";\r\nimport ControlBar from \"../ControlBar/ControlBar\";\r\n\r\nfunction SortingVisualizer() {\r\n    return (\r\n        <div>\r\n            <ControlBar />\r\n            <ArrayBars />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SortingVisualizer;","import React from \"react\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <SortingVisualizer />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport { store } from './store';\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n\n  //wrapping the app around store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}