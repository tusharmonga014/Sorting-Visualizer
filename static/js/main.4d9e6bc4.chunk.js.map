{"version":3,"sources":["defaults/index.js","components/ArrayBars/ArrayBars.jsx","components/ArrayBars/ArrayBars.js","components/ControlBar/ControlBar.jsx","reducers/algorithmRedcuer/index.js","reducers/utilities/swapValuesInArray.js","reducers/arrayReducer/index.js","reducers/index.js","reducers/speedReducer/index.js","reducers/currenltyCheckingReducer/index.js","reducers/pivotReducer/index.js","reducers/sortedArrayReducer/index.js","reducers/sortingRunStatus/index.js","store/index.js","actions/array/index.js","actions/currentlyChecking/index.js","actions/sortedArray/index.js","algorithms/helpers/getSortingRunStatus.js","algorithms/helpers/checkCurrentStatus.js","algorithms/helpers/getTimeDelay.js","algorithms/helpers/sleep.js","algorithms/helpers/continueAfterDelayIfNotStopped.js","algorithms/allAlgorithms/bubbleSort.js","actions/sortingRunStatus/index.js","algorithms/allAlgorithms/mergeSort.js","actions/pivot/index.js","algorithms/allAlgorithms/quickSort.js","algorithms/allAlgorithms/heapSort.js","algorithms/allAlgorithms/insertionSort.js","algorithms/allAlgorithms/selectionSort.js","algorithms/ALGORITHMS.js","algorithms/getAlgorithmById.js","algorithms/sort.js","components/ControlBar/ControlBar.js","actions/algorithm/index.js","actions/speed/index.js","components/SortingVisualizer/SortingVisualizer.jsx","components/App.js","index.js"],"names":["ARRAY_MAX_VALUE","window","screen","width","MAX_ARRAY_SIZE","DEFAULT_ARRAY_SIZE","DELAY_BEFORE_COMPLETESORT_EFFECT","arraySize","TIME_BETWEEN_EACH_BAR_EFFECT","MARGIN_BETWEEN_BARS","SCREEN_PERCENTAGE_TO_OCCUPY","ArrayBars","getMarginBetweenBars","getBarsDisplayAreaWidth","screenWidth","Math","floor","getBarWidth","barsDisplayAreaWidth","marginBetween","showBarHeight","event","barId","target","id","barIdForHeightDisplay","bar","document","getElementById","barHeightDisplayBox","style","opacity","removeAttribute","zIndex","hideBarHeight","setAttribute","giveSortingCompletedEffectWhenCompleted","props","array","sortingRunStatus","length","allBars","getElementsByClassName","setTimeout","barsIterator","classList","add","remove","this","currentlyChecking","pivot","sortedArray","barWidth","displayBarHeight","className","map","idx","backgroundColor","includes","hidden","height","marginLeft","onMouseOver","onMouseLeave","Component","connect","state","algorithm","dispatch","ControlBar","resetArray","generateArray","changeArraySize","value","changeAlgorithm","selectedAlgo","innerText","name","changeSpeed","selectedSpeed","Number","disableArrayAlgorithmInputs","buttonsToBeDisabled","buttonDisablingIterator","disableArrayAlgorithmTexts","textsToBeDisabled","textDisablingIterator","enableArrayAlgorithmInputs","buttonsToBeEnabled","buttonEnablingIterator","enableArrayAlgorithmTexts","textsToBeEnabled","textEnablingIterator","hideStartSortingButton","showStartSortingButton","showPauseButton","hidePauseButton","showContinueButton","hideContinueButton","showStopSortinButton","hideStopSortingButton","manageControlBarFeaturesWhenSortingStarts","manageControlBarFeaturesWhenSortingStops","startSorting","pauseSorting","continueSorting","stopSorting","handleIfSortingCompleted","algorithms","defaultAlgorithm","onClick","type","this_algorithm","min","max","defaultValue","onChange","initialState","checkIfIndexOutOfBounds","index","console","error","swapValuesInArray","firstIdx","secondIdx","temp","rootReducer","combineReducers","action","payload","speed","concat","store","createStore","__REDUX_DEVTOOLS_EXTENSION__","setArray","swapValues","setCurrentlyChecking","setSortedArray","addToSortedArray","getCurrentSortingRunStatus","getState","a","Promise","resolve","reject","setInterval","checkCurrentSortingRunStatus","getTimeDelay","sleep","then","catch","finalCheckResult","continueAfterDelayIfNotStopped","localArray","outerLoopIterator","innerLoopIterator","mergeInArrayAndDispatch","mainArrayIterator","rightIdx","valueToBeMerged","leftLocalArray","rightLocalArray","remainingArrayOnLeft","slice","remainingArrayOnRight","mergedArray","merge","leftIdx","midIdx","leftArrayIterator","rightArrayIterator","leftArrayValueToBeMerged","shift","rightArrayValueToBeMerged","mergeSortRecursive","parseInt","mergeSort","setPivot","partition","startIdx","endIdx","pivotValue","pivotIdx","quickSortRecursive","heapify","nodeIndex","largest","right","left","HeapSort","extractElementIterator","iterator","backwardIterator","minimumElementIndex","minElmntIdxIteartor","selectionSort","ALGORITHMS","function","getAlgorithmById","algorithmId","algorithmsIterator","log","sort","getRandomValue","lowerLimit","upperLimit","random","empty_CurrentlyArray_SortedArray_Pivot","randomGeneratedArray","i","push","generateRandomArray","setAlgorithm","SortingVisualizer","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.4d9e6bc4.chunk.js","sourcesContent":["/**\r\n * Array's lowest value\r\n */\r\nconst ARRAY_MIN_VALUE = 40;\r\n/**\r\n * Array's largest value\r\n * ARRAY_MAX_VALUE > 500 will overlap with Control-Bar\r\n */\r\nconst ARRAY_MAX_VALUE = window.screen.width <= 700 ? 350 : 425;\r\n\r\n/**\r\n * Sorting speed range\r\n * SORTING_SPEED_LOWER_LIMIT is 0 always\r\n */\r\nconst SORTING_SPEED_UPPER_LIMIT = 500;\r\nconst DEFAULT_SELECTED_SPEED = 500;\r\n\r\n/**\r\n * Minimum array length\r\n */\r\nconst MIN_ARRAY_SIZE = 10;\r\n/**\r\n * Maximum array length\r\n */\r\nconst MAX_ARRAY_SIZE = window.screen.width <= 600 ? 100 : 200;\r\nconst DEFAULT_ARRAY_SIZE = MAX_ARRAY_SIZE / 1.5;\r\n\r\n/**\r\n * Bar colour when its neither sorted \r\n * nor in the process of being sorted\r\n */\r\nconst BAR__COLOUR_DEFAULT = 'rgb(0, 204, 255)';\r\n// const BAR__COLOUR_DEFAULT = 'rgb(0, 255, 145)';\r\n/**\r\n * Bar colour when its in the process for sorting\r\n */\r\nconst BAR_COLOUR_WHILE_CHECKING = 'blue';\r\n/**\r\n * Bar colour when it has been sorted\r\n */\r\nconst BAR_COLOUR_SORTED = 'rgb(184, 0, 162)';\r\n/**\r\n * Bar colour when it is pivot\r\n */\r\nconst BAR_COLOUR_PIVOT = 'rgb(255, 117, 26)';\r\n\r\n/**\r\n * Default selected sorting algorithm Id\r\n * shown in dropdown algo selector\r\n */\r\nconst DEFAULT_SELECTED_ALGORITHM_ID = 0;\r\n\r\n/**\r\n * Time delay (in ms) after finish \r\n * of sorting completion effect\r\n */\r\nconst DELAY_AFTER_COMPLETESORT_EFFECT = 1000;\r\n/**\r\n * Time delay (in ms) before start \r\n * of sorting completion effect\r\n */\r\nconst DELAY_BEFORE_COMPLETESORT_EFFECT = (arraySize) => {\r\n    return arraySize <= 50 ? 700\r\n        : arraySize <= 100 ? 500\r\n            : arraySize <= 150 ? 400\r\n                : 300;\r\n}\r\n/**\r\n * Returns time (in ms) between each bar effect\r\n * @param {number} arraySize Length of the array\r\n * @returns Time (in ms) between each bar effect\r\n */\r\nconst TIME_BETWEEN_EACH_BAR_EFFECT = (arraySize) => {\r\n    return arraySize <= 10 ? 8\r\n        : arraySize <= 50 ? 6\r\n            : arraySize <= 100 ? 4\r\n            : arraySize <= 150 ? 3\r\n                : 2;\r\n}\r\n\r\n/**\r\n * tells margin between bars\r\n * @param {*} arraySize the length of array \r\n * @returns space between each bar depending upon the arraySize\r\n */\r\nconst MARGIN_BETWEEN_BARS = (arraySize) => {\r\n    return arraySize <= 10 ? 4\r\n        : arraySize <= 50 ? 2\r\n            : 1;\r\n};\r\n\r\n/**\r\n * tells the amount of screen to occupy\r\n * @param {*} arraySize the length of the array\r\n * @returns the amount of screen to occupy in \r\n *          terms of decimal from 0-1 where \r\n *          0 shows empty space and\r\n *          1 shows full screen \r\n */\r\nconst SCREEN_PERCENTAGE_TO_OCCUPY = (arraySize) => {\r\n    return window.screen.width <= 600 ? 0.80\r\n        : arraySize <= 16 ? 0.50\r\n            : 0.66;\r\n}\r\n\r\n/**\r\n * .............................\r\n * EXPORTS\r\n * ............................. \r\n */\r\nexport {\r\n    ARRAY_MIN_VALUE,\r\n    ARRAY_MAX_VALUE,\r\n    SORTING_SPEED_UPPER_LIMIT,\r\n    DEFAULT_SELECTED_SPEED,\r\n    MIN_ARRAY_SIZE,\r\n    MAX_ARRAY_SIZE,\r\n    DEFAULT_ARRAY_SIZE,\r\n    BAR__COLOUR_DEFAULT,\r\n    BAR_COLOUR_WHILE_CHECKING,\r\n    BAR_COLOUR_SORTED,\r\n    BAR_COLOUR_PIVOT,\r\n    DEFAULT_SELECTED_ALGORITHM_ID,\r\n    DELAY_AFTER_COMPLETESORT_EFFECT,\r\n    DELAY_BEFORE_COMPLETESORT_EFFECT,\r\n    TIME_BETWEEN_EACH_BAR_EFFECT,\r\n    MARGIN_BETWEEN_BARS,\r\n    SCREEN_PERCENTAGE_TO_OCCUPY\r\n}","import React, { Component } from \"react\"\r\nimport { BAR_COLOUR_PIVOT, BAR_COLOUR_SORTED, BAR_COLOUR_WHILE_CHECKING, BAR__COLOUR_DEFAULT, DELAY_AFTER_COMPLETESORT_EFFECT, DELAY_BEFORE_COMPLETESORT_EFFECT, MARGIN_BETWEEN_BARS, SCREEN_PERCENTAGE_TO_OCCUPY, TIME_BETWEEN_EACH_BAR_EFFECT } from \"../../defaults\";\r\nimport \"./ArrayBars.css\";\r\n\r\nclass ArrayBars extends Component {\r\n\r\n    getMarginBetweenBars = (arraySize) => {\r\n        const marginBetween = MARGIN_BETWEEN_BARS(arraySize);\r\n        return marginBetween;\r\n    }\r\n\r\n    getBarsDisplayAreaWidth = (arraySize) => {\r\n        const screenWidth = window.screen.width;\r\n        const barsDisplayAreaWidth = Math.floor(screenWidth * SCREEN_PERCENTAGE_TO_OCCUPY(arraySize));\r\n        return barsDisplayAreaWidth;\r\n    }\r\n\r\n    getBarWidth = (arraySize, barsDisplayAreaWidth, marginBetween) => {\r\n        const barWidth = (barsDisplayAreaWidth - (marginBetween * arraySize)) / arraySize;\r\n        return barWidth;\r\n    }\r\n\r\n    showBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes 0.5 when mouse enters the bar,\r\n         * Height Display Box becomes visible,\r\n         * Z-index of box is set to 1 to bring it forward than bar\r\n         */\r\n        bar.style.opacity = 0.5;\r\n        barHeightDisplayBox.removeAttribute('hidden');\r\n        barHeightDisplayBox.style.zIndex = 1;\r\n    }\r\n\r\n    hideBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes normal when mouse leaves the bar,\r\n         * Height Display Box again becomes hidden,\r\n         * Z-index of box is again set to -1 to prevent its area\r\n         * from stopping mouse over effect for its bar\r\n         */\r\n        bar.style.opacity = 1;\r\n        barHeightDisplayBox.setAttribute('hidden', true);\r\n        barHeightDisplayBox.style.zIndex = -1;\r\n    }\r\n\r\n    giveSortingCompletedEffectWhenCompleted = () => {\r\n        const { array, sortingRunStatus } = this.props;\r\n\r\n        /**\r\n         * Length of store's state array\r\n         */\r\n        const arraySize = array.length;\r\n\r\n        // If sorting is commpleted show effect\r\n        if (sortingRunStatus === 'COMPLETED') {\r\n            const allBars = document.getElementsByClassName('bar');\r\n\r\n            // After DELAY_BEFORE_COMPLETESORT_EFFECT ms of sorting completion show effect\r\n            setTimeout(() => {\r\n\r\n                // Iterating on each bar at gap of TIME_BETWEEN_EACH_BAR_EFFECT ms\r\n                for (let barsIterator = 0; barsIterator < allBars.length; barsIterator++) {\r\n                    setTimeout(() => {\r\n                        // Add effect class which has background color as !important\r\n                        allBars[barsIterator].classList.add('complete-sort-effect');\r\n                    }, TIME_BETWEEN_EACH_BAR_EFFECT(arraySize) * barsIterator);\r\n                }\r\n            }, DELAY_BEFORE_COMPLETESORT_EFFECT(arraySize));\r\n\r\n            /**\r\n             * Remove efect after : (as all setTimeouts start together in a loop)\r\n             * DELAY_BEFORE_COMPLETESORT_EFFECT (waiting time for showing effect)\r\n             * (TIME_BETWEEN_EACH_BAR_EFFECT * arraySize) ms (time taken for each effect)\r\n             * DELAY_AFTER_COMPLETESORT_EFFECT stop and display time for effect\r\n             */\r\n            setTimeout(() => {\r\n                // Iterating on each bar\r\n                for (let barsIterator = 0; barsIterator < allBars.length; barsIterator++) {\r\n                    allBars[barsIterator].classList.remove('complete-sort-effect');\r\n                }\r\n            }, DELAY_BEFORE_COMPLETESORT_EFFECT(arraySize) + (TIME_BETWEEN_EACH_BAR_EFFECT(arraySize) * arraySize) + DELAY_AFTER_COMPLETESORT_EFFECT);\r\n        }\r\n    }\r\n\r\n    render() {\r\n\r\n        const { array, currentlyChecking, pivot, sortedArray, sortingRunStatus } = this.props;\r\n\r\n        const arraySize = array.length;\r\n        const barsDisplayAreaWidth = this.getBarsDisplayAreaWidth(arraySize);\r\n        const marginBetween = this.getMarginBetweenBars(arraySize);\r\n        const barWidth = this.getBarWidth(arraySize, barsDisplayAreaWidth, marginBetween);\r\n        const displayBarHeight = window.screen.width >= 500 && arraySize < 23 ? true : false;\r\n\r\n        this.giveSortingCompletedEffectWhenCompleted();\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"bars\" style={{ width: barsDisplayAreaWidth }}>\r\n                    {\r\n                        array.length > 0 && array.map((bar, idx) => {\r\n                            let backgroundColor = idx === pivot ? BAR_COLOUR_PIVOT : BAR__COLOUR_DEFAULT;\r\n                            backgroundColor = sortedArray.includes(idx) || sortingRunStatus === 'COMPLETED' ? BAR_COLOUR_SORTED : backgroundColor;\r\n                            backgroundColor = currentlyChecking.includes(idx) && sortingRunStatus !== 'COMPLETED' ? BAR_COLOUR_WHILE_CHECKING : backgroundColor;\r\n                            const barIdForHeightDisplay = 'bar' + idx;\r\n\r\n                            return (\r\n                                <div key={idx}>\r\n\r\n                                    {/* bar height display box */}\r\n                                    <div\r\n                                        id={barIdForHeightDisplay}\r\n                                        className=\"bar-height-display\"\r\n                                        hidden>\r\n                                        {bar}\r\n                                    </div>\r\n\r\n                                    {/* bar */}\r\n                                    <div\r\n                                        id={idx}\r\n                                        className=\"bar\"\r\n                                        style={{ width: barWidth, height: bar, backgroundColor: backgroundColor, marginLeft: marginBetween }}\r\n                                        onMouseOver={this.showBarHeight}\r\n                                        onMouseLeave={this.hideBarHeight}>\r\n                                        {displayBarHeight ? bar : ''}\r\n                                    </div>\r\n\r\n                                </div>\r\n                            );\r\n                        })\r\n                    }\r\n                </div >\r\n\r\n                <div className='base-block bg-dark text-center'></div>\r\n\r\n            </div >\r\n        )\r\n    }\r\n}\r\n\r\nexport default ArrayBars;","import ArrayBars from \"./ArrayBars.jsx\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const currentlyChecking = state.currentlyChecking;\r\n    const pivot = state.pivot;\r\n    const sortedArray = state.sortedArray;\r\n    const sortingRunStatus = state.sortingRunStatus;\r\n    return { array, algorithm, currentlyChecking, pivot, sortedArray, sortingRunStatus };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n})\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ArrayBars);","import React, { Component } from \"react\";\r\nimport { DEFAULT_ARRAY_SIZE, DEFAULT_SELECTED_SPEED, MAX_ARRAY_SIZE, MIN_ARRAY_SIZE, SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\nimport \"./ControlBar.css\";\r\n\r\nclass ControlBar extends Component {\r\n\r\n  /**\r\n   * Generates a new Array of given length\r\n   * @param {number} arraySize length for new Array\r\n   */\r\n  resetArray = (arraySize) => {\r\n    this.props.generateArray(arraySize);\r\n  }\r\n\r\n  /**\r\n   * Changes and generates a new array of selected length\r\n   * @param {event} event Event which trigerred the function\r\n   */\r\n  changeArraySize = (event) => {\r\n    this.resetArray(event.target.value);\r\n  }\r\n\r\n  /**\r\n   * Changes the algorithm \r\n   * @param {Object} selectedAlgo Selected algorithm object\r\n   */\r\n  changeAlgorithm = (selectedAlgo) => {\r\n    document.getElementById('dropdown-algo-selector').innerText = selectedAlgo.name;\r\n    this.props.changeAlgorithm(selectedAlgo);\r\n  }\r\n\r\n  /**\r\n  * Changes the algorithm \r\n  * @param {event} event Event which trigerred the function\r\n  */\r\n  changeSpeed = (event) => {\r\n    const selectedSpeed = (Number)(event.target.value);\r\n    this.props.changeSpeed(selectedSpeed);\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar inputs for \r\n   * Array and Algorithm slelection\r\n   */\r\n  disableArrayAlgorithmInputs = () => {\r\n    const buttonsToBeDisabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonDisablingIterator = 0; buttonDisablingIterator < buttonsToBeDisabled.length; buttonDisablingIterator++) {\r\n      buttonsToBeDisabled[buttonDisablingIterator].setAttribute('disabled', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's input-label-texts on the control bar\r\n   */\r\n  disableArrayAlgorithmTexts = () => {\r\n    const textsToBeDisabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textDisablingIterator = 0; textDisablingIterator < textsToBeDisabled.length; textDisablingIterator++) {\r\n      textsToBeDisabled[textDisablingIterator].classList.remove('text-white');\r\n      textsToBeDisabled[textDisablingIterator].classList.add('text-muted');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables the control bar inputs for \r\n   * Array and Algorithm slelection\r\n   */\r\n  enableArrayAlgorithmInputs = () => {\r\n    const buttonsToBeEnabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonEnablingIterator = 0; buttonEnablingIterator < buttonsToBeEnabled.length; buttonEnablingIterator++) {\r\n      buttonsToBeEnabled[buttonEnablingIterator].removeAttribute('disabled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables the control bar's input-label-texts on the control bar\r\n   */\r\n  enableArrayAlgorithmTexts = () => {\r\n    const textsToBeEnabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textEnablingIterator = 0; textEnablingIterator < textsToBeEnabled.length; textEnablingIterator++) {\r\n      textsToBeEnabled[textEnablingIterator].classList.remove('text-muted');\r\n      textsToBeEnabled[textEnablingIterator].classList.add('text-white');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hides start sort button on the control bar\r\n   */\r\n  hideStartSortingButton = () => {\r\n    const startSortingButton = document.getElementById('btn-sort');\r\n    startSortingButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows start sort button on the control bar\r\n   */\r\n  showStartSortingButton = () => {\r\n    const startSortingButton = document.getElementById('btn-sort');\r\n    startSortingButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Shows pause button on the control bar\r\n   */\r\n  showPauseButton = () => {\r\n    const pauseButton = document.getElementById('btn-pause');\r\n    pauseButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides pause button on the control bar\r\n   */\r\n  hidePauseButton = () => {\r\n    const pauseButton = document.getElementById('btn-pause');\r\n    pauseButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows continue button on the control bar\r\n   */\r\n  showContinueButton = () => {\r\n    const continueButton = document.getElementById('btn-continue');\r\n    continueButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides continue button on the control bar\r\n   */\r\n  hideContinueButton = () => {\r\n    const continueButton = document.getElementById('btn-continue');\r\n    continueButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows the stop sort button on the control bar\r\n   */\r\n  showStopSortinButton = () => {\r\n    const stopSortingButton = document.getElementById('btn-stop-sort');\r\n    stopSortingButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides stop sort button on the control bar\r\n   */\r\n  hideStopSortingButton = () => {\r\n    const stopSortingButton = document.getElementById('btn-stop-sort');\r\n    stopSortingButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Disables Array and Algorithm related features\r\n   * and enables Sorting realted features\r\n   */\r\n  manageControlBarFeaturesWhenSortingStarts = () => {\r\n    this.disableArrayAlgorithmInputs();\r\n    this.disableArrayAlgorithmTexts();\r\n    this.hideStartSortingButton();\r\n    this.showPauseButton();\r\n    this.showStopSortinButton();\r\n  }\r\n\r\n  /**\r\n   * Enables Array and Algorithm related features\r\n   * and enables Sorting realted features\r\n   */\r\n  manageControlBarFeaturesWhenSortingStops = () => {\r\n    this.enableArrayAlgorithmInputs();\r\n    this.enableArrayAlgorithmTexts();\r\n    this.hidePauseButton();\r\n    this.hideContinueButton();\r\n    this.hideStopSortingButton();\r\n    this.showStartSortingButton();\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's feature \r\n   * and starts sorting\r\n   */\r\n  startSorting = () => {\r\n    this.manageControlBarFeaturesWhenSortingStarts();\r\n    this.props.startSorting();\r\n  }\r\n\r\n  /**\r\n   * Pauses the sorting\r\n   */\r\n  pauseSorting = () => {\r\n    this.props.pauseSorting();\r\n    this.hidePauseButton();\r\n    this.showContinueButton();\r\n  }\r\n\r\n  /**\r\n   * Continues the paused sorting process\r\n   */\r\n  continueSorting = () => {\r\n    this.hideContinueButton();\r\n    this.showPauseButton();\r\n    this.props.continueSorting();\r\n  }\r\n\r\n  /**\r\n   * Stops the current storting process\r\n   */\r\n  stopSorting = () => {\r\n    this.manageControlBarFeaturesWhenSortingStops();\r\n    this.props.stopSorting();\r\n  }\r\n\r\n  /**\r\n   * Checks if sorting is completed\r\n   * and calls the required control\r\n   * bar manager functions\r\n   */\r\n  handleIfSortingCompleted = () => {\r\n    this.props.sortingRunStatus === 'COMPLETED' && this.manageControlBarFeaturesWhenSortingStops();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetArray(DEFAULT_ARRAY_SIZE);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { array, algorithms, defaultAlgorithm } = this.props;\r\n    const arraySize = array.length;\r\n\r\n    this.handleIfSortingCompleted();\r\n\r\n    return (\r\n      <div className='nav navbar navbar-dark bg-dark text-center pt-2 pb-2'>\r\n        <div className='navbar navbar-brand col-sm-12 col-md-6 col-lg-4 text-center m-0 p-0'>\r\n          <h2>SORTING VISUALIZER</h2>\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-6 col-lg-3 m-0 p-0\">\r\n          <button className='btn btn-white btn-round mt-1 mb-1 mr-2 input-disable-when-running  array-algo-button'\r\n            onClick={() => { this.resetArray(arraySize) }}>\r\n            Generate New Array\r\n          </button>\r\n\r\n          <div className=\"btn-group array-algo-button\">\r\n            <button\r\n              type=\"button\"\r\n              id=\"dropdown-algo-selector\"\r\n              className=\"btn btn-success dropdown-toggle input-disable-when-running col-12\"\r\n              data-toggle=\"dropdown\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded=\"false\">\r\n              {defaultAlgorithm.name}\r\n            </button>\r\n            <div className=\"dropdown-menu\">\r\n              <h1 className=\"dropdown-header text-large\">Select Algorithm</h1>\r\n              {\r\n                algorithms.map((this_algorithm) => {\r\n                  return (\r\n                    <div key={this_algorithm.id}>\r\n                      <div className=\"dropdown-divider\"></div>\r\n                      <button className=\"dropdown-item\"\r\n                        onClick={() => this.changeAlgorithm(this_algorithm)}>\r\n                        {this_algorithm.name}\r\n                      </button>\r\n                    </div>\r\n                  );\r\n                })\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className='col-md-12 col-lg-3 row slider-controls text-justify-end'>\r\n          <div className='text-white text-center text-disable-when-running text-slider slider-controls col-sm-4 col-md-6 col-lg-6 mt-1 mb-1'>\r\n            Array Size :\r\n          </div>\r\n          <input\r\n            className='input-disable-when-running text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6 mt-1 mb-1'\r\n            type=\"range\"\r\n            min={MIN_ARRAY_SIZE}\r\n            max={MAX_ARRAY_SIZE}\r\n            defaultValue={DEFAULT_ARRAY_SIZE}\r\n            onChange={this.changeArraySize}\r\n          />\r\n          <div className='text-white text-center text-slider slider-controls col-sm-4 col-md-6 col-lg-6 mb-1'>\r\n            Sorting Speed :\r\n          </div>\r\n          <input\r\n            className='text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6 mb-1'\r\n            type=\"range\"\r\n            min=\"1\"\r\n            max={SORTING_SPEED_UPPER_LIMIT}\r\n            defaultValue={DEFAULT_SELECTED_SPEED}\r\n            onChange={this.changeSpeed}\r\n          />\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-12 col-lg-2 text-center mt-1 mb-1\">\r\n          <button\r\n            id=\"btn-sort\"\r\n            className=\"btn btn-success\"\r\n            onClick={this.startSorting}>\r\n            START SORTING\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-pause\"\r\n            className=\"btn btn-default btn-when-running mr-1\"\r\n            onClick={this.pauseSorting}\r\n            hidden>\r\n            Pause\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-continue\"\r\n            className=\"btn btn-default btn-when-running mr-1\"\r\n            onClick={this.continueSorting}\r\n            hidden>Continue\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-stop-sort\"\r\n            className=\"btn btn-danger btn-when-running\"\r\n            onClick={this.stopSorting}\r\n            hidden>\r\n            Stop\r\n          </button>\r\n\r\n        </div>\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default ControlBar;","import { DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults\";\r\n\r\nlet initialState = {\r\n    id: DEFAULT_SELECTED_ALGORITHM_ID\r\n}\r\n\r\nexport const algorithm = (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case 'SET_ALGORITHM':\r\n            return action.payload;\r\n        default: return state;\r\n    }\r\n}","function checkIfIndexOutOfBounds(index, arraySize) {\r\n    if (index < 0 || index >= arraySize) {\r\n        console.error(index + \" passed for swapping is out of bounds for \" + arraySize + \", can't swap values.\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Swaps the values in given array\r\n * @param {Array} array Array whose values need to be swapped \r\n * @param {number} firstIdx first index\r\n * @param {number} secondIdx second index\r\n */\r\nexport function swapValuesInArray(array, firstIdx, secondIdx) {\r\n\r\n    const arraySize = array.length;\r\n\r\n    // first and second index both should be in range 0 to (arraySize - 1)\r\n    if (checkIfIndexOutOfBounds(firstIdx, arraySize) || checkIfIndexOutOfBounds(secondIdx, arraySize)) {\r\n        return array;\r\n    }\r\n\r\n    let temp = array[firstIdx];\r\n    array[firstIdx] = array[secondIdx];\r\n    array[secondIdx] = temp;\r\n\r\n    return array;\r\n}","import { swapValuesInArray } from \"../utilities\";\r\n\r\nexport const array = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_ARRAY':\r\n            return action.payload;\r\n        case 'SWAP_VALUES':\r\n            return swapValuesInArray(state, action.payload.firstIdx, action.payload.secondIdx);\r\n        default: return state;\r\n    }\r\n}","import { combineReducers } from \"redux\";\r\nimport { algorithm } from \"./algorithmRedcuer\";\r\nimport { array } from \"./arrayReducer\";\r\nimport { currentlyChecking } from \"./currenltyCheckingReducer\";\r\nimport { speed } from \"./speedReducer\";\r\nimport { pivot } from \"./pivotReducer\";\r\nimport { sortedArray } from \"./sortedArrayReducer\";\r\nimport { sortingRunStatus } from \"./sortingRunStatus\";\r\n\r\nconst rootReducer = combineReducers({\r\n    array,\r\n    algorithm,\r\n    speed,\r\n    currentlyChecking,\r\n    pivot,\r\n    sortedArray,\r\n    sortingRunStatus,\r\n});\r\n\r\nexport default rootReducer;","import { DEFAULT_SELECTED_SPEED } from \"../../defaults\";\r\n\r\nexport const speed = (state = DEFAULT_SELECTED_SPEED, action) => {\r\n    switch (action.type) {\r\n        case 'SET_SPEED':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","/**\r\n * It denotes the array of indices currently \r\n * being checked by the algorithm for sorting\r\n */\r\nexport const currentlyChecking = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_CURRENTLYCHECKING':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const pivot = (state = -1, action) => {\r\n    switch (action.type) {\r\n        case 'SET_PIVOT':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortedArray = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_SORTEDARRAY':\r\n            return action.payload;\r\n        case 'ADD_TO_SORTEDARRAY':\r\n            return state.concat(action.payload);\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortingRunStatus = (state = 'NOT_RUNNING', action) => {\r\n    switch (action.type) {\r\n        case 'STARTED':\r\n            return 'STARTED';\r\n        case 'CONTINUED':\r\n            return 'CONTINUED';\r\n        case 'PAUSED':\r\n            return 'PAUSED';\r\n        case 'STOPPED':\r\n            return 'STOPPED';\r\n        case 'COMPLETED':\r\n            return 'COMPLETED';\r\n        case 'REFRESH':\r\n            return 'NOT_RUNNING';\r\n\r\n        default: return state;\r\n    }\r\n}","import rootReducer from \"../reducers\";\r\nimport { createStore } from \"redux\";\r\n\r\nexport const store = createStore(\r\n    rootReducer,\r\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);","export const setArray = (payload) => {\r\n    return {\r\n        type: 'SET_ARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * Swaps the value at firstIdx with secondIdx \r\n * in store's state Array\r\n * @param {number} firstIdx first index\r\n * @param {number} secondIdx second index\r\n */\r\nexport const swapValues = (firstIdx, secondIdx) => {\r\n    return {\r\n        type: 'SWAP_VALUES',\r\n        payload: {\r\n            firstIdx: firstIdx,\r\n            secondIdx: secondIdx\r\n        }\r\n    }\r\n\r\n}\r\n","export const setCurrentlyChecking = (payload) => {\r\n    return {\r\n        type: 'SET_CURRENTLYCHECKING',\r\n        payload: payload\r\n    }\r\n};\r\n","/**\r\n * Sets the sort array as provided array\r\n * @param {Array} payload takes an array to best set as sortedArray\r\n */\r\nexport const setSortedArray = (payload) => {\r\n    return {\r\n        type: 'SET_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * Adds the given element to sortedArray\r\n * @param {*} payload element to be added in sortedArray\r\n */\r\nexport const addToSortedArray = (payload) => {\r\n    return {\r\n        type: 'ADD_TO_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\"\r\n\r\n/**\r\n * Returns the sortingRunStatus in store's state\r\n * @returns sortingRunStatus\r\n */\r\nfunction getCurrentSortingRunStatus() {\r\n    // Gets the current state object in store\r\n    const state = store.getState();\r\n\r\n    // Gets the sortingRunStatus from state object\r\n    const status = state.sortingRunStatus;\r\n    return status;\r\n}\r\n\r\nexport default getCurrentSortingRunStatus;","import getCurrentSortingRunStatus from \"./getSortingRunStatus\";\r\n\r\nasync function checkCurrentSortingRunStatus() {\r\n    if (getCurrentSortingRunStatus() === 'PAUSED') {\r\n        return new Promise((resolve, reject) => {\r\n            setInterval(() => {\r\n                if (getCurrentSortingRunStatus() === 'CONTINUED')\r\n                    resolve();\r\n                else if (getCurrentSortingRunStatus() === 'STOPPED')\r\n                    reject();\r\n            }, 10);\r\n\r\n        });\r\n    } else if (getCurrentSortingRunStatus() === 'STOPPED') {\r\n        return new Promise((resolve, reject) => reject());\r\n    } else {\r\n        return new Promise(resolve => resolve());\r\n    }\r\n}\r\n\r\nexport default checkCurrentSortingRunStatus;","import { store } from \"../../store\";\r\nimport { SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\n\r\n/**\r\n * @returns the timedelay between each step,\r\n *          so if speed is 10 and speed range is 0-100\r\n *          timedelay will be of 90ms\r\n */\r\nfunction getTimeDelay() {\r\n    const state = store.getState();\r\n    const speed = state.speed;\r\n    return SORTING_SPEED_UPPER_LIMIT - speed;\r\n}\r\n\r\nexport default getTimeDelay;","import getTimeDelay from \"./getTimeDelay\";\r\n\r\nasync function sleep() {\r\n    await new Promise((resolve) => {\r\n        setTimeout(() => resolve(), getTimeDelay());\r\n    });\r\n}\r\n\r\nexport default sleep;","import checkCurrentSortingRunStatus from \"./checkCurrentStatus\";\r\nimport sleep from \"./sleep\";\r\n\r\n/**\r\n * Checks if not paused or stopped and moves when after delay time\r\n * @returns True for continuing, False for stopping\r\n */\r\nasync function continueAfterDelayIfNotStopped() {\r\n\r\n    // Checking if Paused or Stopped\r\n    let checkFurther = await checkCurrentSortingRunStatus()\r\n        .then(() => true)\r\n        .catch(() => false);\r\n    if (!checkFurther)\r\n        return false;\r\n\r\n    // Delaying accroding to selected speed\r\n    await sleep();\r\n\r\n    // Checking if Paused or Stopped\r\n    let finalCheckResult = await checkCurrentSortingRunStatus()\r\n        .then(() => true)\r\n        .catch(() => false);\r\n\r\n    return finalCheckResult;\r\n}\r\n\r\nexport default continueAfterDelayIfNotStopped;","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \".././helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * BUBBLE SORT : \r\n * \r\n * Bubble Sort is the simplest sorting algorithm that works by repeatedly \r\n * swapping the adjacent elements if they are in wrong order.\r\n * \r\n * It works on the principle of keeping the heaviest element(or bubble)\r\n * at last position in each iteration and working on remaining in next.\r\n */\r\n\r\n/**\r\n * Performs Bubble Sort on the store's Array\r\n */\r\nasync function bubbleSort() {\r\n\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // Bubble Sort Algorithm \r\n\r\n    // Outer loop\r\n    for (let outerLoopIterator = 0; outerLoopIterator < arraySize - 1; outerLoopIterator++) {\r\n        let innerLoopIterator = 0;\r\n\r\n        //Inner loop\r\n        for (innerLoopIterator = 0; innerLoopIterator < arraySize - outerLoopIterator - 1; innerLoopIterator++) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            // Setting the current indices which are being checked to currentlyChecking\r\n            store.dispatch(setCurrentlyChecking([innerLoopIterator, innerLoopIterator + 1]));\r\n\r\n            if (localArray[innerLoopIterator] > localArray[innerLoopIterator + 1]) {\r\n\r\n                // Check if stopped or paused - delay accoring to selected speed - again check\r\n                continueSort = await continueAfterDelayIfNotStopped();\r\n                // Return if stopped\r\n                if (!continueSort)\r\n                    return;\r\n\r\n                // Swaps the values in store's state Array\r\n                store.dispatch(swapValues(innerLoopIterator, innerLoopIterator + 1));\r\n            }\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n        }\r\n\r\n        // Adding the 'j' which has been sorted to sortedArray\r\n        store.dispatch(addToSortedArray(innerLoopIterator));\r\n    }\r\n\r\n    // Removing the first bar as currentlyChecking\r\n    store.dispatch(setCurrentlyChecking([]));\r\n\r\n    // First bar needs to be marked explicitly as \r\n    // it doesn't go inside inner loop\r\n    store.dispatch(addToSortedArray(0));\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default bubbleSort;","export const sortingStarted = () => {\r\n    return {\r\n        type: 'STARTED'\r\n    }\r\n};\r\n\r\nexport const sortingContinued = () => {\r\n    return {\r\n        type: 'CONTINUED'\r\n    }\r\n};\r\n\r\nexport const sortingPaused = () => {\r\n    return {\r\n        type: 'PAUSED'\r\n    }\r\n};\r\n\r\nexport const sortingStopped = () => {\r\n    return {\r\n        type: 'STOPPED'\r\n    }\r\n};\r\n\r\nexport const sortingCompleted = () => {\r\n    return {\r\n        type: 'COMPLETED'\r\n    }\r\n}\r\n\r\nexport const sortingRefresh = () => {\r\n    return {\r\n        type: 'REFRESH'\r\n    }\r\n}","import { store } from \"../../store\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { setSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport { setArray } from \"../../actions/array\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * MERGE_SORT (arr[] , l, r)\r\n * \r\n *   If r > l\r\n *      1. Find the middle point to divide the array into two halves:\r\n *          middle m = l + (r - l) / 2\r\n *      2. Call mergeSort for first half:\r\n *          Call mergeSort(arr, l, m)\r\n *      3. Call mergeSort for second half:\r\n *          Call mergeSort(arr, m + 1, r)\r\n *      4. Merge the two halves sorted in step 2 and 3:\r\n *          Call merge(arr, l, m, r)\r\n */\r\n\r\n/**\r\n * Dispatches new array with merged values of given data \r\n * in order of : remaining array on left, merging value, \r\n * left array, right array, remaining array on left.\r\n * @param {number} mainArrayIterator The mainIterator or K\r\n * @param {number} rightIdx End limit of current array(inclusive)\r\n * @param {*} valueToBeMerged The value which needs to be inserted\r\n * @param {Array} leftLocalArray Current remaining left array of current array\r\n * @param {Array} rightLocalArray Current remaining right array of current array\r\n */\r\nfunction mergeInArrayAndDispatch(mainArrayIterator, rightIdx, valueToBeMerged, leftLocalArray, rightLocalArray) {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * Array on the left side of current \r\n     * array-(which remains to be merge)\r\n     */\r\n    const remainingArrayOnLeft = localArray.slice(0, mainArrayIterator);\r\n\r\n    /**\r\n     * Array on the right side of current \r\n     * array-(which remains to be merge)\r\n     */\r\n    const remainingArrayOnRight = localArray.slice(rightIdx + 1);\r\n\r\n    /**\r\n     * New merged array which will be returned\r\n     */\r\n    let mergedArray = [];\r\n\r\n    // Merging the values in new array\r\n    mergedArray = mergedArray.concat(remainingArrayOnLeft).concat(valueToBeMerged).concat(leftLocalArray).concat(rightLocalArray).concat(remainingArrayOnRight);\r\n\r\n    // Setting it as the new state array in store\r\n    store.dispatch(setArray(mergedArray));\r\n}\r\n\r\n/**\r\n * Merges two subarrays of localArray[].\r\n * First subarray is localArray[l..m]\r\n * Second subarray is localArray[m+1..r]\r\n * @param {number} leftIdx Starting index for first subarray\r\n * @param {number} midxIdx Ending Index (inclusive) for first subarray\r\n * @param {number} rightIdx Ending Index (inclusive) for second subarray which start from midIdx + 1\r\n */\r\nasync function merge(leftIdx, midIdx, rightIdx) {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    /**\r\n     * Left subarray array of current array\r\n     */\r\n    var leftLocalArray = localArray.slice(leftIdx, midIdx + 1);\r\n    /**\r\n     * Right subarray array of current array\r\n     */\r\n    var rightLocalArray = localArray.slice(midIdx + 1, rightIdx + 1);\r\n\r\n    /**\r\n     *  ..................................................\r\n     *\r\n     *  MERGING THE TEMP ARRAYS BACK INTO localArray[l..r]\r\n     *  (Using Merge-K-Sorted-LinkedLists Algorithm)\r\n     * \r\n     *  ..................................................\r\n     */\r\n\r\n    /**\r\n     * Iterator for left subarray\r\n     */\r\n    let leftArrayIterator = leftIdx;\r\n    /**\r\n     * Iterator for right subarray\r\n     */\r\n    let rightArrayIterator = midIdx + 1;\r\n\r\n    /**\r\n     * Iterator or K, for state's array\r\n     */\r\n    let mainArrayIterator = leftIdx;\r\n\r\n\r\n    while (leftLocalArray.length > 0 && rightLocalArray.length > 0) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * leftArrayIterator : mainArrayIterator + 1\r\n         * rightArrayIterator :  mainArrayIterator + leftLocalArray.length + 1\r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([leftArrayIterator, rightArrayIterator]));\r\n\r\n        if (leftLocalArray[0] <= rightLocalArray[0]) {\r\n            // Taking first value of left array of current array\r\n            const leftArrayValueToBeMerged = leftLocalArray[0];\r\n\r\n            // Removing first value of left array of current array\r\n            leftLocalArray.shift();\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            mergeInArrayAndDispatch(mainArrayIterator, rightIdx, leftArrayValueToBeMerged, leftLocalArray, rightLocalArray);\r\n\r\n        } else {\r\n            // Taking first value of right array of current array\r\n            const rightArrayValueToBeMerged = rightLocalArray[0];\r\n\r\n            // Removing first value of left array of current array\r\n            rightLocalArray.shift();\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            mergeInArrayAndDispatch(mainArrayIterator, rightIdx, rightArrayValueToBeMerged, leftLocalArray, rightLocalArray);\r\n        }\r\n\r\n        \r\n        leftArrayIterator = mainArrayIterator + 1;\r\n        rightArrayIterator = mainArrayIterator + leftLocalArray.length + 1;\r\n        store.dispatch(setCurrentlyChecking([leftArrayIterator, rightArrayIterator]));\r\n        mainArrayIterator++;\r\n    }\r\n\r\n    while (leftLocalArray.length > 0) {\r\n\r\n        // Marking leftArrayIterator\r\n        store.dispatch(setCurrentlyChecking([leftArrayIterator]));\r\n\r\n        // Taking first value of left array of current array\r\n        const leftArrayValueToBeMerged = leftLocalArray[0];\r\n\r\n        // Removing first value of left array of current array\r\n        leftLocalArray.shift();\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        mergeInArrayAndDispatch(mainArrayIterator, rightIdx, leftArrayValueToBeMerged, leftLocalArray, rightLocalArray);\r\n\r\n        leftArrayIterator = mainArrayIterator + 1;\r\n        mainArrayIterator++;\r\n    }\r\n\r\n    while (rightLocalArray.length > 0) {\r\n\r\n        // Marking leftArrayIterator\r\n        store.dispatch(setCurrentlyChecking([rightArrayIterator]));\r\n\r\n        // Taking first value of right array of current array\r\n        const rightArrayValueToBeMerged = rightLocalArray[0];\r\n\r\n        // Removing first value of left array of current array\r\n        rightLocalArray.shift();\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        mergeInArrayAndDispatch(mainArrayIterator, rightIdx, rightArrayValueToBeMerged, leftLocalArray, rightLocalArray);\r\n\r\n        rightArrayIterator = mainArrayIterator + leftLocalArray.length + 1;\r\n        mainArrayIterator++;\r\n    }\r\n\r\n    // Emptying the currentlyChecking array\r\n    store.dispatch(setCurrentlyChecking([]));\r\n}\r\n\r\n/**\r\n * Sorts the array from leftIdx to rightIdx using MergeSort Algorithm\r\n * @param {*} localArray Original Array whose subarray is to be sorted\r\n * @param {*} leftIdx Starting index of subarray\r\n * @param {*} rightIdx Ending Index (inclusive) of subarray \r\n */\r\nasync function mergeSortRecursive(leftIdx, rightIdx) {\r\n    if (leftIdx >= rightIdx) {\r\n        return;//returns recursively\r\n    }\r\n\r\n    /**\r\n     * Middle index\r\n     */\r\n    const midIdx = leftIdx + parseInt((rightIdx - leftIdx) / 2);\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = await checkCurrentSortingRunStatus()\r\n        .then(async () => {\r\n            await mergeSortRecursive(leftIdx, midIdx)\r\n            await mergeSortRecursive(midIdx + 1, rightIdx);\r\n            await merge(leftIdx, midIdx, rightIdx);\r\n            return true;\r\n        })\r\n        .catch(() => false);\r\n\r\n    // Aborting and returing if Stopped\r\n    if (!continueSort)\r\n        return;\r\n}\r\n\r\n/**\r\n * Perform Merge Sort on the store's Array\r\n */\r\nasync function mergeSort() {\r\n\r\n    /** \r\n      * Gets current state object\r\n      */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = localArray.length;\r\n\r\n    // Performing merge sort on the array\r\n    await mergeSortRecursive(0, arraySize - 1);\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default mergeSort;","export const setPivot = (payload) => {\r\n    return {\r\n        type: 'SET_PIVOT',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray, setSortedArray } from \"../../actions/sortedArray\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setPivot } from \"../../actions/pivot\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\n\r\n/**\r\n * QUICK SORT : \r\n * \r\n * QuickSort is a Divide and Conquer algorithm. It picks an element as pivot \r\n * and partitions the given array around the picked pivot.\r\n * \r\n * The key process in quickSort is partition(). Target of partitions is, given \r\n * an array and an element x of array as pivot, put x at its correct position \r\n * in sorted array and put all smaller elements (smaller than x) before x, and \r\n * put all greater elements (greater than x) after x. All this should be done \r\n * in linear time. \r\n * \r\n */\r\n\r\n/**\r\n * \r\n * @param {Array} localArray Copy of the array on which we want to we want to perform Quick Sort\r\n * @param {number} startIdx Starting index \r\n * @param {number} endIdx Ending index \r\n * @returns Pivot index\r\n */\r\nasync function partition(localArray, startIdx, endIdx) {\r\n\r\n    // Taking the last element as the pivot\r\n    /**\r\n     * Value at selected(last element) pivot\r\n     */\r\n    const pivotValue = localArray[endIdx];\r\n    store.dispatch(setPivot(endIdx));\r\n\r\n    /**\r\n     * Shows uptill where the value is smaller than pivotValue\r\n     */\r\n    let pivotIdx = startIdx;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    for (let idx = startIdx; idx < endIdx; idx++) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        store.dispatch(setCurrentlyChecking([idx, pivotIdx]));\r\n\r\n        if (localArray[idx] <= pivotValue) {\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            // Swapping the value\r\n            store.dispatch(swapValues(idx, pivotIdx));\r\n\r\n            // Moving to next element\r\n            pivotIdx++;\r\n        }\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n\r\n    // Check if stopped or paused - delay accoring to selected speed - again check\r\n    continueSort = await continueAfterDelayIfNotStopped();\r\n    // Return if stopped\r\n    if (!continueSort)\r\n        return;\r\n\r\n    // Putting the pivot value in the middle\r\n    store.dispatch(swapValues(endIdx, pivotIdx));\r\n\r\n    return pivotIdx;\r\n};\r\n\r\nasync function quickSortRecursive(localArray, startIdx, endIdx) {\r\n    // Base case or terminating case\r\n    if (startIdx >= endIdx) {\r\n        return;\r\n    }\r\n\r\n    // Returns pivotIndex\r\n    const pivotIdx = await partition(localArray, startIdx, endIdx);\r\n\r\n    store.dispatch(addToSortedArray(pivotIdx));\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = await checkCurrentSortingRunStatus()\r\n        .then(async () => {\r\n            // Recursively apply the same logic to the left and right subarrays\r\n            store.dispatch(addToSortedArray(pivotIdx));\r\n            await quickSortRecursive(localArray, startIdx, pivotIdx - 1);\r\n            // Marking first index for this part as sorted\r\n            store.dispatch(addToSortedArray(startIdx));\r\n            await quickSortRecursive(localArray, pivotIdx + 1, endIdx);\r\n            // Marking first index for this part as sorted\r\n            store.dispatch(addToSortedArray(pivotIdx + 1));\r\n        })\r\n        .catch(() => false);\r\n    // Aborting and returing if Stopped\r\n    if (!continueSort)\r\n        return;\r\n}\r\n\r\n/**\r\n * Performs quick sort on the store's state array\r\n */\r\nasync function quickSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    // Performing quick sort on the array\r\n    await quickSortRecursive(localArray, 0, arraySize - 1);\r\n\r\n    // Remove the pivot regardless of whether sort was completed or stoped\r\n    store.dispatch(setPivot(null));\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default quickSort;","import { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray, setSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport { store } from \"../../store\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n\r\n/**\r\n * Since a Binary Heap is a Complete Binary Tree, it can be easily represented\r\n * as an array and the array-based representation is space-efficient.\r\n * If the parent node is stored at index I, the left child can be\r\n * calculated by 2 * I + 1 and the right child by 2 * I + 2\r\n * (assuming the indexing starts at 0).\r\n */\r\n\r\n/**\r\n * HEAP SORT Algorithm for sorting in increasing order:\r\n *  1. Build a max heap from the input data.\r\n *  2. At this point, the largest item is stored at the root of the heap.\r\n *     Replace it with the last item of the heap followed by reducing the\r\n *     size of heap by one. Finally, heapify the root of the tree.\r\n *  3. Repeat step 2 while the size of the heap is greater than 1.\r\n */\r\n\r\n/**\r\n * Heapifies a subtree rooted with node i which is\r\n * an index in localArray. arraySize is size of heap\r\n * @param {Array} localArray An array which represents heap\r\n * @param {Number} nodeIndex An index which represents root node of the subtree\r\n * @param {Number} arraySize Size of the heap array\r\n */\r\nasync function heapify(localArray, nodeIndex, arraySize) {\r\n    let largest = nodeIndex; // Initialize largest as root\r\n    const left = 2 * nodeIndex + 1; // left = 2*i + 1\r\n    const right = 2 * nodeIndex + 2; // right = 2*i + 2\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // If left child is larger than root\r\n    if (left < arraySize && localArray[left] > localArray[largest])\r\n        largest = left;\r\n\r\n    // If right child is larger than largest so far\r\n    if (right < arraySize && localArray[right] > localArray[largest])\r\n        largest = right;\r\n\r\n\r\n    // Check if stopped or paused - delay accoring to selected speed - again check\r\n    continueSort = await continueAfterDelayIfNotStopped();\r\n    // Return if stopped\r\n    if (!continueSort)\r\n        return;\r\n\r\n    /**\r\n     * left and right are being currently checked and also\r\n     * need to check to make sure currently checking doesn't \r\n     * show more than current heap size\r\n     */\r\n    store.dispatch(setCurrentlyChecking([largest, nodeIndex]));\r\n\r\n    // If largest is not root\r\n    if (largest !== nodeIndex) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Swaps the values in store's state Array\r\n        store.dispatch(swapValues(largest, nodeIndex));\r\n\r\n        // Recursively heapify the affected sub-tree\r\n        await heapify(localArray, largest, arraySize);\r\n    }\r\n}\r\n/**\r\n * Helpeer function for implementing heap sort on localArray\r\n * @param {Array} localArray An array which represents heap\r\n */\r\nasync function HeapSort(localArray) {\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = localArray.length;\r\n\r\n    // Build heap (rearrange localArray)\r\n    for (let nodeIndex = Math.floor(arraySize / 2) - 1; nodeIndex >= 0; nodeIndex--) {\r\n        /**\r\n         * Aborts the sort if value is false\r\n         */\r\n        let continueSort = await checkCurrentSortingRunStatus()\r\n            .then(async () => {\r\n                await heapify(localArray, nodeIndex, arraySize);\r\n                return true;\r\n            })\r\n            .catch(() => false);\r\n        // Aborting and returing if Stopped\r\n        if (!continueSort)\r\n            return;\r\n    }\r\n\r\n    // One by one extract an element from heap\r\n    for (let extractElementIterator = arraySize - 1; extractElementIterator > 0; extractElementIterator--) {\r\n\r\n        /**\r\n         * Aborts the sort if value is false\r\n         */\r\n        let continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Move current root to end\r\n        store.dispatch(swapValues(0, extractElementIterator));\r\n\r\n\r\n        // Emptying the currently checking array to prevent having a single bar as marked each time\r\n        store.dispatch(setCurrentlyChecking([]));\r\n\r\n        // Add the last moved bar to sorted Array\r\n        store.dispatch(addToSortedArray(extractElementIterator));\r\n\r\n        // Call max heapify on the reduced heap\r\n        continueSort = await checkCurrentSortingRunStatus()\r\n            .then(async () => {\r\n                await heapify(localArray, 0, extractElementIterator);\r\n                return true;\r\n            })\r\n            .catch(() => false);\r\n        // Aborting and returing if Stopped\r\n        if (!continueSort)\r\n            return;\r\n    }\r\n}\r\n\r\n/**\r\n * Performs Heap Sort on the store's Array\r\n */\r\nasync function heapSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    // We perform the Heap Sort on store's state array\r\n    await HeapSort(localArray);\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default heapSort;","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * INSERTION SORT : \r\n * \r\n * Insertion sort is a simple sorting algorithm that works similar to the way \r\n * you sort playing cards in your hands. The array is virtually split into a \r\n * sorted and an unsorted part. Values from the unsorted part are picked and \r\n * placed at the correct position in the sorted part.\r\n * \r\n */\r\n\r\n/**\r\n * Performs insertion sort on the store's state array\r\n */\r\nasync function insertionSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // Insetion Sort Algorithm\r\n\r\n    for (let iterator = 0; iterator < arraySize; iterator++) {\r\n        /**\r\n         * Backward moving iterator for current element\r\n         */\r\n        let backwardIterator = iterator;\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Current element is marked\r\n        store.dispatch(setCurrentlyChecking([backwardIterator]));\r\n\r\n        /**\r\n         * Adding the current element's index to sortedArray as\r\n         * all array including this position is sorted\r\n         */\r\n        store.dispatch(addToSortedArray(iterator));\r\n\r\n        /**\r\n         * Keep swpping the current element with previous \r\n         * elements untill it reaches the correct position\r\n         * i.e. previous element is smaller or equal to it\r\n         */\r\n        while (backwardIterator > 0 && localArray[backwardIterator - 1] > localArray[backwardIterator]) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            /**\r\n             * Swapping the currentElement with \r\n             * previous element as it is bigger\r\n             */\r\n            store.dispatch(swapValues(backwardIterator - 1, backwardIterator));\r\n\r\n            // Current element is marked as it has now moved to one previous postition\r\n            store.dispatch(setCurrentlyChecking([backwardIterator - 1]));\r\n\r\n            backwardIterator--;\r\n        }\r\n    }\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default insertionSort;\r\n","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { setPivot } from \"../../actions/pivot\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * SELECTION SORT : \r\n * \r\n * The selection sort algorithm sorts an array by repeatedly finding the minimum\r\n * element (considering ascending order) from unsorted part and putting it at\r\n * the beginning. The algorithm maintains two subarrays in a given array.\r\n *\r\n * In every iteration of selection sort, the minimum element (considering ascending\r\n * order) from the unsorted subarray is picked and moved to the sorted subarray.\r\n */\r\n\r\n/**\r\n * Perform insertion sort on store's state array\r\n */\r\nasync function selectionSort() {\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    /* Selection Sort Algorithm */\r\n\r\n    /**\r\n     * One by one move boundary of unsorted subarray\r\n     * only till arraysize - 1 as last element will be\r\n     * in its correct position after all iterations\r\n     */\r\n    for (let iterator = 0; iterator < arraySize - 1; iterator++) {\r\n\r\n        // Find the minimum element in unsorted array\r\n        let minimumElementIndex = iterator;\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Current element is marked\r\n        store.dispatch(setPivot(minimumElementIndex));\r\n\r\n        //finding current minimum element's index\r\n        for (let minElmntIdxIteartor = iterator + 1; minElmntIdxIteartor < arraySize; minElmntIdxIteartor++) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            if (localArray[minElmntIdxIteartor] < localArray[minimumElementIndex]) {\r\n                // Set minimum element if current is smaller\r\n                minimumElementIndex = minElmntIdxIteartor;\r\n\r\n                // Marking current element as new min element\r\n                store.dispatch(setPivot(minElmntIdxIteartor));\r\n            }\r\n            else {\r\n                // Marking current checked element\r\n                store.dispatch(setCurrentlyChecking([minElmntIdxIteartor]));\r\n            }\r\n        }\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Swap the found minimum element with the first element\r\n        store.dispatch(swapValues(minimumElementIndex, iterator));\r\n\r\n        // Showing the currently sorted minimum element\r\n        store.dispatch(setPivot(iterator));\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n            // Emptying the currentlyChecking array\r\n        store.dispatch(setCurrentlyChecking([]));\r\n\r\n        // Adding current iterator index to sorted array as it now at correct position\r\n        store.dispatch(addToSortedArray(iterator));\r\n    }\r\n\r\n    // Adding last element index to sorted array as it now sorted\r\n    store.dispatch(addToSortedArray(arraySize - 1));\r\n\r\n    // Emptying the currentlyChecking array\r\n    store.dispatch(setCurrentlyChecking([]));\r\n\r\n    // Removing the last set pivot\r\n    store.dispatch(setPivot(null));\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default selectionSort;","import bubbleSort from \"./allAlgorithms/bubbleSort\";\r\nimport mergeSort from \"./allAlgorithms/mergeSort\";\r\nimport quickSort from \"./allAlgorithms/quickSort\";\r\nimport heapSort from \"./allAlgorithms/heapSort\";\r\nimport insertionSort from \"./allAlgorithms/insertionSort\";\r\nimport selectionSort from \"./allAlgorithms/selectionSort\";\r\n\r\n/**\r\n * An array of objects where each \r\n * object is a sorting algorithm\r\n */\r\nconst ALGORITHMS = [\r\n    {\r\n        id: 0,\r\n        name: 'Merge Sort',\r\n        value: 'MERGE_SORT',\r\n        function: mergeSort\r\n    },\r\n    {\r\n        id: 1,\r\n        name: 'Bubble Sort',\r\n        value: 'BUBBLE_SORT',\r\n        function: bubbleSort\r\n    },\r\n    {\r\n        id: 2,\r\n        name: 'Heap Sort',\r\n        value: 'HEAP_SORT',\r\n        function: heapSort\r\n    },\r\n    {\r\n        id: 3,\r\n        name: 'Insertion Sort',\r\n        value: 'INSERTION_SORT',\r\n        function: insertionSort\r\n    },\r\n    {\r\n        id: 4,\r\n        name: 'Quick Sort',\r\n        value: 'QUICK_SORT',\r\n        function: quickSort\r\n    },\r\n    {\r\n        id: 5,\r\n        name: 'Selection Sort',\r\n        value: 'SELECTION_SORT',\r\n        function: selectionSort\r\n    }\r\n]\r\n\r\nexport default ALGORITHMS;","import ALGORITHMS from \"./ALGORITHMS\";\r\n\r\n/**\r\n * Return algorithm object of specified Id\r\n * @param {*} algorithmId Algorithm Id\r\n * @returns Algorithm object\r\n */\r\nfunction getAlgorithmById(algorithmId) {\r\n\r\n    // If valid algorithm is selected, return its object\r\n    for (let algorithmsIterator = 0; algorithmsIterator < ALGORITHMS.length; algorithmsIterator++) {\r\n        if (ALGORITHMS[algorithmsIterator].id === algorithmId) {\r\n            return ALGORITHMS[algorithmsIterator];\r\n        }\r\n    }\r\n\r\n    // If algorithm Id doesn't match with any present Ids\r\n    console.log('No matching algorithm found with Id : \"' + algorithmId + '\"');\r\n    return {};\r\n}\r\n\r\nexport default getAlgorithmById;","import { store } from \"../store\";\r\nimport { sortingStarted } from \"../actions/sortingRunStatus\";\r\nimport ALGORITHMS from \"./ALGORITHMS\";\r\nimport getAlgorithmById from \"./getAlgorithmById\";\r\n\r\n/**\r\n * Starts the sorting process\r\n */\r\nfunction sort() {\r\n    /**\r\n     * Store's state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * Algorithm object in store's state\r\n     */\r\n    let algorithm = state.algorithm;\r\n\r\n    /**\r\n     * As when default is selected, it only has id in its object,\r\n     * so we can get the whole object by this id\r\n     */\r\n    algorithm = getAlgorithmById(algorithm.id);\r\n\r\n    if (ALGORITHMS.includes(algorithm)) {\r\n        // If valid algorithm is selected, call its function\r\n        store.dispatch(sortingStarted());\r\n        algorithm.function();\r\n    } else {\r\n        // If not valid algorithm, show error\r\n        console.error(\"No sorting algorithm selected, can't sort\");\r\n        return;\r\n    }\r\n}\r\n\r\nexport default sort;","import ControlBar from \"./ControlBar.jsx\";\r\nimport { connect } from \"react-redux\";\r\nimport { ARRAY_MIN_VALUE, ARRAY_MAX_VALUE, DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults/index.js\";\r\nimport { ALGORITHMS, getAlgorithmById, sort } from \"../../algorithms\"\r\nimport { setArray } from \"../../actions/array\";\r\nimport { setSpeed } from \"../../actions/speed/index.js\";\r\nimport { setSortedArray } from \"../../actions/sortedArray/index.js\";\r\nimport { setAlgorithm } from \"../../actions/algorithm\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking/index.js\";\r\nimport { sortingContinued, sortingPaused, sortingRefresh, sortingStopped } from \"../../actions/sortingRunStatus/index.js\";\r\nimport { setPivot } from \"../../actions/pivot/index.js\";\r\n\r\n/**\r\n * Return a random value in specified range\r\n * @param {*} lowerLimit Least possible random number\r\n * @param {*} upperLimit Maximum possible random number\r\n * @returns A random number between lowerLimit and UpperLimit (both inclusive)\r\n */\r\nconst getRandomValue = (lowerLimit, upperLimit) => {\r\n    return Math.floor(Math.random() * (upperLimit + 1)) + lowerLimit;\r\n}\r\n\r\n/**\r\n * Returns a random array pf specified Length\r\n * @param {*} arraySize Length of the array to be formed\r\n * @returns A random values array of length = arraySize\r\n */\r\nconst generateRandomArray = (arraySize) => {\r\n    const array = [];\r\n    const lowerLimit = ARRAY_MIN_VALUE;\r\n    const upperLimit = ARRAY_MAX_VALUE;\r\n    for (var i = 0; i < arraySize; i++) {\r\n        array.push(getRandomValue(lowerLimit, upperLimit));\r\n    }\r\n    return array;\r\n}\r\n\r\n/**\r\n * Takes the dispatch method as argument \r\n * and dispatches the methods for reseting \r\n * sortedArray and currentlyChecking array\r\n */\r\nconst empty_CurrentlyArray_SortedArray_Pivot = (dispatch) => {\r\n    dispatch(setCurrentlyChecking([]));\r\n    dispatch(setSortedArray([]));\r\n    dispatch(setPivot(null));\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const sortingRunStatus = state.sortingRunStatus;\r\n    const algorithms = ALGORITHMS;\r\n    const defaultAlgorithm = getAlgorithmById(DEFAULT_SELECTED_ALGORITHM_ID);\r\n    return { array, algorithm, sortingRunStatus, algorithms, defaultAlgorithm };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n    /**\r\n     * Generats a random array of given size and sets it through dispatch\r\n     * @param {*} arraySize Length of the array to be generated\r\n     */\r\n    generateArray: (arraySize) => {\r\n        const randomGeneratedArray = generateRandomArray(arraySize);\r\n        dispatch(setArray(randomGeneratedArray));\r\n        empty_CurrentlyArray_SortedArray_Pivot(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Changes the algorithm through dispatch\r\n     * @param {*} selectedAlgo New algorithm to be set \r\n     */\r\n    changeAlgorithm: (selectedAlgo) => {\r\n        dispatch(setAlgorithm(selectedAlgo));\r\n        empty_CurrentlyArray_SortedArray_Pivot(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Changes the sorting display speed of algorithm\r\n     * @param {*} selectedSpeed Selected Speed\r\n     */\r\n    changeSpeed: (selectedSpeed) => {\r\n        dispatch(setSpeed(selectedSpeed));\r\n    },\r\n\r\n    /**\r\n     * Starts the sorting\r\n     */\r\n    startSorting: () => {\r\n        dispatch(sortingRefresh());\r\n        empty_CurrentlyArray_SortedArray_Pivot(dispatch);\r\n        sort();\r\n    },\r\n\r\n    /**\r\n     * Pauses the current sorting process\r\n     * by dispatching the sortingPaused\r\n     */\r\n    pauseSorting: () => {\r\n        dispatch(sortingPaused());\r\n    },\r\n\r\n    /**\r\n     * Continues the paused sorting process\r\n     * by dispatching sortingContinued\r\n     */\r\n    continueSorting: () => {\r\n        dispatch(sortingContinued());\r\n    },\r\n\r\n    /**\r\n     * Stops the current sorting process\r\n     * by dispatching sortingStopped\r\n     */\r\n    stopSorting: () => {\r\n        dispatch(sortingStopped());\r\n        empty_CurrentlyArray_SortedArray_Pivot(dispatch);\r\n    }\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ControlBar);","import { getAlgorithmById } from \"../../algorithms\";\r\nimport { DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults\";\r\n\r\nexport const setAlgorithm = (payload = getAlgorithmById(DEFAULT_SELECTED_ALGORITHM_ID)) => {\r\n    return {\r\n        type: 'SET_ALGORITHM',\r\n        payload: payload\r\n    }\r\n};\r\n","export const setSpeed = (payload) => {\r\n    return {\r\n        type: 'SET_SPEED',\r\n        payload: payload\r\n    }\r\n};\r\n","import React from \"react\";\r\nimport ArrayBars from \"../ArrayBars/ArrayBars\";\r\nimport ControlBar from \"../ControlBar/ControlBar\";\r\n\r\nfunction SortingVisualizer() {\r\n    return (\r\n        <div>\r\n            <ControlBar />\r\n            <ArrayBars />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SortingVisualizer;","import React from \"react\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <SortingVisualizer />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport { store } from './store';\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n\n  // Wrapping the app around store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}