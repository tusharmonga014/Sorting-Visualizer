{"version":3,"sources":["defaults/index.js","components/ArrayBars/ArrayBars.jsx","components/ArrayBars/ArrayBars.js","components/ControlBar/ControlBar.jsx","utilities/getNewArrayWithSwappedValues.js","utilities/setValueInArrayUsingSplice.js","reducers/arrayReducer/index.js","reducers/index.js","reducers/algorithmRedcuer/index.js","reducers/speedReducer/index.js","reducers/currenltyCheckingReducer/index.js","reducers/pivotReducer/index.js","reducers/sortedArrayReducer/index.js","reducers/runningStatusReducer/index.js","store/index.js","actions/array/index.js","actions/currentlyChecking/index.js","actions/sortedArray/index.js","algorithms/helpers/getTimeDelay.js","algorithms/helpers/storeDispatch.js","algorithms/bubbleSort.js","algorithms/mergeSort.js","actions/pivot/index.js","algorithms/quickSort.js","algorithms/heapSort.js","actions/runningStatus/index.js","actions/speed/index.js","components/ControlBar/ControlBar.js","actions/algorithm/index.js","algorithms/index.js","components/SortingVisualizer/SortingVisualizer.jsx","components/App.js","index.js"],"names":["DEFAULT_SELECTED_ALGORITHM","MARGIN_BETWEEN_BARS","arraySize","SCREEN_PERCENTAGE_TO_OCCUPY","ArrayBars","getMarginBetweenBars","getBarsDisplayAreaWidth","screenWidth","window","screen","width","Math","floor","getBarWidth","barsDisplayAreaWidth","marginBetween","showBarHeight","event","barId","target","id","barIdForHeightDisplay","bar","document","getElementById","barHeightDisplayBox","style","opacity","removeAttribute","zIndex","hideBarHeight","setAttribute","enableInputs","buttonsToBeEnabled","getElementsByClassName","buttonDisablingIterator","length","enableTexts","textsToBeDisabled","textDisablingIterator","classList","remove","add","enableControlbarFeaturesWhenArrayIsSorted","props","array","sortedArray","this","currentlyChecking","pivot","barWidth","displayBarHeight","className","map","idx","backgroundColor","includes","hidden","height","marginLeft","onMouseOver","onMouseLeave","Component","connect","state","algorithm","dispatch","ControlBar","resetArray","generateArray","changeArraySize","value","getAlgorithmNameInTitleCase","console","error","changeAlgorithm","selectedAlgo","selectedAlgoTitleCase","innerText","changeSpeed","selectedSpeed","Number","disableInputs","buttonsToBeDisabled","disableTexts","disableControlBarFeatures","startSorting","runningStatus","onClick","type","min","max","defaultValue","onChange","checkIfIndexOutOfBounds","index","getNewArrayWithSwappedValues","swappingIndicesArray","firstIdx","secondIdx","firstIdxValue","secondIdxValue","arrayWithSwappedValues","swappingIterator","push","setValueInArrayUsingSplice","replaceCounter","splice","rootReducer","combineReducers","action","payload","data","speed","concat","store","createStore","__REDUX_DEVTOOLS_EXTENSION__","swapValues","setValue","setCurrentlyChecking","addToSortedArray","getTimeDelay","getState","storeDispatch","storeElementPayload","storeElementReducer","updateArrayAfterTimeDelay","i","j","needToSwap","addToSorted","timeDelayIterator","setTimeout","currentIndicesArray","bubbleSort","localArray","slice","temp","Queue","QueueObject","k","mergeSortRecursive","leftIdx","rightIdx","midIdx","parseInt","n1","n2","leftLocalArray","Array","rightLocalArray","merge","mergeSort","arrayIterator","setPivot","indices","quickSortRecursive","startIdx","endIdx","pivotIdx","pivotValue","partition","quickSort","nodeIndex","largest","heapify","left","right","swap","heapSort","extractElementIterator","HeapSort","setRunningStatus","getRandomValue","lowerLimit","upperLimit","random","empty_CurrentlyArray_and_SortedArray","randomGeneratedArray","generateRandomArray","sort","stopSorting","SortingVisualizer","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.cce30312.chunk.js","sourcesContent":["/**\r\n * Array's lowest value\r\n */\r\nconst ARRAY_MIN_VALUE = 10;\r\n/**\r\n * Array's largest value\r\n * ARRAY_MAX_VALUE > 500 will overlap with Control-Bar\r\n */\r\nconst ARRAY_MAX_VALUE = 425;\r\n\r\n/**\r\n * Sorting speed range\r\n * SORTING_SPEED_LOWER_LIMIT is 0 always\r\n */\r\nconst SORTING_SPEED_UPPER_LIMIT = 800;\r\nconst DEFAULT_SELECTED_SPEED = 600;\r\n\r\n/**\r\n * Minimum array length\r\n */\r\nconst MIN_ARRAY_SIZE = 10;\r\n/**\r\n * Maximum array length\r\n */\r\nconst MAX_ARRAY_SIZE = 200;\r\nconst DEFAULT_ARRAY_SIZE = 100;\r\n\r\n/**\r\n * Bar colour when its neither sorted \r\n * nor in the process of being sorted\r\n */\r\nconst BAR__COLOUR_DEFAULT = 'rgb(0, 204, 255)';\r\n// const BAR__COLOUR_DEFAULT = 'rgb(0, 255, 145)';\r\n/**\r\n * Bar colour when its in the process for sorting\r\n */\r\nconst BAR_COLOUR_WHILE_CHECKING = 'blue';\r\n/**\r\n * Bar colour when it has been sorted\r\n */\r\nconst BAR_COLOUR_SORTED = 'purple';\r\n/**\r\n * Bar colour when it is pivot\r\n */\r\nconst BAR_COLOUR_PIVOT = 'rgb(102, 255, 51)';\r\n\r\n\r\n/**\r\n * Default selected sorting algorithm\r\n * shown in dropdown algo selector\r\n */\r\nconst DEFAULT_SELECTED_ALGORITHM = 'MERGE_SORT';\r\n\r\n/**\r\n * tells margin between bars\r\n * @param {*} arraySize the length of array \r\n * @returns space between each bar depending upon the arraySize\r\n */\r\nconst MARGIN_BETWEEN_BARS = (arraySize) => {\r\n    return arraySize <= 10 ? 4 : arraySize <= 50 ? 2 : 1\r\n};\r\n\r\n/**\r\n * tells the amount of screen to occupy\r\n * @param {*} arraySize the length of the array\r\n * @returns the amount of screen to occupy in \r\n *          terms of decimal from 0-1 where \r\n *          0 shows empty space and\r\n *          1 shows full screen \r\n */\r\nconst SCREEN_PERCENTAGE_TO_OCCUPY = (arraySize) => {\r\n    return arraySize <= 10 ? 0.33 : arraySize <= 50 ? 0.50 : 0.66;\r\n}\r\n\r\n/**\r\n * .............................\r\n * EXPORTS\r\n * ............................. \r\n */\r\nexport {\r\n    ARRAY_MIN_VALUE,\r\n    ARRAY_MAX_VALUE,\r\n    SORTING_SPEED_UPPER_LIMIT,\r\n    DEFAULT_SELECTED_SPEED,\r\n    MIN_ARRAY_SIZE,\r\n    MAX_ARRAY_SIZE,\r\n    DEFAULT_ARRAY_SIZE,\r\n    BAR__COLOUR_DEFAULT,\r\n    BAR_COLOUR_WHILE_CHECKING,\r\n    BAR_COLOUR_SORTED,\r\n    BAR_COLOUR_PIVOT,\r\n    DEFAULT_SELECTED_ALGORITHM,\r\n    MARGIN_BETWEEN_BARS,\r\n    SCREEN_PERCENTAGE_TO_OCCUPY\r\n}","import React, { Component } from \"react\"\r\nimport { BAR_COLOUR_PIVOT, BAR_COLOUR_SORTED, BAR_COLOUR_WHILE_CHECKING, BAR__COLOUR_DEFAULT, MARGIN_BETWEEN_BARS, SCREEN_PERCENTAGE_TO_OCCUPY } from \"../../defaults\";\r\nimport \"./ArrayBars.css\";\r\n\r\nclass ArrayBars extends Component {\r\n\r\n    getMarginBetweenBars = (arraySize) => {\r\n        const marginBetween = MARGIN_BETWEEN_BARS(arraySize);\r\n        return marginBetween;\r\n    }\r\n\r\n    getBarsDisplayAreaWidth = (arraySize) => {\r\n        const screenWidth = window.screen.width;\r\n        const barsDisplayAreaWidth = Math.floor(screenWidth * SCREEN_PERCENTAGE_TO_OCCUPY(arraySize));\r\n        return barsDisplayAreaWidth;\r\n    }\r\n\r\n    getBarWidth = (arraySize, barsDisplayAreaWidth, marginBetween) => {\r\n        const barWidth = (barsDisplayAreaWidth - (marginBetween * arraySize)) / arraySize;\r\n        return barWidth;\r\n    }\r\n\r\n    showBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes 0.5 when mouse enters the bar,\r\n         * Height Display Box becomes visible,\r\n         * Z-index of box is set to 1 to bring it forward than bar\r\n         */\r\n        bar.style.opacity = 0.5;\r\n        barHeightDisplayBox.removeAttribute('hidden');\r\n        barHeightDisplayBox.style.zIndex = 1;\r\n    }\r\n\r\n    hideBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes normal when mouse leaves the bar,\r\n         * Height Display Box again becomes hidden,\r\n         * Z-index of box is again set to 0 to prevent its area\r\n         * from stopping mouse over effect for its bar\r\n         */\r\n        bar.style.opacity = 1;\r\n        barHeightDisplayBox.setAttribute('hidden', true);\r\n        barHeightDisplayBox.style.zIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Enables the control bar's input-label-texts\r\n     */\r\n    enableInputs = () => {\r\n        const buttonsToBeEnabled = document.getElementsByClassName('input-disable-when-running');\r\n        for (let buttonDisablingIterator = 0; buttonDisablingIterator < buttonsToBeEnabled.length; buttonDisablingIterator++) {\r\n            buttonsToBeEnabled[buttonDisablingIterator].removeAttribute('disabled');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the control bar's input-label-texts\r\n     */\r\n    enableTexts = () => {\r\n        const textsToBeDisabled = document.getElementsByClassName('text-disable-when-running');\r\n        for (let textDisablingIterator = 0; textDisablingIterator < textsToBeDisabled.length; textDisablingIterator++) {\r\n            textsToBeDisabled[textDisablingIterator].classList.remove('text-muted');\r\n            textsToBeDisabled[textDisablingIterator].classList.add('text-white');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the control-bar buttons which were \r\n     * disabled when sorting started\r\n     */\r\n    enableControlbarFeaturesWhenArrayIsSorted = () => {\r\n        const { array, sortedArray } = this.props;\r\n        if (array.length === sortedArray.length) {\r\n            this.enableInputs();\r\n            this.enableTexts();\r\n        }\r\n    }\r\n\r\n    render() {\r\n\r\n        const { array, currentlyChecking, pivot, sortedArray } = this.props;\r\n\r\n        const arraySize = array.length;\r\n        const barsDisplayAreaWidth = this.getBarsDisplayAreaWidth(arraySize);\r\n        const marginBetween = this.getMarginBetweenBars(arraySize);\r\n        const barWidth = this.getBarWidth(arraySize, barsDisplayAreaWidth, marginBetween);\r\n        const displayBarHeight = arraySize < 23 ? true : false;\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"bars\" style={{ width: barsDisplayAreaWidth }}>\r\n                    {\r\n                        array.length > 0 && array.map((bar, idx) => {\r\n                            let backgroundColor = currentlyChecking.includes(idx) ? BAR_COLOUR_WHILE_CHECKING : BAR__COLOUR_DEFAULT;\r\n                            backgroundColor = idx === pivot ? BAR_COLOUR_PIVOT : backgroundColor;\r\n                            backgroundColor = sortedArray.includes(idx) ? BAR_COLOUR_SORTED : backgroundColor;\r\n                            let barIdForHeightDisplay = 'bar' + idx;\r\n                            this.enableControlbarFeaturesWhenArrayIsSorted();\r\n\r\n                            return (\r\n                                <div key={idx}>\r\n\r\n                                    {/* bar height display box */}\r\n                                    <div\r\n                                        id={barIdForHeightDisplay}\r\n                                        className=\"bar-height-display\"\r\n                                        hidden>\r\n                                        {bar}\r\n                                    </div>\r\n\r\n                                    {/* bar */}\r\n                                    <div\r\n                                        id={idx}\r\n                                        className=\"bar\"\r\n                                        style={{ width: barWidth, height: bar, backgroundColor: backgroundColor, marginLeft: marginBetween }}\r\n                                        onMouseOver={this.showBarHeight}\r\n                                        onMouseLeave={this.hideBarHeight}>\r\n                                        {displayBarHeight ? bar : ''}\r\n                                    </div>\r\n\r\n                                </div>\r\n                            );\r\n                        })\r\n                    }\r\n                </div >\r\n\r\n                <div className='base-block bg-dark text-center'></div>\r\n\r\n            </div >\r\n        )\r\n    }\r\n}\r\n\r\nexport default ArrayBars;","import ArrayBars from \"./ArrayBars.jsx\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const currentlyChecking = state.currentlyChecking;\r\n    const pivot = state.pivot;\r\n    const sortedArray = state.sortedArray;\r\n    return { array, algorithm, currentlyChecking, pivot, sortedArray };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n})\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ArrayBars);","import React, { Component } from \"react\";\r\nimport { DEFAULT_ARRAY_SIZE, DEFAULT_SELECTED_ALGORITHM, DEFAULT_SELECTED_SPEED, MAX_ARRAY_SIZE, MIN_ARRAY_SIZE, SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\nimport \"./ControlBar.css\";\r\n\r\nclass ControlBar extends Component {\r\n\r\n  resetArray = (arraySize) => {\r\n    this.props.generateArray(arraySize);\r\n  }\r\n\r\n  changeArraySize = (event) => {\r\n    this.resetArray(event.target.value);\r\n  }\r\n\r\n  /**\r\n   * Returns the algorithm name in Title Case\r\n   * @param {*} algorithm The algorithm whose name is to be returned in Title Case\r\n   * @returns Algorithm name in Title Case\r\n   */\r\n  getAlgorithmNameInTitleCase = (algorithm) => {\r\n    switch (algorithm) {\r\n      case 'BUBBLE_SORT': return 'Bubble Sort';\r\n      case 'MERGE_SORT': return 'Merge Sort';\r\n      case 'QUICK_SORT': return 'Quick Sort';\r\n      case 'HEAP_SORT': return 'Heap Sort';\r\n      default: {\r\n        console.error('No algorithm provided for conversion to title case');\r\n      }\r\n    }\r\n  }\r\n\r\n  changeAlgorithm = (event) => {\r\n    const selectedAlgo = event.target.value;\r\n    this.props.changeAlgorithm(selectedAlgo);\r\n    const selectedAlgoTitleCase = this.getAlgorithmNameInTitleCase(selectedAlgo);\r\n    document.getElementById(\"dropdown-algo-selector\").innerText = selectedAlgoTitleCase;\r\n  }\r\n\r\n  changeSpeed = (event) => {\r\n    const selectedSpeed = (Number)(event.target.value);\r\n    this.props.changeSpeed(selectedSpeed);\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar inputs\r\n   */\r\n  disableInputs = () => {\r\n    const buttonsToBeDisabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonDisablingIterator = 0; buttonDisablingIterator < buttonsToBeDisabled.length; buttonDisablingIterator++) {\r\n      buttonsToBeDisabled[buttonDisablingIterator].setAttribute('disabled', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's input-label-texts\r\n   */\r\n  disableTexts = () => {\r\n    const textsToBeDisabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textDisablingIterator = 0; textDisablingIterator < textsToBeDisabled.length; textDisablingIterator++) {\r\n      textsToBeDisabled[textDisablingIterator].classList.remove('text-white');\r\n      textsToBeDisabled[textDisablingIterator].classList.add('text-muted');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar features\r\n   */\r\n  disableControlBarFeatures = () => {\r\n    this.disableInputs();\r\n    this.disableTexts();\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's feature \r\n   * and starts sorting\r\n   */\r\n  startSorting = () => {\r\n    this.disableControlBarFeatures();\r\n    this.props.startSorting();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetArray(DEFAULT_ARRAY_SIZE);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { array, runningStatus } = this.props;\r\n    const arraySize = array.length;\r\n\r\n    return (\r\n      <div className='nav navbar navbar-dark bg-dark text-center p-3'>\r\n        <div className='navbar navbar-brand col-sm-12 col-md-6 col-lg-3 text-center m-0 p-0'>\r\n          <h2>SORTING VISUALIZER</h2>\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-6 col-lg-3  text-center\">\r\n          <button className='generate-array-button btn btn-white btn-round mt-1 mb-1 mr-2 input-disable-when-running'\r\n            onClick={() => { this.resetArray(arraySize) }}>\r\n            Generate New Array\r\n          </button>\r\n\r\n          <div className=\"btn-group\">\r\n            <button\r\n              type=\"button\"\r\n              id=\"dropdown-algo-selector\"\r\n              className=\"btn btn-success dropdown-toggle input-disable-when-running\"\r\n              data-toggle=\"dropdown\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded=\"false\">\r\n              {this.getAlgorithmNameInTitleCase(DEFAULT_SELECTED_ALGORITHM)}\r\n            </button>\r\n            <div className=\"dropdown-menu\">\r\n              <h1 className=\"dropdown-header text-large\">Select Algorithm</h1>\r\n              <div className=\"dropdown-divider\"></div>\r\n              <button className=\"dropdown-item\"\r\n                value='MERGE_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Merge Sort\r\n              </button>\r\n              <div className=\"dropdown-divider\"></div>\r\n              <button\r\n                className=\"dropdown-item\"\r\n                value='QUICK_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Quick Sort\r\n              </button>\r\n              <div className=\"dropdown-divider\"></div>\r\n              <button\r\n                className=\"dropdown-item\"\r\n                value='BUBBLE_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Bubble Sort\r\n              </button>\r\n              <div className=\"dropdown-divider\"></div>\r\n              <button\r\n                className=\"dropdown-item\"\r\n                value='HEAP_SORT'\r\n                onClick={this.changeAlgorithm}>\r\n                Heap Sort\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className='col-md-12 col-lg-3 row slider-controls'>\r\n          <div className='text-white text-center text-disable-when-running slider-controls col-sm-3 col-md-6 col-lg-6'>\r\n            Array Size :\r\n          </div>\r\n          <input\r\n            className='input-disable-when-running text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6'\r\n            type=\"range\"\r\n            min={MIN_ARRAY_SIZE}\r\n            max={MAX_ARRAY_SIZE}\r\n            defaultValue={DEFAULT_ARRAY_SIZE}\r\n            onChange={this.changeArraySize}\r\n          />\r\n          <div className='text-white text-center text-disable-when-running slider-controls col-sm-3 col-md-6 col-lg-6'>\r\n            Sorting Speed :\r\n          </div>\r\n          <input\r\n            className='input-disable-when-running text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6'\r\n            type=\"range\"\r\n            min=\"1\"\r\n            max={SORTING_SPEED_UPPER_LIMIT}\r\n            defaultValue={DEFAULT_SELECTED_SPEED}\r\n            onChange={this.changeSpeed}\r\n          />\r\n        </div>\r\n\r\n        <button\r\n          className=\"btn btn-success mr-4 col-sm-12 col-md-12 col-lg-2\"\r\n          onClick={this.startSorting}>\r\n          START SORTING\r\n        </button>\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default ControlBar;","function checkIfIndexOutOfBounds(index, arraySize) {\r\n    if (index < 0 || index >= arraySize) {\r\n        console.error(index + \" passed for swapping is out of bounds for \" + arraySize + \", can't swap values.\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} array Array whose values need to be swapped \r\n * @param {*} swappingIndicesArray An Array of 2 indices whose values are to be swapped\r\n * @returns A new array with swapped values\r\n */\r\nexport function getNewArrayWithSwappedValues(array, swappingIndicesArray) {\r\n\r\n    // show error if exactly 2 indices are not passed\r\n    if (swappingIndicesArray.length !== 2) {\r\n        console.error(\"An array of 2 indices required for swapping instead recieved \" + swappingIndicesArray.length + \" values , can't swap values\");\r\n        return array;\r\n    }\r\n\r\n    const arraySize = array.length;\r\n\r\n    let firstIdx = swappingIndicesArray[0];\r\n    let secondIdx = swappingIndicesArray[1];\r\n\r\n    // first and second index both should be in range 0 to (arraySize - 1)\r\n    if (checkIfIndexOutOfBounds(firstIdx, arraySize) || checkIfIndexOutOfBounds(secondIdx, arraySize)) {\r\n        return array;\r\n    }\r\n\r\n    let firstIdxValue = null;\r\n    let secondIdxValue = null;\r\n    const arrayWithSwappedValues = [];\r\n\r\n    // loop to traverse on original array\r\n    for (var swappingIterator = 0; swappingIterator < arraySize; swappingIterator++) {\r\n        /**\r\n         * store the values of first and second indices and\r\n         * copy rest all indices values\r\n         */\r\n        if (swappingIterator === firstIdx)\r\n            firstIdxValue = array[swappingIterator];\r\n        else if (swappingIterator === secondIdx)\r\n            secondIdxValue = array[swappingIterator];\r\n\r\n        arrayWithSwappedValues.push(array[swappingIterator]);\r\n    }\r\n\r\n    arrayWithSwappedValues[firstIdx] = secondIdxValue;\r\n    arrayWithSwappedValues[secondIdx] = firstIdxValue;\r\n\r\n    return arrayWithSwappedValues;\r\n}","/**\r\n * Returns the array with value inserted at given index\r\n * @param {Array} array Array in which value needs to be inserted\r\n * @param {Number} index Index at wich value gets inserted\r\n * @param {Number} replaceCounter Number of indices to replace after given index by the given value\r\n * @param {*} value Value which is to be inserted\r\n * @returns Array with value inserted at index \r\n */\r\nexport function setValueInArrayUsingSplice(array, index, replaceCounter, value) {\r\n    array.splice(index, replaceCounter, value);\r\n    return array;\r\n}","import { getNewArrayWithSwappedValues, setValueInArrayUsingSplice } from \"../../utilities\";\r\n\r\nexport const array = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_ARRAY':\r\n            return action.payload;\r\n        case 'SWAP_VALUES':\r\n            return getNewArrayWithSwappedValues(state, action.payload)\r\n        case 'SET_VALUE':\r\n            return setValueInArrayUsingSplice(state, action.payload.id, 1, action.payload.data);\r\n        default: return state;\r\n    }\r\n}","import { combineReducers } from \"redux\";\r\nimport { algorithm } from \"./algorithmRedcuer\";\r\nimport { array } from \"./arrayReducer\";\r\nimport { currentlyChecking } from \"./currenltyCheckingReducer\";\r\nimport { speed } from \"./speedReducer\";\r\nimport { pivot } from \"./pivotReducer\";\r\nimport { sortedArray } from \"./sortedArrayReducer\";\r\nimport { runningStatus } from \"./runningStatusReducer\";\r\n\r\nconst rootReducer = combineReducers({\r\n    array,\r\n    algorithm,\r\n    speed,\r\n    currentlyChecking,\r\n    pivot,\r\n    sortedArray,\r\n    runningStatus\r\n});\r\n\r\nexport default rootReducer;","import { DEFAULT_SELECTED_ALGORITHM } from \"../../defaults\";\r\n\r\nexport const algorithm = (state = DEFAULT_SELECTED_ALGORITHM, action) => {\r\n    switch (action.type) {\r\n        case 'SET_ALGORITHM':\r\n            return  action.payload;\r\n        default: return state;\r\n    }\r\n}","import { DEFAULT_SELECTED_SPEED } from \"../../defaults\";\r\n\r\nexport const speed = (state = DEFAULT_SELECTED_SPEED, action) => {\r\n    switch (action.type) {\r\n        case 'SET_SPEED':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","/**\r\n * It denotes the array of indices currently \r\n * being checked by the algorithm for sorting\r\n */\r\nexport const currentlyChecking = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_CURRENTLYCHECKING':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const pivot = (state = -1, action) => {\r\n    switch (action.type) {\r\n        case 'SET_PIVOT':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortedArray = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_SORTEDARRAY':\r\n            return action.payload;\r\n        case 'ADD_TO_SORTEDARRAY':\r\n            return state.concat(action.payload);\r\n        default: return state;\r\n    }\r\n}","\r\nexport const runningStatus = (state = false, action) => {\r\n    switch (action.type) {\r\n        case 'SET_RUNNINGSTATUS':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","import rootReducer from \"../reducers\";\r\nimport { createStore } from \"redux\";\r\n\r\nexport const store = createStore(\r\n    rootReducer,\r\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);","export const setArray = (payload) => {\r\n    return {\r\n        type: 'SET_ARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * \r\n * @param {*} payload An array of indices i, j \r\n * where swapping needs to be done as :\r\n * Array[i] <-> Array[j]\r\n */\r\nexport const swapValues = (payload) => {\r\n    return {\r\n        type: 'SWAP_VALUES',\r\n        payload: payload\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sets value at specific index in store's State Array\r\n * @param {Object} payload\r\n * index : Index at which value needs to be stored,\r\n * value : The value which needs to be inserted\r\n * @returns An action object with type and payload\r\n */\r\nexport const setValue = (payload) => {\r\n    return {\r\n        type: 'SET_VALUE',\r\n        payload: {\r\n            id: payload.index,\r\n            data: payload.value\r\n        }\r\n    }\r\n}\r\n","export const setCurrentlyChecking = (payload) => {\r\n    return {\r\n        type: 'SET_CURRENTLYCHECKING',\r\n        payload: payload\r\n    }\r\n};\r\n","export const setSortedArray = (payload) => {\r\n    return {\r\n        type: 'SET_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\nexport const addToSortedArray = (payload) => {\r\n    return {\r\n        type: 'ADD_TO_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\";\r\nimport { SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\n\r\n/**\r\n * @returns the timedelay between each step,\r\n *          so if speed is 10 and speed range is 0-100\r\n *          timedelay will be of 90ms\r\n */\r\nexport function getTimeDelay() {\r\n    const state = store.getState();\r\n    const speed = state.speed;\r\n    return SORTING_SPEED_UPPER_LIMIT - speed;\r\n}","import { store } from \"../../store\";\r\n\r\n/**\r\n * @param {*} storeElementPayload The payload for the store element whose state needs to be updated\r\n * @param {*} storeElementReducer The reducer for that specific change to the element\r\n */\r\nexport function storeDispatch(storeElementPayload, storeElementReducer) {\r\n    store.dispatch(storeElementReducer(storeElementPayload));\r\n}","import { store } from \"../store\";\r\nimport { swapValues } from \"../actions/array\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../actions/sortedArray\";\r\nimport { getTimeDelay, storeDispatch } from \"./helpers\";\r\n\r\n/**\r\n * Executes and updates the array with dispatches after timeDelays\r\n * @param {number} i Main iterator in bubble sort\r\n * @param {number} j Checking iterator in bubble sort\r\n * @param {number} arraySize Length of the array\r\n * @param {boolean} needToSwap Represents whether value at j index was swapped with (j + 1)'s value\r\n * @param {boolean} addToSorted Shows whether its the last j value which has been sorted\r\n * @param {number} timeDelayIterator An increasing value which prevents running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(i, j, arraySize, needToSwap, addToSorted, timeDelayIterator) {\r\n\r\n    setTimeout(() => {\r\n\r\n        const currentIndicesArray = [j, j + 1];\r\n\r\n        storeDispatch(currentIndicesArray, setCurrentlyChecking);\r\n\r\n        if (needToSwap) {\r\n            storeDispatch(currentIndicesArray, swapValues);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n\r\n        if (addToSorted) {\r\n            storeDispatch(j + 1, addToSortedArray);\r\n            /**\r\n             * As the bar at 0th position also needs \r\n             * to be added to sortedArray, which doesn't \r\n             * get called from inside j loop\r\n             */\r\n            if (i === arraySize - 2) {\r\n                storeDispatch(0, addToSortedArray);\r\n            }\r\n        }\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n\r\n};\r\n\r\n/**\r\n * Performs Bubble Sort on the store's Array\r\n */\r\nfunction bubbleSort() {\r\n\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * setTimeout() function inside a loop stacks up and\r\n     * executes only after the loopand all the iterations \r\n     * start together at same time\r\n     * \r\n     * To prevent simultaneous executions of setTimeouts,\r\n     * we pass an iterator with increasing values.\r\n     */\r\n    let timeDelayIterator = 0;\r\n\r\n\r\n    /**\r\n     * Its a copy of store's state Array.\r\n     * Here .slice() is really important as\r\n     * it gives us a deep copy else whatever changes\r\n     * we make in the loop, they will get updated immediately\r\n     */\r\n    const localArray = state.array.slice();\r\n    const arraySize = state.array.length;\r\n\r\n    // bubble sort algorithm \r\n    for (var i = 0; i < arraySize - 1; i++) {\r\n        for (var j = 0; j < arraySize - i - 1; j++) {\r\n\r\n            let needToSwap = false;\r\n            let addToSorted = false;\r\n\r\n            if (localArray[j] > localArray[j + 1]) {\r\n                /**\r\n                 * We make changes to our localArray according to bubbleSort,\r\n                 * then  setTimeout, which was stacked up, follows those \r\n                 * chnanges of swapping\r\n                 */\r\n                let temp = localArray[j];\r\n                localArray[j] = localArray[j + 1];\r\n                localArray[j + 1] = temp;\r\n                needToSwap = true;\r\n            }\r\n\r\n            if (j === arraySize - i - 2) {\r\n                addToSorted = true;\r\n            }\r\n\r\n            /** \r\n             * Timer() uses j's value to update currentlyChecking and if \r\n             * needToSwap is true then also swaps array using j's value\r\n             * THIS ALL HAPPENS AFTER THESE LOOPS HAVE EXECUTED\r\n             */\r\n            updateArrayAfterTimeDelay(i, j, arraySize, needToSwap, addToSorted, timeDelayIterator);\r\n\r\n            timeDelayIterator += 2;\r\n\r\n        }\r\n    }\r\n}\r\n\r\nexport default bubbleSort;","import { setValue } from \"../actions/array\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../actions/sortedArray\";\r\nimport { store } from \"../store\";\r\nimport { getTimeDelay, storeDispatch } from \"./helpers\";\r\n\r\n/**\r\n * MERGE_SORT (arr[] , l, r)\r\n * \r\n *   If r > l\r\n *      1. Find the middle point to divide the array into two halves:\r\n *          middle m = l + (r - l) / 2\r\n *      2. Call mergeSort for first half:\r\n *          Call mergeSort(arr, l, m)\r\n *      3. Call mergeSort for second half:\r\n *          Call mergeSort(arr, m + 1, r)\r\n *      4. Merge the two halves sorted in step 2 and 3:\r\n *          Call merge(arr, l, m, r)\r\n */\r\n\r\n/**\r\n * \r\n * **********************************************************\r\n *\r\n * We perform the merge sort on a copy of store's state Array\r\n * and keep a track of changes in array and the indices which \r\n * were compared while merging two subarrays\r\n * \r\n * **********************************************************\r\n * \r\n * Then we update our state array step-by-step according \r\n * to our tracked changes\r\n * \r\n * **********************************************************\r\n * \r\n */\r\n\r\n/**\r\n * -- We didn't need a queue in Bubble Sort because it wasn't recursive --\r\n * \r\n * This keeps a track of changes in the array an the indices\r\n * It stores an object for each change,\r\n * k : index which needs to be updated\r\n * value : value with which array[k] will be updated with\r\n * firstIdx : index for first subarray,\r\n * secondIdx : index for second subarray\r\n */\r\nlet Queue = [];\r\n\r\n/**\r\n * It takes an object and a timeDelayIterator as arguments and update the\r\n * store's state Array after delayed time\r\n * @param {*} QueueObject The Object which contains one specific change\r\n * @param {*} timeDelayIterator An increasing value which prevents \r\n * running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(QueueObject, timeDelayIterator) {\r\n    setTimeout(() => {\r\n\r\n        const { k, value, firstIdx, secondIdx } = QueueObject;\r\n        const indices = [firstIdx, secondIdx];\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        storeDispatch(indices, setCurrentlyChecking);\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n\r\n        /**\r\n         * Updating value at k index in array\r\n         */\r\n        storeDispatch({ index: k, value: value }, setValue);\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n}\r\n\r\n/**\r\n * Merges two subarrays of localArray[].\r\n * First subarray is localArray[l..m]\r\n * Second subarray is localArray[m+1..r]\r\n * @param {*} localArray Original Array \r\n * @param {*} leftIdx Starting index for first subarray\r\n * @param {*} midxIdx Ending Index (inclusive) for first subarray\r\n * @param {*} rightIdx Ending Index (inclusive) for second subarray \r\n *                      which start from midIdx + 1\r\n */\r\nfunction merge(localArray, leftIdx, midIdx, rightIdx) {\r\n\r\n    // Sizes of two subarray\r\n    var n1 = midIdx - leftIdx + 1;\r\n    var n2 = rightIdx - midIdx;\r\n\r\n    // Creating temp arrays\r\n    var leftLocalArray = new Array(n1);\r\n    var rightLocalArray = new Array(n2);\r\n\r\n    // Copy data to temp arrays\r\n    for (let i = 0; i < n1; i++)\r\n        leftLocalArray[i] = localArray[[leftIdx + i]];\r\n    for (let j = 0; j < n2; j++)\r\n        rightLocalArray[j] = localArray[midIdx + 1 + j];\r\n\r\n    /**\r\n     *  ..................................................\r\n     *\r\n     *  MERGING THE TEMP ARRAYS BACK INTO localArray[l..r]\r\n     * (Using Merge-K-Sorted-LinkedLists Algorithm)\r\n     * \r\n     *  ..................................................\r\n     */\r\n\r\n    // Initial index of first subarray\r\n    var i = 0;\r\n\r\n    // Initial index of second subarray\r\n    var j = 0;\r\n\r\n    // Initial index of merged subarray\r\n    var k = leftIdx;\r\n\r\n    while (i < n1 && j < n2) {\r\n        if (leftLocalArray[i] <= rightLocalArray[j]) {\r\n            localArray[k] = leftLocalArray[i];\r\n            Queue.push({\r\n                k: k,\r\n                value: leftLocalArray[i],\r\n                firstIdx: leftIdx + i,\r\n                secondIdx: midIdx + 1 + j\r\n            });\r\n            i++;\r\n        }\r\n        else {\r\n            localArray[k] = rightLocalArray[j];\r\n            Queue.push({\r\n                k: k,\r\n                value: rightLocalArray[j],\r\n                firstIdx: leftIdx + i,\r\n                secondIdx: midIdx + 1 + j\r\n            });\r\n            j++;\r\n        }\r\n\r\n        k++;\r\n    }\r\n\r\n    /**\r\n     * Reason for IMPORTANT in below steps : \r\n     * Pushing the changes for even one \r\n     * subarray is important as, if not done then \r\n     * at last if some changes were made to array, \r\n     * they will not get recorded, but such changes \r\n     * 'in between' will get updated by next merge changes\r\n     */\r\n\r\n    // Copy the remaining elements of\r\n    // leftLocalArray[], if there are any\r\n    while (i < n1) {\r\n        localArray[k] = leftLocalArray[i];\r\n        // IMPORTANT\r\n        Queue.push({\r\n            k: k,\r\n            value: leftLocalArray[i],\r\n            firstIdx: leftIdx + i,\r\n            secondIdx: -1\r\n        });\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // rightLocalArrau[], if there are any\r\n    while (j < n2) {\r\n        localArray[k] = rightLocalArray[j];\r\n        // IMPORTANT \r\n        Queue.push({\r\n            k: k,\r\n            value: rightLocalArray[j],\r\n            firstIdx: -1,\r\n            secondIdx: midIdx + 1 + j\r\n        });\r\n        j++;\r\n        k++;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sorts the array from leftIdx to rightIdx using MergeSort Algorithm\r\n * @param {*} localArray Original Array whose subarray is to be sorted\r\n * @param {*} leftIdx Starting index of subarray\r\n * @param {*} rightIdx Ending Index (inclusive) of subarray \r\n */\r\nfunction mergeSortRecursive(localArray, leftIdx, rightIdx) {\r\n    if (leftIdx >= rightIdx) {\r\n        return;//returns recursively\r\n    }\r\n    var midIdx = leftIdx + parseInt((rightIdx - leftIdx) / 2);\r\n    mergeSortRecursive(localArray, leftIdx, midIdx);\r\n    mergeSortRecursive(localArray, midIdx + 1, rightIdx);\r\n    merge(localArray, leftIdx, midIdx, rightIdx);\r\n}\r\n\r\n/**\r\n * Perform Merge Sort on the store's Array\r\n */\r\nfunction mergeSort() {\r\n\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * Its a copy of store's state Array.\r\n     * Here .slice() is really important as\r\n     * it gives us a deep copy else whatever changes\r\n     * we make in the loop, they will get updated immediately\r\n     */\r\n    const localArray = state.array.slice();\r\n\r\n    // So that it clears prevoius memory.. as it is a global variable maintaining memory across files\r\n    Queue = [];\r\n\r\n    // We perform the merge sort on a copy of store's state Array\r\n    mergeSortRecursive(localArray, 0, state.array.length - 1);\r\n\r\n    // Performing the Queued changes in the array\r\n    for (var i = 0; i < Queue.length; i++) {\r\n        /**\r\n        * setTimeout() function inside a loop stacks up and\r\n        * executes only after the loop and all the iterations \r\n        * start together at same time\r\n        * \r\n        * To prevent simultaneous executions of setTimeouts,\r\n        * we pass an iterator with increasing values.\r\n        */\r\n        //i is passed as timeDealyIterator\r\n        updateArrayAfterTimeDelay(Queue[i], i + 2);\r\n\r\n        /**\r\n         * On last iteration, adding another setTimeout()\r\n         * to the list of setTimeouts to fill sortedArray\r\n         */\r\n        // THIS EXECUTES AFTER ALL THE OTHER setTimeout ABOVE IN LOOP\r\n        if (i === Queue.length - 1) {\r\n            setTimeout(() => {\r\n                for (let arrayIterator = 0; arrayIterator < localArray.length; arrayIterator++)\r\n                    storeDispatch(arrayIterator, addToSortedArray);\r\n            }, getTimeDelay() * (i + 2));\r\n        }\r\n    }\r\n}\r\n\r\nexport default mergeSort;","export const setPivot = (payload) => {\r\n    return {\r\n        type: 'SET_PIVOT',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../store\";\r\nimport { storeDispatch, getTimeDelay } from \"./helpers\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../actions/sortedArray\";\r\nimport { swapValues } from \"../actions/array\";\r\nimport { setPivot } from \"../actions/pivot\";\r\n\r\n/**\r\n * \r\n * **********************************************************\r\n *\r\n * We perform the quick sort on a copy of store's state Array\r\n * and keep a track of changes in array and the pivot points\r\n * \r\n * **********************************************************\r\n * \r\n * Then we update our state array step-by-step according \r\n * to our tracked changes\r\n * \r\n * **********************************************************\r\n * \r\n */\r\n\r\n/**\r\n * -- We didn't need a queue in Bubble Sort because it wasn't recursive --\r\n * \r\n * This keeps a track of changes in the array an the indices\r\n * It stores an object for each change,\r\n * firstIdx : index for first subarray,\r\n * secondIdx : index for second subarray\r\n * pivot : currently selected pivot point\r\n */\r\nlet Queue = [];\r\n\r\n/**\r\n * It takes an object and a timeDelayIterator as arguments and update the\r\n * store's state Array after delayed time\r\n * @param {*} QueueObject The Object which contains one specific change\r\n * @param {*} timeDelayIterator An increasing value which prevents \r\n * running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(QueueObject, timeDelayIterator) {\r\n    setTimeout(() => {\r\n\r\n        const { firstIdx, secondIdx, pivot } = QueueObject;\r\n        const indices = [firstIdx, secondIdx];\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        storeDispatch(indices, setCurrentlyChecking);\r\n        storeDispatch(pivot, setPivot);\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n\r\n        /**\r\n         * Updating array with changed array\r\n         */\r\n        storeDispatch(indices, swapValues);\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array} localArray Copy of the array on which we want to we want to perform Quick Sort\r\n * @param {number} startIdx Starting index \r\n * @param {number} endIdx Ending index \r\n * @returns Pivot index\r\n */\r\nfunction partition(localArray, startIdx, endIdx) {\r\n\r\n    // Taking the last element as the pivot\r\n    /**\r\n     * Value at selected(last element) pivot\r\n     */\r\n    const pivotValue = localArray[endIdx];\r\n\r\n    /**\r\n     * Shows uptill where the value is smaller than pivotValue\r\n     */\r\n    let pivotIdx = startIdx;\r\n    for (let idx = startIdx; idx < endIdx; idx++) {\r\n        if (localArray[idx] < pivotValue) {\r\n            // Swapping elements\r\n            [localArray[idx], localArray[pivotIdx]] = [localArray[pivotIdx], localArray[idx]];\r\n            // Moving to next element\r\n            pivotIdx++;\r\n            Queue.push({\r\n                firstIdx: idx,\r\n                secondIdx: pivotIdx - 1,\r\n                pivot: endIdx\r\n            })\r\n        }\r\n    }\r\n\r\n    // Putting the pivot value in the middle\r\n    [localArray[pivotIdx], localArray[endIdx]] = [localArray[endIdx], localArray[pivotIdx]]\r\n    Queue.push({\r\n        firstIdx: pivotIdx,\r\n        secondIdx: endIdx,\r\n        pivot: -1\r\n    })\r\n\r\n    return pivotIdx;\r\n};\r\n\r\nfunction quickSortRecursive(localArray, startIdx, endIdx) {\r\n    // Base case or terminating case\r\n    if (startIdx >= endIdx) {\r\n        return;\r\n    }\r\n\r\n    // Returns pivotIndex\r\n    const pivotIdx = partition(localArray, startIdx, endIdx);\r\n\r\n    // Recursively apply the same logic to the left and right subarrays\r\n    quickSortRecursive(localArray, startIdx, pivotIdx - 1);\r\n    quickSortRecursive(localArray, pivotIdx + 1, endIdx);\r\n}\r\n\r\nfunction quickSort() {\r\n\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n    * Its a copy of store's state Array.\r\n    * Here .slice() is really important as\r\n    * it gives us a deep copy else whatever changes\r\n    * we make in the loop, they will get updated immediately\r\n    */\r\n    let localArray = state.array.slice();\r\n\r\n    // So that it clears prevoius memory.. as it is a global variable maintaining memory across files\r\n    Queue = [];\r\n\r\n    // We perform the quick sort on a copy of store's state Array\r\n    quickSortRecursive(localArray, 0, localArray.length - 1);\r\n\r\n    // Performing the Queued changes in the array\r\n    for (var i = 0; i < Queue.length; i++) {\r\n        /**\r\n        * setTimeout() function inside a loop stacks up and\r\n        * executes only after the loop and all the iterations \r\n        * start together at same time\r\n        * \r\n        * To prevent simultaneous executions of setTimeouts,\r\n        * we pass an iterator with increasing values.\r\n        */\r\n        //i is passed as timeDealyIterator\r\n        updateArrayAfterTimeDelay(Queue[i], i + 2);\r\n\r\n        /**\r\n         * On last iteration, adding another setTimeout()\r\n         * to the list of setTimeouts to fill sortedArray\r\n         */\r\n        // THIS EXECUTES AFTER ALL THE OTHER setTimeout ABOVE IN LOOP\r\n        if (i === Queue.length - 1) {\r\n            setTimeout(() => {\r\n                for (let arrayIterator = 0; arrayIterator < localArray.length; arrayIterator++)\r\n                    storeDispatch(arrayIterator, addToSortedArray);\r\n            }, getTimeDelay() * (i + 2));\r\n        }\r\n    }\r\n}\r\n\r\nexport default quickSort;","import { swapValues } from \"../actions/array\";\r\nimport { setCurrentlyChecking } from \"../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../actions/sortedArray\";\r\nimport { store } from \"../store\";\r\nimport { getTimeDelay, storeDispatch } from \"./helpers\";\r\n\r\n/**\r\n * Since a Binary Heap is a Complete Binary Tree, it can be easily represented\r\n * as an array and the array-based representation is space-efficient.\r\n * If the parent node is stored at index I, the left child can be\r\n * calculated by 2 * I + 1 and the right child by 2 * I + 2\r\n * (assuming the indexing starts at 0).\r\n */\r\n\r\n/**\r\n * HEAP SORT Algorithm for sorting in increasing order:\r\n *  1. Build a max heap from the input data.\r\n *  2. At this point, the largest item is stored at the root of the heap.\r\n *     Replace it with the last item of the heap followed by reducing the\r\n *     size of heap by one. Finally, heapify the root of the tree.\r\n *  3. Repeat step 2 while the size of the heap is greater than 1.\r\n */\r\n\r\n/**\r\n * \r\n * **********************************************************\r\n *\r\n * We perform the heap sort on a copy of store's state Array\r\n * and keep a track of changes in array (Heap)\r\n * \r\n * **********************************************************\r\n * \r\n * Then we update our state array step-by-step according \r\n * to our tracked changes\r\n * \r\n * **********************************************************\r\n * \r\n */\r\n\r\n/**\r\n * -- We didn't need a queue in Bubble Sort because it wasn't recursive --\r\n * \r\n * This keeps a track of changes in the array an the indices\r\n * It stores an object for each change,\r\n * firstIdx : left index for heap node in array,\r\n * secondIdx : right index for heap node in array,\r\n * nodeIndex : heap node root\r\n * largest : largest value index\r\n */\r\nlet Queue = [];\r\n\r\n/**\r\n * It takes an object and a timeDelayIterator as arguments and update the\r\n * store's state Array after delayed time\r\n * @param {*} QueueObject The Object which contains one specific change\r\n * @param {*} timeDelayIterator An increasing value which prevents \r\n * running all setTimeouts at once\r\n */\r\nfunction updateArrayAfterTimeDelay(QueueObject, timeDelayIterator) {\r\n    setTimeout(() => {\r\n\r\n        const { firstIdx, secondIdx, nodeIndex, largest } = QueueObject;\r\n        const indices = [firstIdx, secondIdx];\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        storeDispatch(indices, setCurrentlyChecking);\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        setTimeout(() => {\r\n            storeDispatch([], setCurrentlyChecking);\r\n        }, getTimeDelay() * (timeDelayIterator - 1));\r\n\r\n        if (nodeIndex !== largest) {\r\n\r\n            /**\r\n             * Updating value at k index in array\r\n             */\r\n            storeDispatch([nodeIndex, largest], swapValues);\r\n\r\n            /**\r\n             * When both left are right are null, its the case of \r\n             * moving current root to end and it has been sorted \r\n             * so its added to sortedArray, also we need to explicitly \r\n             * add first bar to sortedArray as at that point\r\n             * nodeIndex = largest = 0, so it does'nt enter in here  \r\n             */\r\n            if (firstIdx === null && secondIdx === null) {\r\n                storeDispatch(largest, addToSortedArray);\r\n            }\r\n        }\r\n        /** we need to explicitly \r\n         * add first bar to sortedArray as at that point\r\n         * nodeIndex = largest = 0, so it does'nt enter \r\n         * in above condition\r\n         */\r\n        if (largest === 0) {\r\n            storeDispatch(0, addToSortedArray);\r\n        }\r\n\r\n    }, getTimeDelay() * timeDelayIterator);\r\n}\r\n\r\n/**\r\n * Heapifies a subtree rooted with node i which is\r\n * an index in localArray. arraySize is size of heap\r\n * @param {Array} localArray An array which represents heap\r\n * @param {Number} nodeIndex An index which represents root node of the subtree\r\n * @param {Number} arraySize Size of the heap array\r\n */\r\nfunction heapify(localArray, nodeIndex, arraySize) {\r\n    let largest = nodeIndex; // Initialize largest as root\r\n    const left = 2 * nodeIndex + 1; // left = 2*i + 1\r\n    const right = 2 * nodeIndex + 2; // right = 2*i + 2\r\n\r\n    // If left child is larger than root\r\n    if (left < arraySize && localArray[left] > localArray[largest])\r\n        largest = left;\r\n\r\n    // If right child is larger than largest so far\r\n    if (right < arraySize && localArray[right] > localArray[largest])\r\n        largest = right;\r\n\r\n    Queue.push({\r\n        // Need to check to make sure currently checing also doesn;t show more than current heap size\r\n        firstIdx: left < arraySize ? left : null,\r\n        // Need to check to make sure currently checing also doesn;t show more than current heap size\r\n        secondIdx: right < arraySize ? right : null,\r\n        nodeIndex: nodeIndex,\r\n        largest: largest\r\n    });\r\n\r\n    // If largest is not root\r\n    if (largest !== nodeIndex) {\r\n        const swap = localArray[nodeIndex];\r\n        localArray[nodeIndex] = localArray[largest];\r\n        localArray[largest] = swap;\r\n\r\n        // Recursively heapify the affected sub-tree\r\n        heapify(localArray, largest, arraySize);\r\n    }\r\n}\r\n/**\r\n * Helpeer function for implementing heap sort on localArray\r\n * @param {Array} localArray An array which represents heap\r\n */\r\nfunction HeapSort(localArray) {\r\n    var arraySize = localArray.length;\r\n\r\n    // Build heap (rearrange localArray)\r\n    for (let nodeIndex = Math.floor(arraySize / 2) - 1; nodeIndex >= 0; nodeIndex--)\r\n        heapify(localArray, nodeIndex, arraySize);\r\n\r\n    // One by one extract an element from heap\r\n    for (let extractElementIterator = arraySize - 1; extractElementIterator > 0; extractElementIterator--) {\r\n        // Move current root to end\r\n        const temp = localArray[0];\r\n        localArray[0] = localArray[extractElementIterator];\r\n        localArray[extractElementIterator] = temp;\r\n        Queue.push({\r\n            firstIdx: null,\r\n            secondIdx: null,\r\n            nodeIndex: 0,\r\n            largest: extractElementIterator\r\n        });\r\n\r\n        // call max heapify on the reduced heap\r\n        heapify(localArray, 0, extractElementIterator);\r\n    }\r\n}\r\n\r\n/**\r\n * Performs Heap Sort on the store's Array\r\n */\r\nfunction heapSort() {\r\n    // gets current state object\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * Its a copy of store's state Array.\r\n     * Here .slice() is really important as\r\n     * it gives us a deep copy else whatever changes\r\n     * we make in the loop, they will get updated immediately\r\n     */\r\n    const localArray = state.array.slice();\r\n\r\n    // So that it clears prevoius memory.. as it is a global variable maintaining memory across files\r\n    Queue = [];\r\n\r\n    // We perform the Heap Sort on a copy of store's state Array\r\n    HeapSort(localArray);\r\n\r\n    // Performing the Queued changes in the array\r\n    for (var i = 0; i < Queue.length; i++) {\r\n        /**\r\n        * setTimeout() function inside a loop stacks up and\r\n        * executes only after the loop and all the iterations \r\n        * start together at same time\r\n        * \r\n        * To prevent simultaneous executions of setTimeouts,\r\n        * we pass an iterator with increasing values.\r\n        */\r\n        //i is passed as timeDealyIterator\r\n        updateArrayAfterTimeDelay(Queue[i], i + 2);\r\n    }\r\n}\r\n\r\nexport default heapSort;","\r\nexport const setRunningStatus = (payload) => {\r\n    return {\r\n        type: 'SET_RUNNINGSTATUS',\r\n        payload: payload\r\n    }\r\n};\r\n","export const setSpeed = (payload) => {\r\n    return {\r\n        type: 'SET_SPEED',\r\n        payload: payload\r\n    }\r\n};\r\n","import ControlBar from \"./ControlBar.jsx\";\r\nimport { connect } from \"react-redux\";\r\nimport { ARRAY_MIN_VALUE, ARRAY_MAX_VALUE } from \"../../defaults/index.js\";\r\nimport sort from \"../../algorithms\"\r\nimport { setArray } from \"../../actions/array\";\r\nimport { setSpeed } from \"../../actions/speed/index.js\";\r\nimport { setSortedArray } from \"../../actions/sortedArray/index.js\";\r\nimport { setAlgorithm } from \"../../actions/algorithm\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking/index.js\";\r\n\r\n/**\r\n * Return a random value in specified range\r\n * @param {*} lowerLimit Least possible random number\r\n * @param {*} upperLimit Maximum possible random number\r\n * @returns A random number between lowerLimit and UpperLimit (both inclusive)\r\n */\r\nconst getRandomValue = (lowerLimit, upperLimit) => {\r\n    return Math.floor(Math.random() * (upperLimit + 1)) + lowerLimit;\r\n}\r\n\r\n/**\r\n * Returns a random array pf specified Length\r\n * @param {*} arraySize Length of the array to be formed\r\n * @returns A random values array of length = arraySize\r\n */\r\nconst generateRandomArray = (arraySize) => {\r\n    const array = [];\r\n    const lowerLimit = ARRAY_MIN_VALUE;\r\n    const upperLimit = ARRAY_MAX_VALUE;\r\n    for (var i = 0; i < arraySize; i++) {\r\n        array.push(getRandomValue(lowerLimit, upperLimit));\r\n    }\r\n    return array;\r\n}\r\n\r\n/**\r\n * Takes the dispatch method as argument \r\n * and dispatches the methods for reseting \r\n * sortedArray and currentlyChecking array\r\n */\r\nconst empty_CurrentlyArray_and_SortedArray = (dispatch) => {\r\n    dispatch(setCurrentlyChecking([]));\r\n    dispatch(setSortedArray([]));\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const runningStatus = state.runningStatus;\r\n    return { array, algorithm, runningStatus }\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n    /**\r\n     * Generats a random array of given size and sets it through dispatch\r\n     * @param {*} arraySize Length of the array to be generated\r\n     */\r\n    generateArray: (arraySize) => {\r\n        const randomGeneratedArray = generateRandomArray(arraySize);\r\n        dispatch(setArray(randomGeneratedArray));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n    },\r\n\r\n    /**\r\n     * Changes the algorithm through dispatch\r\n     * @param {*} selectedAlgo New algorithm to be set \r\n     */\r\n    changeAlgorithm: (selectedAlgo) => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(setAlgorithm(selectedAlgo));\r\n    },\r\n\r\n    /**\r\n     * Changes the sorting display speed of algorithm\r\n     * @param {*} selectedSpeed Selected Speed\r\n     */\r\n    changeSpeed: (selectedSpeed) => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(setSpeed(selectedSpeed));\r\n    },\r\n\r\n    /**\r\n     * Starts the sorting\r\n     */\r\n    startSorting: () => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        sort();\r\n    },\r\n\r\n    stopSorting: () => {\r\n        // window.clearTimeout()\r\n    }\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ControlBar);","export const setAlgorithm = (payload) => {\r\n    return {\r\n        type: 'SET_ALGORITHM',\r\n        payload: payload\r\n    }\r\n};\r\n","import bubbleSort from \"./bubbleSort\";\r\nimport mergeSort from \"./mergeSort\";\r\nimport quickSort from \"./quickSort\";\r\nimport heapSort from \"./heapSort\";\r\nimport { store } from \"../store\";\r\nimport { storeDispatch } from \"./helpers\";\r\nimport { setRunningStatus } from \"../actions/runningStatus\";\r\n\r\nexport default function sort() {\r\n\r\n    const state = store.getState();\r\n\r\n    const algorithm = state.algorithm;\r\n\r\n    switch (algorithm) {\r\n\r\n        case 'BUBBLE_SORT': {\r\n            storeDispatch(true, setRunningStatus);\r\n            bubbleSort();\r\n            break;\r\n        }\r\n        case 'MERGE_SORT': {\r\n            storeDispatch(true, setRunningStatus);\r\n            mergeSort();\r\n            break;\r\n        }\r\n        case 'QUICK_SORT': {\r\n            storeDispatch(true, setRunningStatus);\r\n            quickSort();\r\n            break;\r\n        }\r\n        case 'HEAP_SORT': {\r\n            storeDispatch(true, setRunningStatus);\r\n            heapSort();\r\n            break;\r\n        }\r\n        default: {\r\n            console.error(\"No sorting algorithm selected, can't sort\");\r\n            return;\r\n        }\r\n    }\r\n\r\n}","import React from \"react\";\r\nimport ArrayBars from \"../ArrayBars/ArrayBars\";\r\nimport ControlBar from \"../ControlBar/ControlBar\";\r\n\r\nfunction SortingVisualizer() {\r\n    return (\r\n        <div>\r\n            <ControlBar />\r\n            <ArrayBars />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SortingVisualizer;","import React from \"react\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <SortingVisualizer />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport { store } from './store';\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n\n  //wrapping the app around store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}