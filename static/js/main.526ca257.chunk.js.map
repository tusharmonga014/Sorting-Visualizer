{"version":3,"sources":["defaults/index.js","components/ArrayBars/ArrayBars.jsx","components/ArrayBars/ArrayBars.js","components/ControlBar/ControlBar.jsx","reducers/algorithmRedcuer/index.js","reducers/utilities/swapValuesInArray.js","reducers/utilities/setValueInArrayUsingSplice.js","reducers/arrayReducer/index.js","reducers/index.js","reducers/speedReducer/index.js","reducers/currenltyCheckingReducer/index.js","reducers/pivotReducer/index.js","reducers/sortedArrayReducer/index.js","reducers/sortingRunStatus/index.js","store/index.js","actions/array/index.js","actions/currentlyChecking/index.js","actions/sortedArray/index.js","algorithms/helpers/getSortingRunStatus.js","algorithms/helpers/checkCurrentStatus.js","algorithms/helpers/getTimeDelay.js","algorithms/helpers/sleep.js","algorithms/helpers/continueAfterDelayIfNotStopped.js","algorithms/allAlgorithms/bubbleSort.js","actions/sortingRunStatus/index.js","algorithms/allAlgorithms/mergeSort.js","actions/pivot/index.js","algorithms/allAlgorithms/quickSort.js","algorithms/allAlgorithms/heapSort.js","algorithms/allAlgorithms/insertionSort.js","algorithms/ALGORITHMS.js","algorithms/getAlgorithmById.js","algorithms/sort.js","components/ControlBar/ControlBar.js","actions/algorithm/index.js","actions/speed/index.js","components/SortingVisualizer/SortingVisualizer.jsx","components/App.js","index.js"],"names":["ARRAY_MAX_VALUE","window","screen","width","MAX_ARRAY_SIZE","DEFAULT_ARRAY_SIZE","DELAY_BEFORE_COMPLETESORT_EFFECT","arraySize","TIME_BETWEEN_EACH_BAR_EFFECT","MARGIN_BETWEEN_BARS","SCREEN_PERCENTAGE_TO_OCCUPY","ArrayBars","getMarginBetweenBars","getBarsDisplayAreaWidth","screenWidth","Math","floor","getBarWidth","barsDisplayAreaWidth","marginBetween","showBarHeight","event","barId","target","id","barIdForHeightDisplay","bar","document","getElementById","barHeightDisplayBox","style","opacity","removeAttribute","zIndex","hideBarHeight","setAttribute","giveSortingCompletedEffectWhenCompleted","props","array","sortingRunStatus","length","allBars","getElementsByClassName","setTimeout","barsIterator","console","log","classList","add","remove","this","currentlyChecking","pivot","sortedArray","barWidth","displayBarHeight","className","map","idx","backgroundColor","includes","hidden","height","marginLeft","onMouseOver","onMouseLeave","Component","connect","state","algorithm","dispatch","ControlBar","resetArray","generateArray","changeArraySize","value","changeAlgorithm","selectedAlgo","innerText","name","changeSpeed","selectedSpeed","Number","disableArrayAlgorithmInputs","buttonsToBeDisabled","buttonDisablingIterator","disableArrayAlgorithmTexts","textsToBeDisabled","textDisablingIterator","enableArrayAlgorithmInputs","buttonsToBeEnabled","buttonEnablingIterator","enableArrayAlgorithmTexts","textsToBeEnabled","textEnablingIterator","hideStartSortingButton","showStartSortingButton","showPauseButton","hidePauseButton","showContinueButton","hideContinueButton","showStopSortinButton","hideStopSortingButton","manageControlBarFeaturesWhenSortingStarts","manageControlBarFeaturesWhenSortingStops","startSorting","pauseSorting","continueSorting","stopSorting","handleIfSortingCompleted","algorithms","defaultAlgorithm","onClick","type","this_algorithm","min","max","defaultValue","onChange","initialState","checkIfIndexOutOfBounds","index","error","swapValuesInArray","firstIdx","secondIdx","temp","setValueInArrayUsingSplice","replaceCounter","splice","rootReducer","combineReducers","action","payload","data","speed","concat","store","createStore","__REDUX_DEVTOOLS_EXTENSION__","swapValues","setValue","setCurrentlyChecking","setSortedArray","addToSortedArray","getCurrentSortingRunStatus","getState","a","Promise","resolve","reject","setInterval","checkCurrentSortingRunStatus","getTimeDelay","sleep","then","catch","finalCheckResult","continueAfterDelayIfNotStopped","localArray","outerLoopIterator","innerLoopIterator","merge","leftIdx","midIdx","rightIdx","n1","n2","leftLocalArray","Array","rightLocalArray","i","j","k","mergeSortRecursive","parseInt","mergeSort","setPivot","partition","startIdx","endIdx","pivotValue","pivotIdx","quickSortRecursive","heapify","nodeIndex","largest","right","left","HeapSort","extractElementIterator","iterator","backwardIterator","insertionSort","ALGORITHMS","function","getAlgorithmById","algorithmId","algorithmsIterator","sort","getRandomValue","lowerLimit","upperLimit","random","empty_CurrentlyArray_and_SortedArray","randomGeneratedArray","push","generateRandomArray","setAlgorithm","SortingVisualizer","App","ReactDOM","render"],"mappings":"wOAQMA,EAAkBC,OAAOC,OAAOC,OAAS,IAAM,IAAM,IAgBrDC,EAAiBH,OAAOC,OAAOC,OAAS,IAAM,IAAM,IACpDE,EAAqBD,EAAiB,IAoCtCE,EAAmC,SAACC,GACtC,OAAOA,GAAa,GAAK,IACnBA,GAAa,IAAM,IACfA,GAAa,IAAM,IACf,KAOZC,EAA+B,SAACD,GAClC,OAAOA,GAAa,GAAK,EACnBA,GAAa,GAAK,EACdA,GAAa,IAAM,EACf,GAQZE,EAAsB,SAACF,GACzB,OAAOA,GAAa,GAAK,EACnBA,GAAa,GAAK,EACd,GAWRG,EAA8B,SAACH,GACjC,OAAON,OAAOC,OAAOC,OAAS,IAAM,GAC9BI,GAAa,GAAK,GACd,K,eCoECI,E,4MAnKXC,qBAAuB,SAACL,GAEpB,OADsBE,EAAoBF,I,EAI9CM,wBAA0B,SAACN,GACvB,IAAMO,EAAcb,OAAOC,OAAOC,MAElC,OAD6BY,KAAKC,MAAMF,EAAcJ,EAA4BH,K,EAItFU,YAAc,SAACV,EAAWW,EAAsBC,GAE5C,OADkBD,EAAwBC,EAAgBZ,GAAcA,G,EAI5Ea,cAAgB,SAACC,GAKb,IAAMC,EAAQD,EAAME,OAAOC,GACrBC,EAAwB,MAAQH,EAKhCI,EAAMC,SAASC,eAAeN,GAC9BO,EAAsBF,SAASC,eAAeH,GAOpDC,EAAII,MAAMC,QAAU,GACpBF,EAAoBG,gBAAgB,UACpCH,EAAoBC,MAAMG,OAAS,G,EAGvCC,cAAgB,SAACb,GAKb,IAAMC,EAAQD,EAAME,OAAOC,GACrBC,EAAwB,MAAQH,EAKhCI,EAAMC,SAASC,eAAeN,GAC9BO,EAAsBF,SAASC,eAAeH,GAQpDC,EAAII,MAAMC,QAAU,EACpBF,EAAoBM,aAAa,UAAU,GAC3CN,EAAoBC,MAAMG,QAAU,G,EAGxCG,wCAA0C,WACtC,MAAoC,EAAKC,MAAjCC,EAAR,EAAQA,MAAOC,EAAf,EAAeA,iBAKThC,EAAY+B,EAAME,OAGxB,GAAyB,cAArBD,EAAkC,CAClC,IAAME,EAAUd,SAASe,uBAAuB,OAGhDC,YAAW,WAGP,IAHc,IAAD,WAGJC,GACLD,YAAW,WACPE,QAAQC,IAAI,OAEZL,EAAQG,GAAcG,UAAUC,IAAI,0BACrCxC,EAA6BD,GAAaqC,IALxCA,EAAe,EAAGA,EAAeH,EAAQD,OAAQI,IAAiB,EAAlEA,KAOVtC,EAAiCC,IAQpCoC,YAAW,WAEPE,QAAQC,IAAI,OACZ,IAAK,IAAIF,EAAe,EAAGA,EAAeH,EAAQD,OAAQI,IACtDH,EAAQG,GAAcG,UAAUE,OAAO,0BAE5C3C,EAAiCC,GAAcC,EAA6BD,GAAaA,EDpDhE,O,4CCyDpC,WAAU,IAAD,OAEL,EAA2E2C,KAAKb,MAAxEC,EAAR,EAAQA,MAAOa,EAAf,EAAeA,kBAAmBC,EAAlC,EAAkCA,MAAOC,EAAzC,EAAyCA,YAAad,EAAtD,EAAsDA,iBAEhDhC,EAAY+B,EAAME,OAClBtB,EAAuBgC,KAAKrC,wBAAwBN,GACpDY,EAAgB+B,KAAKtC,qBAAqBL,GAC1C+C,EAAWJ,KAAKjC,YAAYV,EAAWW,EAAsBC,GAC7DoC,EAAmBtD,OAAOC,OAAOC,OAAS,KAAOI,EAAY,GAInE,OAFA2C,KAAKd,0CAGD,gCACI,qBAAKoB,UAAU,OAAO1B,MAAO,CAAE3B,MAAOe,GAAtC,SAEQoB,EAAME,OAAS,GAAKF,EAAMmB,KAAI,SAAC/B,EAAKgC,GAChC,IAAIC,EAAkBD,IAAQN,EDtFjC,oBAbG,mBCoGAO,EAAkBN,EAAYO,SAASF,IAA6B,cAArBnB,ED3FjD,mBC2FwGoB,EACtGA,EAAkBR,EAAkBS,SAASF,IAA6B,cAArBnB,EDhG/C,OCgG8GoB,EACpH,IAAMlC,EAAwB,MAAQiC,EAEtC,OACI,gCAGI,qBACIlC,GAAIC,EACJ+B,UAAU,qBACVK,QAAM,EAHV,SAIKnC,IAIL,qBACIF,GAAIkC,EACJF,UAAU,MACV1B,MAAO,CAAE3B,MAAOmD,EAAUQ,OAAQpC,EAAKiC,gBAAiBA,EAAiBI,WAAY5C,GACrF6C,YAAa,EAAK5C,cAClB6C,aAAc,EAAK/B,cALvB,SAMKqB,EAAmB7B,EAAM,OAjBxBgC,QA0B1B,qBAAKF,UAAU,0C,GA9JPU,a,OCaTC,eAdS,SAACC,GAOrB,MAAO,CAAE9B,MANK8B,EAAM9B,MAMJ+B,UALED,EAAMC,UAKGlB,kBAJDiB,EAAMjB,kBAIcC,MAHhCgB,EAAMhB,MAGiCC,YAFjCe,EAAMf,YAEwCd,iBADzC6B,EAAM7B,qBAIR,kBAAM,SAAA+B,GAAQ,MAAK,MAI/BH,CAA6CxD,GC2T7C4D,G,kNAlUbC,WAAa,SAACjE,GACZ,EAAK8B,MAAMoC,cAAclE,I,EAO3BmE,gBAAkB,SAACrD,GACjB,EAAKmD,WAAWnD,EAAME,OAAOoD,Q,EAO/BC,gBAAkB,SAACC,GACjBlD,SAASC,eAAe,0BAA0BkD,UAAYD,EAAaE,KAC3E,EAAK1C,MAAMuC,gBAAgBC,I,EAO7BG,YAAc,SAAC3D,GACb,IAAM4D,EAAiBC,OAAQ7D,EAAME,OAAOoD,OAC5C,EAAKtC,MAAM2C,YAAYC,I,EAOzBE,4BAA8B,WAE5B,IADA,IAAMC,EAAsBzD,SAASe,uBAAuB,8BACnD2C,EAA0B,EAAGA,EAA0BD,EAAoB5C,OAAQ6C,IAC1FD,EAAoBC,GAAyBlD,aAAa,YAAY,I,EAO1EmD,2BAA6B,WAE3B,IADA,IAAMC,EAAoB5D,SAASe,uBAAuB,6BACjD8C,EAAwB,EAAGA,EAAwBD,EAAkB/C,OAAQgD,IACpFD,EAAkBC,GAAuBzC,UAAUE,OAAO,cAC1DsC,EAAkBC,GAAuBzC,UAAUC,IAAI,e,EAQ3DyC,2BAA6B,WAE3B,IADA,IAAMC,EAAqB/D,SAASe,uBAAuB,8BAClDiD,EAAyB,EAAGA,EAAyBD,EAAmBlD,OAAQmD,IACvFD,EAAmBC,GAAwB3D,gBAAgB,a,EAO/D4D,0BAA4B,WAE1B,IADA,IAAMC,EAAmBlE,SAASe,uBAAuB,6BAChDoD,EAAuB,EAAGA,EAAuBD,EAAiBrD,OAAQsD,IACjFD,EAAiBC,GAAsB/C,UAAUE,OAAO,cACxD4C,EAAiBC,GAAsB/C,UAAUC,IAAI,e,EAOzD+C,uBAAyB,WACIpE,SAASC,eAAe,YAChCO,aAAa,UAAU,I,EAM5C6D,uBAAyB,WACIrE,SAASC,eAAe,YAChCI,gBAAgB,W,EAMrCiE,gBAAkB,WACItE,SAASC,eAAe,aAChCI,gBAAgB,W,EAM9BkE,gBAAkB,WACIvE,SAASC,eAAe,aAChCO,aAAa,UAAU,I,EAMrCgE,mBAAqB,WACIxE,SAASC,eAAe,gBAChCI,gBAAgB,W,EAMjCoE,mBAAqB,WACIzE,SAASC,eAAe,gBAChCO,aAAa,UAAU,I,EAMxCkE,qBAAuB,WACK1E,SAASC,eAAe,iBAChCI,gBAAgB,W,EAMpCsE,sBAAwB,WACI3E,SAASC,eAAe,iBAChCO,aAAa,UAAU,I,EAO3CoE,0CAA4C,WAC1C,EAAKpB,8BACL,EAAKG,6BACL,EAAKS,yBACL,EAAKE,kBACL,EAAKI,wB,EAOPG,yCAA2C,WACzC,EAAKf,6BACL,EAAKG,4BACL,EAAKM,kBACL,EAAKE,qBACL,EAAKE,wBACL,EAAKN,0B,EAOPS,aAAe,WACb,EAAKF,4CACL,EAAKlE,MAAMoE,gB,EAMbC,aAAe,WACb,EAAKrE,MAAMqE,eACX,EAAKR,kBACL,EAAKC,sB,EAMPQ,gBAAkB,WAChB,EAAKP,qBACL,EAAKH,kBACL,EAAK5D,MAAMsE,mB,EAMbC,YAAc,WACZ,EAAKJ,2CACL,EAAKnE,MAAMuE,e,EAQbC,yBAA2B,WACO,cAAhC,EAAKxE,MAAME,kBAAoC,EAAKiE,4C,uDAGtD,WACEtD,KAAKsB,WAAWnE,K,oBAIlB,WAAU,IAAD,OACP,EAAgD6C,KAAKb,MAA7CC,EAAR,EAAQA,MAAOwE,EAAf,EAAeA,WAAYC,EAA3B,EAA2BA,iBACrBxG,EAAY+B,EAAME,OAIxB,OAFAU,KAAK2D,2BAGH,sBAAKrD,UAAU,uDAAf,UACE,qBAAKA,UAAU,sEAAf,SACE,sDAGF,sBAAKA,UAAU,sCAAf,UACE,wBAAQA,UAAU,uFAChBwD,QAAS,WAAQ,EAAKxC,WAAWjE,IADnC,gCAKA,sBAAKiD,UAAU,8BAAf,UACE,wBACEyD,KAAK,SACLzF,GAAG,yBACHgC,UAAU,oEACV,cAAY,WACZ,gBAAc,OACd,gBAAc,QANhB,SAOGuD,EAAiBhC,OAEpB,sBAAKvB,UAAU,gBAAf,UACE,oBAAIA,UAAU,6BAAd,8BAEEsD,EAAWrD,KAAI,SAACyD,GACd,OACE,gCACE,qBAAK1D,UAAU,qBACf,wBAAQA,UAAU,gBAChBwD,QAAS,kBAAM,EAAKpC,gBAAgBsC,IADtC,SAEGA,EAAenC,SAJVmC,EAAe1F,gBAcrC,sBAAKgC,UAAU,0DAAf,UACE,qBAAKA,UAAU,oHAAf,0BAGA,uBACEA,UAAU,2GACVyD,KAAK,QACLE,IHhQW,GGiQXC,IAAKhH,EACLiH,aAAchH,EACdiH,SAAUpE,KAAKwB,kBAEjB,qBAAKlB,UAAU,qFAAf,6BAGA,uBACEA,UAAU,2EACVyD,KAAK,QACLE,IAAI,IACJC,IHlRsB,IGmRtBC,aHlRmB,IGmRnBC,SAAUpE,KAAK8B,iBAInB,sBAAKxB,UAAU,qDAAf,UACE,wBACEhC,GAAG,WACHgC,UAAU,kBACVwD,QAAS9D,KAAKuD,aAHhB,2BAOA,wBACEjF,GAAG,YACHgC,UAAU,wCACVwD,QAAS9D,KAAKwD,aACd7C,QAAM,EAJR,mBAQA,wBACErC,GAAG,eACHgC,UAAU,wCACVwD,QAAS9D,KAAKyD,gBACd9C,QAAM,EAJR,sBAOA,wBACErC,GAAG,gBACHgC,UAAU,kCACVwD,QAAS9D,KAAK0D,YACd/C,QAAM,EAJR,4B,GAzTeK,c,8BCFrBqD,EAAe,CACf/F,GJ+CkC,GKlDtC,SAASgG,EAAwBC,EAAOlH,GACpC,OAAIkH,EAAQ,GAAKA,GAASlH,KACtBsC,QAAQ6E,MAAMD,EAAQ,6CAA+ClH,EAAY,yBAC1E,GAWR,SAASoH,EAAkBrF,EAAOsF,EAAUC,GAE/C,IAAMtH,EAAY+B,EAAME,OAGxB,GAAIgF,EAAwBI,EAAUrH,IAAciH,EAAwBK,EAAWtH,GACnF,OAAO+B,EAGX,IAAIwF,EAAOxF,EAAMsF,GAIjB,OAHAtF,EAAMsF,GAAYtF,EAAMuF,GACxBvF,EAAMuF,GAAaC,EAEZxF,ECnBJ,SAASyF,EAA2BzF,EAAOmF,EAAOO,EAAgBrD,GAErE,OADArC,EAAM2F,OAAOR,EAAOO,EAAgBrD,GAC7BrC,ECRJ,ICiBQ4F,EAVKC,YAAgB,CAChC7F,MDRiB,WAAyB,IAAxB8B,EAAuB,uDAAf,GAAIgE,EAAW,uCACzC,OAAQA,EAAOnB,MACX,IAAK,YACD,OAAOmB,EAAOC,QAClB,IAAK,cACD,OAAOV,EAAkBvD,EAAOgE,EAAOC,QAAQT,SAAUQ,EAAOC,QAAQR,WAC5E,IAAK,YACD,OAAOE,EAA2B3D,EAAOgE,EAAOC,QAAQ7G,GAAI,EAAG4G,EAAOC,QAAQC,MAClF,QAAS,OAAOlE,ICCpBC,UJLqB,WAAmC,IAAlCD,EAAiC,uDAAzBmD,EAAca,EAAW,uCACvD,OAAQA,EAAOnB,MACX,IAAK,gBACD,OAAOmB,EAAOC,QAClB,QAAS,OAAOjE,IIEpBmE,MCViB,WAA6C,IAA5CnE,EAA2C,uDTalC,ISbuBgE,EAAW,uCAC7D,OAAQA,EAAOnB,MACX,IAAK,YACD,OAAOmB,EAAOC,QAElB,QAAS,OAAOjE,IDMpBjB,kBET6B,WAAyB,IAAxBiB,EAAuB,uDAAf,GAAIgE,EAAW,uCACrD,OAAQA,EAAOnB,MACX,IAAK,wBACD,OAAOmB,EAAOC,QAElB,QAAS,OAAOjE,IFKpBhB,MGbiB,WAAyB,IAAxBgB,EAAuB,wDAAd,EAAGgE,EAAW,uCACzC,OAAQA,EAAOnB,MACX,IAAK,YACD,OAAOmB,EAAOC,QAElB,QAAS,OAAOjE,IHSpBf,YIduB,WAAyB,IAAxBe,EAAuB,uDAAf,GAAIgE,EAAW,uCAC/C,OAAQA,EAAOnB,MACX,IAAK,kBACD,OAAOmB,EAAOC,QAClB,IAAK,qBACD,OAAOjE,EAAMoE,OAAOJ,EAAOC,SAC/B,QAAS,OAAOjE,IJSpB7B,iBKf4B,WAAoC,IAAnC6B,EAAkC,uDAA1B,cAAegE,EAAW,uCAC/D,OAAQA,EAAOnB,MACX,IAAK,UACD,MAAO,UACX,IAAK,YACD,MAAO,YACX,IAAK,SACD,MAAO,SACX,IAAK,UACD,MAAO,UACX,IAAK,YACD,MAAO,YACX,IAAK,UACD,MAAO,cAEX,QAAS,OAAO7C,MCbXqE,EAAQC,YACjBR,EACAjI,OAAO0I,8BAAgC1I,OAAO0I,gCCQrCC,EAAa,SAAChB,EAAUC,GACjC,MAAO,CACHZ,KAAM,cACNoB,QAAS,CACLT,SAAUA,EACVC,UAAWA,KAYVgB,EAAW,SAACpB,EAAO9C,GAC5B,MAAO,CACHsC,KAAM,YACNoB,QAAS,CACL7G,GAAIiG,EACJa,KAAM3D,KCnCLmE,EAAuB,SAACT,GACjC,MAAO,CACHpB,KAAM,wBACNoB,QAASA,ICCJU,EAAiB,SAACV,GAC3B,MAAO,CACHpB,KAAM,kBACNoB,QAASA,IAQJW,EAAmB,SAACX,GAC7B,MAAO,CACHpB,KAAM,qBACNoB,QAASA,ICHFY,MATf,WAMI,OAJcR,EAAMS,WAGC3G,kB,4CCTzB,sBAAA4G,EAAA,yDACyC,WAAjCF,IADR,yCAEe,IAAIG,SAAQ,SAACC,EAASC,GACzBC,aAAY,WAC6B,cAAjCN,IACAI,IACsC,YAAjCJ,KACLK,MACL,QARf,UAWgD,YAAjCL,IAXf,yCAYe,IAAIG,SAAQ,SAACC,EAASC,GAAV,OAAqBA,QAZhD,gCAce,IAAIF,SAAQ,SAAAC,GAAO,OAAIA,QAdtC,4C,sBAkBeG,M,2CCNAC,MANf,WAGI,OpBG8B,IoBLhBhB,EAAMS,WACAX,O,4CCRxB,sBAAAY,EAAA,sEACU,IAAIC,SAAQ,SAACC,GACf1G,YAAW,kBAAM0G,MAAWI,QAFpC,4C,sBAMeC,M,uFCDf,4BAAAP,EAAA,sEAG6BK,IACpBG,MAAK,kBAAM,KACXC,OAAM,kBAAM,KALrB,2DAOe,GAPf,uBAUUF,IAVV,uBAaiCF,IACxBG,MAAK,kBAAM,KACXC,OAAM,kBAAM,KAfrB,cAaQC,EAbR,yBAiBWA,GAjBX,6C,sBAoBeC,M,uFCPf,oCAAAX,EAAA,sDAMU/E,EAAQqE,EAAMS,WAKda,EAAa3F,EAAM9B,MAKnB/B,EAAY6D,EAAM9B,MAAME,QAKX,EAKVwH,EAAoB,EA1BjC,YA0BoCA,EAAoBzJ,EAAY,GA1BpE,iBA2BY0J,EAAoB,EAGnBA,EAAoB,EA9BjC,YA8BoCA,EAAoB1J,EAAYyJ,EAAoB,GA9BxF,kCAiCiCF,IAjCjC,wEAuCYrB,EAAMnE,SAASwE,EAAqB,CAACmB,EAAmBA,EAAoB,OAExEF,EAAWE,GAAqBF,EAAWE,EAAoB,IAzC/E,kCA4CqCH,IA5CrC,qEAkDgBrB,EAAMnE,SAASsE,EAAWqB,EAAmBA,EAAoB,IAlDjF,yBAsDiCH,IAtDjC,qEA8B2FG,IA9B3F,uBA6DQxB,EAAMnE,SAAS0E,EAAiBiB,IA7DxC,QA0BuED,IA1BvE,uBAiEIvB,EAAMnE,SAASwE,EAAqB,KAIpCL,EAAMnE,SAAS0E,EAAiB,IAGhCP,EAAMnE,SCnEC,CACH2C,KAAM,cDNd,6C,+BEaeiD,E,oFAAf,WAAqBH,EAAYI,EAASC,EAAQC,GAAlD,+BAAAlB,EAAA,sDAWI,IARImB,EAAKF,EAASD,EAAU,EACxBI,EAAKF,EAAWD,EAGhBI,EAAiB,IAAIC,MAAMH,GAC3BI,EAAkB,IAAID,MAAMF,GAGvBI,EAAI,EAAGA,EAAIL,EAAIK,IACpBH,EAAeG,GAAKZ,EAAW,CAACI,EAAUQ,IAC9C,IAASC,EAAI,EAAGA,EAAIL,EAAIK,IACpBF,EAAgBE,GAAKb,EAAWK,EAAS,EAAIQ,GAY7CD,EAAI,EAGJC,EAAI,EAGJC,EAAIV,GAKW,EArCvB,aAuCWQ,EAAIL,GAAMM,EAAIL,GAvCzB,kCA0C6BT,IA1C7B,wEAmDQrB,EAAMnE,SAASwE,EAAqB,CAACqB,EAAUQ,EAAGP,EAASQ,EAAI,OAE3DJ,EAAeG,IAAMD,EAAgBE,IArDjD,kCAwDiCd,IAxDjC,qEA6DYrB,EAAMnE,SAASuE,EAASgC,EAAGL,EAAeG,KAE1CA,IA/DZ,yCAoEiCb,IApEjC,qEAyEYrB,EAAMnE,SAASuE,EAASgC,EAAGH,EAAgBE,KAE3CA,IA3EZ,QA8EQC,IA9ER,6BAmFWF,EAAIL,GAnFf,kCAsF6BR,IAtF7B,sFA4FcJ,IA5Fd,eAkGQjB,EAAMnE,SAASwE,EAAqB,CAACqB,EAAUQ,KAlGvD,UAqG6Bb,IArG7B,qEA0GQrB,EAAMnE,SAASuE,EAASgC,EAAGL,EAAeG,KAE1CA,IACAE,IA7GR,6BAkHWD,EAAIL,GAlHf,kCAqH6BT,IArH7B,4EA8HQrB,EAAMnE,SAASwE,EAAqB,CAACsB,EAASQ,EAAI,KA9H1D,UAiIclB,IAjId,QAmIQjB,EAAMnE,SAASuE,EAASgC,EAAGH,EAAgBE,KAE3CA,IACAC,IAtIR,6D,+BAiJeC,E,kFAAf,WAAkCf,EAAYI,EAASE,GAAvD,eAAAlB,EAAA,2DACQgB,GAAWE,GADnB,wDAQUD,EAASD,EAAUY,UAAUV,EAAWF,GAAW,GAR7D,SAa6BX,IACpBG,KADoB,sBACf,sBAAAR,EAAA,sEACI2B,EAAmBf,EAAYI,EAASC,GAD5C,uBAEIU,EAAmBf,EAAYK,EAAS,EAAGC,GAF/C,uBAGIH,EAAMH,EAAYI,EAASC,EAAQC,GAHvC,iCAIK,GAJL,4CAMLT,OAAM,kBAAM,KApBrB,uG,kEA8BA,gCAAAT,EAAA,6DAKU/E,EAAQqE,EAAMS,WAKda,EAAa3F,EAAM9B,MAKnB/B,EAAY6D,EAAM9B,MAAME,OAflC,SAkBUsI,EAAmBf,EAAY,EAAGxJ,EAAY,GAlBxD,uBA0B4BiJ,IACnBG,MAAK,kBAAM,KACXC,OAAM,kBAAM,KA5BrB,eAgCQnB,EAAMnE,SAASyE,EAAe,KAC9BN,EAAMnE,SAASwE,EAAqB,MAIpCL,EAAMnE,SD5NH,CACH2C,KAAM,cCsLd,4C,sBAwCe+D,ICxPFC,EAAW,SAAC5C,GACrB,MAAO,CACHpB,KAAM,YACNoB,QAASA,I,SC2BF6C,E,kFAAf,WAAyBnB,EAAYoB,EAAUC,GAA/C,mBAAAjC,EAAA,sDAMUkC,EAAatB,EAAWqB,GAC9B3C,EAAMnE,SAAS2G,EAASG,IAKpBE,EAAWH,GAKI,EAEVzH,EAAMyH,EAnBnB,YAmB6BzH,EAAM0H,GAnBnC,iCAsB6BtB,IAtB7B,uEA+BQrB,EAAMnE,SAASwE,EAAqB,CAACpF,EAAK4H,OAEtCvB,EAAWrG,IAAQ2H,GAjC/B,kCAmCiCvB,IAnCjC,qEAyCYrB,EAAMnE,SAASsE,EAAWlF,EAAK4H,IAG/BA,IA5CZ,yBAgD6BxB,IAhD7B,qEAwDQrB,EAAMnE,SAASwE,EAAqB,KAxD5C,QAmB2CpF,IAnB3C,wCA4DyBoG,IA5DzB,4EAkEIrB,EAAMnE,SAASsE,EAAWwC,EAAQE,IAlEtC,kBAoEWA,GApEX,6C,+BAuEeC,G,qFAAf,WAAkCxB,EAAYoB,EAAUC,GAAxD,eAAAjC,EAAA,2DAEQgC,GAAYC,GAFpB,iEAO2BF,EAAUnB,EAAYoB,EAAUC,GAP3D,cAOUE,EAPV,OASI7C,EAAMnE,SAAS0E,EAAiBsC,IATpC,SAc6B9B,IACpBG,KADoB,sBACf,sBAAAR,EAAA,6DAEFV,EAAMnE,SAAS0E,EAAiBsC,IAF9B,SAGIC,GAAmBxB,EAAYoB,EAAUG,EAAW,GAHxD,cAKF7C,EAAMnE,SAAS0E,EAAiBmC,IAL9B,SAMII,GAAmBxB,EAAYuB,EAAW,EAAGF,GANjD,OAQF3C,EAAMnE,SAAS0E,EAAiBsC,EAAW,IARzC,4CAUL1B,OAAM,kBAAM,KAzBrB,yG,oEAkCA,gCAAAT,EAAA,6DAKU/E,EAAQqE,EAAMS,WAKda,EAAa3F,EAAM9B,MAKnB/B,EAAY6D,EAAM9B,MAAME,OAflC,SAkBU+I,GAAmBxB,EAAY,EAAGxJ,EAAY,GAlBxD,cAqBIkI,EAAMnE,SAAS2G,EAAS,OArB5B,SA6B4BzB,IACnBG,MAAK,kBAAM,KACXC,OAAM,kBAAM,KA/BrB,eAmCQnB,EAAMnE,SAASyE,EAAe,KAC9BN,EAAMnE,SAASwE,EAAqB,MAIpCL,EAAMnE,SHtJH,CACH2C,KAAM,cG6Gd,6C,+BCtGeuE,G,qFAAf,WAAuBzB,EAAY0B,EAAWlL,GAA9C,mBAAA4I,EAAA,6DACQuC,EAAUD,EAERE,EAAQ,EAAIF,EAAY,GAKX,GANbG,EAAO,EAAIH,EAAY,GASlBlL,GAAawJ,EAAW6B,GAAQ7B,EAAW2B,KAClDA,EAAUE,GAGVD,EAAQpL,GAAawJ,EAAW4B,GAAS5B,EAAW2B,KACpDA,EAAUC,GAhBlB,SAoByB7B,IApBzB,uEA8BIrB,EAAMnE,SAASwE,EAAqB,CAAC4C,EAASD,KAG1CC,IAAYD,EAjCpB,kCAoC6B3B,IApC7B,4EA0CQrB,EAAMnE,SAASsE,EAAW8C,EAASD,IA1C3C,UA6CcD,GAAQzB,EAAY2B,EAASnL,GA7C3C,6C,+BAoDesL,G,iFAAf,WAAwB9B,GAAxB,2BAAAZ,EAAA,sDAIU5I,EAAYwJ,EAAWvH,OAJjC,IAAA2G,EAAA,iBAOasC,GAPb,SAAAtC,EAAA,sEAWiCK,IACpBG,KADoB,sBACf,sBAAAR,EAAA,sEACIqC,GAAQzB,EAAY0B,EAAWlL,GADnC,iCAEK,GAFL,4CAILqJ,OAAM,kBAAM,KAhBzB,gHAOa6B,EAAY1K,KAAKC,MAAMT,EAAY,GAAK,EAPrD,YAOwDkL,GAAa,GAPrE,0CAOaA,GAPb,iGAOwEA,IAPxE,2BAAAtC,EAAA,iBAuBa2C,GAvBb,SAAA3C,EAAA,sEA4BiCW,IA5BjC,oFAkCQrB,EAAMnE,SAASsE,EAAW,EAAGkD,IAI7BrD,EAAMnE,SAASwE,EAAqB,KAGpCL,EAAMnE,SAAS0E,EAAiB8C,IAzCxC,UA4C6BtC,IAChBG,KADgB,sBACX,sBAAAR,EAAA,sEACIqC,GAAQzB,EAAY,EAAG+B,GAD3B,iCAEK,GAFL,4CAILlC,OAAM,kBAAM,KAjDzB,mHAuBakC,EAAyBvL,EAAY,EAvBlD,aAuBqDuL,EAAyB,GAvB9E,0CAuBaA,GAvBb,qGAuBiFA,IAvBjF,6D,oEA2DA,8BAAA3C,EAAA,6DAKU/E,EAAQqE,EAAMS,WAKda,EAAa3F,EAAM9B,MAV7B,SAaUuJ,GAAS9B,GAbnB,uBAqB4BP,IACnBG,MAAK,kBAAM,KACXC,OAAM,kBAAM,KAvBrB,eA2BQnB,EAAMnE,SAASyE,EAAe,KAC9BN,EAAMnE,SAASwE,EAAqB,MAIpCL,EAAMnE,SJvJH,CACH2C,KAAM,cIsHd,4C,oEC5HA,oCAAAkC,EAAA,sDAKU/E,EAAQqE,EAAMS,WAKda,EAAa3F,EAAM9B,MAKnB/B,EAAY6D,EAAM9B,MAAME,QAKX,EAIVuJ,EAAW,EAxBxB,YAwB2BA,EAAWxL,GAxBtC,wBA4BYyL,EAAmBD,EA5B/B,SA+B6BjC,IA/B7B,oEAqCQrB,EAAMnE,SAASwE,EAAqB,CAACkD,KAMrCvD,EAAMnE,SAAS0E,EAAiB+C,IA3CxC,aAkDeC,EAAmB,GAAKjC,EAAWiC,EAAmB,GAAKjC,EAAWiC,IAlDrF,kCAqDiClC,IArDjC,qEA8DYrB,EAAMnE,SAASsE,EAAWoD,EAAmB,EAAGA,IAGhDvD,EAAMnE,SAASwE,EAAqB,CAACkD,EAAmB,KAExDA,IAnEZ,wBAwBiDD,IAxBjD,uBAwEItD,EAAMnE,SLnEC,CACH2C,KAAM,cKNd,6C,sBA2EegF,IC9CAC,GAvCI,CACf,CACI1K,GAAI,EACJuD,KAAM,aACNJ,MAAO,aACPwH,S,4CAEJ,CACI3K,GAAI,EACJuD,KAAM,cACNJ,MAAO,cACPwH,S,4CAEJ,CACI3K,GAAI,EACJuD,KAAM,YACNJ,MAAO,YACPwH,S,6CAEJ,CACI3K,GAAI,EACJuD,KAAM,iBACNJ,MAAO,iBACPwH,S,6CAEJ,CACI3K,GAAI,EACJuD,KAAM,aACNJ,MAAO,aACPwH,S,6CAEJ,CACI3K,GAAI,EACJuD,KAAM,iBACNJ,MAAO,mBCvBAyH,OAdf,SAA0BC,GAGtB,IAAK,IAAIC,EAAqB,EAAGA,EAAqBJ,GAAW1J,OAAQ8J,IACrE,GAAIJ,GAAWI,GAAoB9K,KAAO6K,EACtC,OAAOH,GAAWI,GAM1B,OADAzJ,QAAQC,IAAI,0CAA4CuJ,EAAc,KAC/D,ICkBIE,OA5Bf,WAII,IAKIlI,EALUoE,EAAMS,WAKE7E,UAMtBA,EAAY+H,GAAiB/H,EAAU7C,IAEnC0K,GAAWtI,SAASS,IAEpBoE,EAAMnE,SR1BH,CACH2C,KAAM,YQ0BN5C,EAAU8H,YAGVtJ,QAAQ6E,MAAM,8CCdhB8E,GAAiB,SAACC,EAAYC,GAChC,OAAO3L,KAAKC,MAAMD,KAAK4L,UAAYD,EAAa,IAAMD,GAuBpDG,GAAuC,SAACtI,GAC1CA,EAASwE,EAAqB,KAC9BxE,EAASyE,EAAe,MA+Eb5E,gBA5ES,SAACC,GAMrB,MAAO,CAAE9B,MALK8B,EAAM9B,MAKJ+B,UAJED,EAAMC,UAIG9B,iBAHF6B,EAAM7B,iBAGcuE,WAF1BoF,GAEsCnF,iBADhCqF,GjCDS,OiCKX,kBAAM,SAAA9H,GAAQ,MAAK,CAM1CG,cAAe,SAAClE,GACZ,IAAMsM,EApCc,SAACtM,GAIzB,IAHA,IAAM+B,EAAQ,GAERoK,EAAa1M,EACV2K,EAAI,EAAGA,EAAIpK,EAAWoK,IAC3BrI,EAAMwK,KAAKN,GjC5BK,GiC4BsBE,IAE1C,OAAOpK,EA6B0ByK,CAAoBxM,GACjD+D,ElB9DG,CACH2C,KAAM,YACNoB,QkB4DkBwE,IAClBD,GAAqCtI,GACrCA,ETlCG,CACH2C,KAAM,aSwCVrC,gBAAiB,SAACC,GACdP,ECtEoB,WACxB,MAAO,CACH2C,KAAM,gBACNoB,QAHmF,uDAApD+D,GlC+CD,IiCuBrBY,CAAanI,IACtB+H,GAAqCtI,GACrCA,ET5CG,CACH2C,KAAM,aSkDVjC,YAAa,SAACC,GACVX,EElFG,CACH2C,KAAM,YACNoB,QFgFkBpD,IAClB2H,GAAqCtI,GACrCA,ETtDG,CACH2C,KAAM,aS2DVR,aAAc,WACVmG,GAAqCtI,GACrCiI,MAOJ7F,aAAc,WACVpC,ETxFG,CACH2C,KAAM,YS8FVN,gBAAiB,WACbrC,ETtGG,CACH2C,KAAM,eS4GVL,YAAa,WACTtC,ETlGG,CACH2C,KAAM,YSkGN2F,GAAqCtI,QAI9BH,CAA6CI,GG7G7C0I,OATf,WACI,OACI,gCACI,cAAC,GAAD,IACA,cAAC,EAAD,QCCGC,OANf,WACE,OACE,cAAC,GAAD,KCCJC,IAASC,OAGP,cAAC,IAAD,CAAU3E,MAAOA,EAAjB,SACE,cAAC,GAAD,MAGF9G,SAASC,eAAe,W","file":"static/js/main.526ca257.chunk.js","sourcesContent":["/**\r\n * Array's lowest value\r\n */\r\nconst ARRAY_MIN_VALUE = 40;\r\n/**\r\n * Array's largest value\r\n * ARRAY_MAX_VALUE > 500 will overlap with Control-Bar\r\n */\r\nconst ARRAY_MAX_VALUE = window.screen.width <= 700 ? 350 : 425;\r\n\r\n/**\r\n * Sorting speed range\r\n * SORTING_SPEED_LOWER_LIMIT is 0 always\r\n */\r\nconst SORTING_SPEED_UPPER_LIMIT = 500;\r\nconst DEFAULT_SELECTED_SPEED = 500;\r\n\r\n/**\r\n * Minimum array length\r\n */\r\nconst MIN_ARRAY_SIZE = 10;\r\n/**\r\n * Maximum array length\r\n */\r\nconst MAX_ARRAY_SIZE = window.screen.width <= 600 ? 100 : 200;\r\nconst DEFAULT_ARRAY_SIZE = MAX_ARRAY_SIZE / 1.5;\r\n\r\n/**\r\n * Bar colour when its neither sorted \r\n * nor in the process of being sorted\r\n */\r\nconst BAR__COLOUR_DEFAULT = 'rgb(0, 204, 255)';\r\n// const BAR__COLOUR_DEFAULT = 'rgb(0, 255, 145)';\r\n/**\r\n * Bar colour when its in the process for sorting\r\n */\r\nconst BAR_COLOUR_WHILE_CHECKING = 'blue';\r\n/**\r\n * Bar colour when it has been sorted\r\n */\r\nconst BAR_COLOUR_SORTED = 'rgb(184, 0, 162)';\r\n/**\r\n * Bar colour when it is pivot\r\n */\r\nconst BAR_COLOUR_PIVOT = 'rgb(255, 117, 26)';\r\n\r\n/**\r\n * Default selected sorting algorithm Id\r\n * shown in dropdown algo selector\r\n */\r\nconst DEFAULT_SELECTED_ALGORITHM_ID = 0;\r\n\r\n/**\r\n * Time delay (in ms) after finish \r\n * of sorting completion effect\r\n */\r\nconst DELAY_AFTER_COMPLETESORT_EFFECT = 1000;\r\n/**\r\n * Time delay (in ms) before start \r\n * of sorting completion effect\r\n */\r\nconst DELAY_BEFORE_COMPLETESORT_EFFECT = (arraySize) => {\r\n    return arraySize <= 50 ? 700\r\n        : arraySize <= 100 ? 500\r\n            : arraySize <= 150 ? 400\r\n                : 300;\r\n}\r\n/**\r\n * Returns time (in ms) between each bar effect\r\n * @param {number} arraySize Length of the array\r\n * @returns Time (in ms) between each bar effect\r\n */\r\nconst TIME_BETWEEN_EACH_BAR_EFFECT = (arraySize) => {\r\n    return arraySize <= 10 ? 8\r\n        : arraySize <= 50 ? 6\r\n            : arraySize <= 150 ? 4\r\n                : 3;\r\n}\r\n\r\n/**\r\n * tells margin between bars\r\n * @param {*} arraySize the length of array \r\n * @returns space between each bar depending upon the arraySize\r\n */\r\nconst MARGIN_BETWEEN_BARS = (arraySize) => {\r\n    return arraySize <= 10 ? 4\r\n        : arraySize <= 50 ? 2\r\n            : 1;\r\n};\r\n\r\n/**\r\n * tells the amount of screen to occupy\r\n * @param {*} arraySize the length of the array\r\n * @returns the amount of screen to occupy in \r\n *          terms of decimal from 0-1 where \r\n *          0 shows empty space and\r\n *          1 shows full screen \r\n */\r\nconst SCREEN_PERCENTAGE_TO_OCCUPY = (arraySize) => {\r\n    return window.screen.width <= 600 ? 0.80\r\n        : arraySize <= 16 ? 0.50\r\n            : 0.66;\r\n}\r\n\r\n/**\r\n * .............................\r\n * EXPORTS\r\n * ............................. \r\n */\r\nexport {\r\n    ARRAY_MIN_VALUE,\r\n    ARRAY_MAX_VALUE,\r\n    SORTING_SPEED_UPPER_LIMIT,\r\n    DEFAULT_SELECTED_SPEED,\r\n    MIN_ARRAY_SIZE,\r\n    MAX_ARRAY_SIZE,\r\n    DEFAULT_ARRAY_SIZE,\r\n    BAR__COLOUR_DEFAULT,\r\n    BAR_COLOUR_WHILE_CHECKING,\r\n    BAR_COLOUR_SORTED,\r\n    BAR_COLOUR_PIVOT,\r\n    DEFAULT_SELECTED_ALGORITHM_ID,\r\n    DELAY_AFTER_COMPLETESORT_EFFECT,\r\n    DELAY_BEFORE_COMPLETESORT_EFFECT,\r\n    TIME_BETWEEN_EACH_BAR_EFFECT,\r\n    MARGIN_BETWEEN_BARS,\r\n    SCREEN_PERCENTAGE_TO_OCCUPY\r\n}","import React, { Component } from \"react\"\r\nimport { BAR_COLOUR_PIVOT, BAR_COLOUR_SORTED, BAR_COLOUR_WHILE_CHECKING, BAR__COLOUR_DEFAULT, DELAY_AFTER_COMPLETESORT_EFFECT, DELAY_BEFORE_COMPLETESORT_EFFECT, MARGIN_BETWEEN_BARS, SCREEN_PERCENTAGE_TO_OCCUPY, TIME_BETWEEN_EACH_BAR_EFFECT } from \"../../defaults\";\r\nimport \"./ArrayBars.css\";\r\n\r\nclass ArrayBars extends Component {\r\n\r\n    getMarginBetweenBars = (arraySize) => {\r\n        const marginBetween = MARGIN_BETWEEN_BARS(arraySize);\r\n        return marginBetween;\r\n    }\r\n\r\n    getBarsDisplayAreaWidth = (arraySize) => {\r\n        const screenWidth = window.screen.width;\r\n        const barsDisplayAreaWidth = Math.floor(screenWidth * SCREEN_PERCENTAGE_TO_OCCUPY(arraySize));\r\n        return barsDisplayAreaWidth;\r\n    }\r\n\r\n    getBarWidth = (arraySize, barsDisplayAreaWidth, marginBetween) => {\r\n        const barWidth = (barsDisplayAreaWidth - (marginBetween * arraySize)) / arraySize;\r\n        return barWidth;\r\n    }\r\n\r\n    showBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes 0.5 when mouse enters the bar,\r\n         * Height Display Box becomes visible,\r\n         * Z-index of box is set to 1 to bring it forward than bar\r\n         */\r\n        bar.style.opacity = 0.5;\r\n        barHeightDisplayBox.removeAttribute('hidden');\r\n        barHeightDisplayBox.style.zIndex = 1;\r\n    }\r\n\r\n    hideBarHeight = (event) => {\r\n        /**\r\n         * Obataining bar and its height display \r\n         * box id from the event\r\n         */\r\n        const barId = event.target.id;\r\n        const barIdForHeightDisplay = 'bar' + barId;\r\n\r\n        /**\r\n         * Getting the HTML element through their ids\r\n         */\r\n        const bar = document.getElementById(barId);\r\n        const barHeightDisplayBox = document.getElementById(barIdForHeightDisplay);\r\n\r\n        /**\r\n         * Opacity becomes normal when mouse leaves the bar,\r\n         * Height Display Box again becomes hidden,\r\n         * Z-index of box is again set to -1 to prevent its area\r\n         * from stopping mouse over effect for its bar\r\n         */\r\n        bar.style.opacity = 1;\r\n        barHeightDisplayBox.setAttribute('hidden', true);\r\n        barHeightDisplayBox.style.zIndex = -1;\r\n    }\r\n\r\n    giveSortingCompletedEffectWhenCompleted = () => {\r\n        const { array, sortingRunStatus } = this.props;\r\n\r\n        /**\r\n         * Length of store's state array\r\n         */\r\n        const arraySize = array.length;\r\n\r\n        // If sorting is commpleted show effect\r\n        if (sortingRunStatus === 'COMPLETED') {\r\n            const allBars = document.getElementsByClassName('bar');\r\n\r\n            // After DELAY_BEFORE_COMPLETESORT_EFFECT ms of sorting completion show effect\r\n            setTimeout(() => {\r\n\r\n                // Iterating on each bar at gap of TIME_BETWEEN_EACH_BAR_EFFECT ms\r\n                for (let barsIterator = 0; barsIterator < allBars.length; barsIterator++) {\r\n                    setTimeout(() => {\r\n                        console.log('yes');\r\n                        // Add effect class which has background color as !important\r\n                        allBars[barsIterator].classList.add('complete-sort-effect');\r\n                    }, TIME_BETWEEN_EACH_BAR_EFFECT(arraySize) * barsIterator);\r\n                }\r\n            }, DELAY_BEFORE_COMPLETESORT_EFFECT(arraySize));\r\n\r\n            /**\r\n             * Remove efect after : (as all setTimeouts start together in a loop)\r\n             * DELAY_BEFORE_COMPLETESORT_EFFECT (waiting time for showing effect)\r\n             * (TIME_BETWEEN_EACH_BAR_EFFECT * arraySize) ms (time taken for each effect)\r\n             * DELAY_AFTER_COMPLETESORT_EFFECT stop and display time for effect\r\n             */\r\n            setTimeout(() => {\r\n                // Iterating on each bar\r\n                console.log('now');\r\n                for (let barsIterator = 0; barsIterator < allBars.length; barsIterator++) {\r\n                    allBars[barsIterator].classList.remove('complete-sort-effect');\r\n                }\r\n            }, DELAY_BEFORE_COMPLETESORT_EFFECT(arraySize) + (TIME_BETWEEN_EACH_BAR_EFFECT(arraySize) * arraySize) + DELAY_AFTER_COMPLETESORT_EFFECT);\r\n            // },5000);\r\n        }\r\n    }\r\n\r\n    render() {\r\n\r\n        const { array, currentlyChecking, pivot, sortedArray, sortingRunStatus } = this.props;\r\n\r\n        const arraySize = array.length;\r\n        const barsDisplayAreaWidth = this.getBarsDisplayAreaWidth(arraySize);\r\n        const marginBetween = this.getMarginBetweenBars(arraySize);\r\n        const barWidth = this.getBarWidth(arraySize, barsDisplayAreaWidth, marginBetween);\r\n        const displayBarHeight = window.screen.width >= 500 && arraySize < 23 ? true : false;\r\n\r\n        this.giveSortingCompletedEffectWhenCompleted();\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"bars\" style={{ width: barsDisplayAreaWidth }}>\r\n                    {\r\n                        array.length > 0 && array.map((bar, idx) => {\r\n                            let backgroundColor = idx === pivot ? BAR_COLOUR_PIVOT : BAR__COLOUR_DEFAULT;\r\n                            backgroundColor = sortedArray.includes(idx) || sortingRunStatus === 'COMPLETED' ? BAR_COLOUR_SORTED : backgroundColor;\r\n                            backgroundColor = currentlyChecking.includes(idx) && sortingRunStatus !== 'COMPLETED' ? BAR_COLOUR_WHILE_CHECKING : backgroundColor;\r\n                            const barIdForHeightDisplay = 'bar' + idx;\r\n\r\n                            return (\r\n                                <div key={idx}>\r\n\r\n                                    {/* bar height display box */}\r\n                                    <div\r\n                                        id={barIdForHeightDisplay}\r\n                                        className=\"bar-height-display\"\r\n                                        hidden>\r\n                                        {bar}\r\n                                    </div>\r\n\r\n                                    {/* bar */}\r\n                                    <div\r\n                                        id={idx}\r\n                                        className=\"bar\"\r\n                                        style={{ width: barWidth, height: bar, backgroundColor: backgroundColor, marginLeft: marginBetween }}\r\n                                        onMouseOver={this.showBarHeight}\r\n                                        onMouseLeave={this.hideBarHeight}>\r\n                                        {displayBarHeight ? bar : ''}\r\n                                    </div>\r\n\r\n                                </div>\r\n                            );\r\n                        })\r\n                    }\r\n                </div >\r\n\r\n                <div className='base-block bg-dark text-center'></div>\r\n\r\n            </div >\r\n        )\r\n    }\r\n}\r\n\r\nexport default ArrayBars;","import ArrayBars from \"./ArrayBars.jsx\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const currentlyChecking = state.currentlyChecking;\r\n    const pivot = state.pivot;\r\n    const sortedArray = state.sortedArray;\r\n    const sortingRunStatus = state.sortingRunStatus;\r\n    return { array, algorithm, currentlyChecking, pivot, sortedArray, sortingRunStatus };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n})\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ArrayBars);","import React, { Component } from \"react\";\r\nimport { DEFAULT_ARRAY_SIZE, DEFAULT_SELECTED_SPEED, MAX_ARRAY_SIZE, MIN_ARRAY_SIZE, SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\nimport \"./ControlBar.css\";\r\n\r\nclass ControlBar extends Component {\r\n\r\n  /**\r\n   * Generates a new Array of given length\r\n   * @param {number} arraySize length for new Array\r\n   */\r\n  resetArray = (arraySize) => {\r\n    this.props.generateArray(arraySize);\r\n  }\r\n\r\n  /**\r\n   * Changes and generates a new array of selected length\r\n   * @param {event} event Event which trigerred the function\r\n   */\r\n  changeArraySize = (event) => {\r\n    this.resetArray(event.target.value);\r\n  }\r\n\r\n  /**\r\n   * Changes the algorithm \r\n   * @param {Object} selectedAlgo Selected algorithm object\r\n   */\r\n  changeAlgorithm = (selectedAlgo) => {\r\n    document.getElementById('dropdown-algo-selector').innerText = selectedAlgo.name;\r\n    this.props.changeAlgorithm(selectedAlgo);\r\n  }\r\n\r\n  /**\r\n  * Changes the algorithm \r\n  * @param {event} event Event which trigerred the function\r\n  */\r\n  changeSpeed = (event) => {\r\n    const selectedSpeed = (Number)(event.target.value);\r\n    this.props.changeSpeed(selectedSpeed);\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar inputs for \r\n   * Array and Algorithm slelection\r\n   */\r\n  disableArrayAlgorithmInputs = () => {\r\n    const buttonsToBeDisabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonDisablingIterator = 0; buttonDisablingIterator < buttonsToBeDisabled.length; buttonDisablingIterator++) {\r\n      buttonsToBeDisabled[buttonDisablingIterator].setAttribute('disabled', true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's input-label-texts on the control bar\r\n   */\r\n  disableArrayAlgorithmTexts = () => {\r\n    const textsToBeDisabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textDisablingIterator = 0; textDisablingIterator < textsToBeDisabled.length; textDisablingIterator++) {\r\n      textsToBeDisabled[textDisablingIterator].classList.remove('text-white');\r\n      textsToBeDisabled[textDisablingIterator].classList.add('text-muted');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables the control bar inputs for \r\n   * Array and Algorithm slelection\r\n   */\r\n  enableArrayAlgorithmInputs = () => {\r\n    const buttonsToBeEnabled = document.getElementsByClassName('input-disable-when-running');\r\n    for (let buttonEnablingIterator = 0; buttonEnablingIterator < buttonsToBeEnabled.length; buttonEnablingIterator++) {\r\n      buttonsToBeEnabled[buttonEnablingIterator].removeAttribute('disabled');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables the control bar's input-label-texts on the control bar\r\n   */\r\n  enableArrayAlgorithmTexts = () => {\r\n    const textsToBeEnabled = document.getElementsByClassName('text-disable-when-running');\r\n    for (let textEnablingIterator = 0; textEnablingIterator < textsToBeEnabled.length; textEnablingIterator++) {\r\n      textsToBeEnabled[textEnablingIterator].classList.remove('text-muted');\r\n      textsToBeEnabled[textEnablingIterator].classList.add('text-white');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hides start sort button on the control bar\r\n   */\r\n  hideStartSortingButton = () => {\r\n    const startSortingButton = document.getElementById('btn-sort');\r\n    startSortingButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows start sort button on the control bar\r\n   */\r\n  showStartSortingButton = () => {\r\n    const startSortingButton = document.getElementById('btn-sort');\r\n    startSortingButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Shows pause button on the control bar\r\n   */\r\n  showPauseButton = () => {\r\n    const pauseButton = document.getElementById('btn-pause');\r\n    pauseButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides pause button on the control bar\r\n   */\r\n  hidePauseButton = () => {\r\n    const pauseButton = document.getElementById('btn-pause');\r\n    pauseButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows continue button on the control bar\r\n   */\r\n  showContinueButton = () => {\r\n    const continueButton = document.getElementById('btn-continue');\r\n    continueButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides continue button on the control bar\r\n   */\r\n  hideContinueButton = () => {\r\n    const continueButton = document.getElementById('btn-continue');\r\n    continueButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Shows the stop sort button on the control bar\r\n   */\r\n  showStopSortinButton = () => {\r\n    const stopSortingButton = document.getElementById('btn-stop-sort');\r\n    stopSortingButton.removeAttribute('hidden');\r\n  }\r\n\r\n  /**\r\n   * Hides stop sort button on the control bar\r\n   */\r\n  hideStopSortingButton = () => {\r\n    const stopSortingButton = document.getElementById('btn-stop-sort');\r\n    stopSortingButton.setAttribute('hidden', true);\r\n  }\r\n\r\n  /**\r\n   * Disables Array and Algorithm related features\r\n   * and enables Sorting realted features\r\n   */\r\n  manageControlBarFeaturesWhenSortingStarts = () => {\r\n    this.disableArrayAlgorithmInputs();\r\n    this.disableArrayAlgorithmTexts();\r\n    this.hideStartSortingButton();\r\n    this.showPauseButton();\r\n    this.showStopSortinButton();\r\n  }\r\n\r\n  /**\r\n   * Enables Array and Algorithm related features\r\n   * and enables Sorting realted features\r\n   */\r\n  manageControlBarFeaturesWhenSortingStops = () => {\r\n    this.enableArrayAlgorithmInputs();\r\n    this.enableArrayAlgorithmTexts();\r\n    this.hidePauseButton();\r\n    this.hideContinueButton();\r\n    this.hideStopSortingButton();\r\n    this.showStartSortingButton();\r\n  }\r\n\r\n  /**\r\n   * Disables the control bar's feature \r\n   * and starts sorting\r\n   */\r\n  startSorting = () => {\r\n    this.manageControlBarFeaturesWhenSortingStarts();\r\n    this.props.startSorting();\r\n  }\r\n\r\n  /**\r\n   * Pauses the sorting\r\n   */\r\n  pauseSorting = () => {\r\n    this.props.pauseSorting();\r\n    this.hidePauseButton();\r\n    this.showContinueButton();\r\n  }\r\n\r\n  /**\r\n   * Continues the paused sorting process\r\n   */\r\n  continueSorting = () => {\r\n    this.hideContinueButton();\r\n    this.showPauseButton();\r\n    this.props.continueSorting();\r\n  }\r\n\r\n  /**\r\n   * Stops the current storting process\r\n   */\r\n  stopSorting = () => {\r\n    this.manageControlBarFeaturesWhenSortingStops();\r\n    this.props.stopSorting();\r\n  }\r\n\r\n  /**\r\n   * Checks if sorting is completed\r\n   * and calls the required control\r\n   * bar manager functions\r\n   */\r\n  handleIfSortingCompleted = () => {\r\n    this.props.sortingRunStatus === 'COMPLETED' && this.manageControlBarFeaturesWhenSortingStops();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetArray(DEFAULT_ARRAY_SIZE);\r\n  }\r\n\r\n\r\n  render() {\r\n    const { array, algorithms, defaultAlgorithm } = this.props;\r\n    const arraySize = array.length;\r\n\r\n    this.handleIfSortingCompleted();\r\n\r\n    return (\r\n      <div className='nav navbar navbar-dark bg-dark text-center pt-2 pb-2'>\r\n        <div className='navbar navbar-brand col-sm-12 col-md-6 col-lg-4 text-center m-0 p-0'>\r\n          <h2>SORTING VISUALIZER</h2>\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-6 col-lg-3 m-0 p-0\">\r\n          <button className='btn btn-white btn-round mt-1 mb-1 mr-2 input-disable-when-running  array-algo-button'\r\n            onClick={() => { this.resetArray(arraySize) }}>\r\n            Generate New Array\r\n          </button>\r\n\r\n          <div className=\"btn-group array-algo-button\">\r\n            <button\r\n              type=\"button\"\r\n              id=\"dropdown-algo-selector\"\r\n              className=\"btn btn-success dropdown-toggle input-disable-when-running col-12\"\r\n              data-toggle=\"dropdown\"\r\n              aria-haspopup=\"true\"\r\n              aria-expanded=\"false\">\r\n              {defaultAlgorithm.name}\r\n            </button>\r\n            <div className=\"dropdown-menu\">\r\n              <h1 className=\"dropdown-header text-large\">Select Algorithm</h1>\r\n              {\r\n                algorithms.map((this_algorithm) => {\r\n                  return (\r\n                    <div key={this_algorithm.id}>\r\n                      <div className=\"dropdown-divider\"></div>\r\n                      <button className=\"dropdown-item\"\r\n                        onClick={() => this.changeAlgorithm(this_algorithm)}>\r\n                        {this_algorithm.name}\r\n                      </button>\r\n                    </div>\r\n                  );\r\n                })\r\n              }\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className='col-md-12 col-lg-3 row slider-controls text-justify-end'>\r\n          <div className='text-white text-center text-disable-when-running text-slider slider-controls col-sm-4 col-md-6 col-lg-6 mt-1 mb-1'>\r\n            Array Size :\r\n          </div>\r\n          <input\r\n            className='input-disable-when-running text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6 mt-1 mb-1'\r\n            type=\"range\"\r\n            min={MIN_ARRAY_SIZE}\r\n            max={MAX_ARRAY_SIZE}\r\n            defaultValue={DEFAULT_ARRAY_SIZE}\r\n            onChange={this.changeArraySize}\r\n          />\r\n          <div className='text-white text-center text-slider slider-controls col-sm-4 col-md-6 col-lg-6 mb-1'>\r\n            Sorting Speed :\r\n          </div>\r\n          <input\r\n            className='text-center slider-controls slider-range col-sm-7 col-md-6 col-lg-6 mb-1'\r\n            type=\"range\"\r\n            min=\"1\"\r\n            max={SORTING_SPEED_UPPER_LIMIT}\r\n            defaultValue={DEFAULT_SELECTED_SPEED}\r\n            onChange={this.changeSpeed}\r\n          />\r\n        </div>\r\n\r\n        <div className=\"col-sm-12 col-md-12 col-lg-2 text-center mt-1 mb-1\">\r\n          <button\r\n            id=\"btn-sort\"\r\n            className=\"btn btn-success\"\r\n            onClick={this.startSorting}>\r\n            START SORTING\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-pause\"\r\n            className=\"btn btn-default btn-when-running mr-1\"\r\n            onClick={this.pauseSorting}\r\n            hidden>\r\n            Pause\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-continue\"\r\n            className=\"btn btn-default btn-when-running mr-1\"\r\n            onClick={this.continueSorting}\r\n            hidden>Continue\r\n          </button>\r\n\r\n          <button\r\n            id=\"btn-stop-sort\"\r\n            className=\"btn btn-danger btn-when-running\"\r\n            onClick={this.stopSorting}\r\n            hidden>\r\n            Stop\r\n          </button>\r\n\r\n        </div>\r\n\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default ControlBar;","import { DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults\";\r\n\r\nlet initialState = {\r\n    id: DEFAULT_SELECTED_ALGORITHM_ID\r\n}\r\n\r\nexport const algorithm = (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case 'SET_ALGORITHM':\r\n            return action.payload;\r\n        default: return state;\r\n    }\r\n}","function checkIfIndexOutOfBounds(index, arraySize) {\r\n    if (index < 0 || index >= arraySize) {\r\n        console.error(index + \" passed for swapping is out of bounds for \" + arraySize + \", can't swap values.\");\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Swaps the values in given array\r\n * @param {Array} array Array whose values need to be swapped \r\n * @param {number} firstIdx first index\r\n * @param {number} secondIdx second index\r\n */\r\nexport function swapValuesInArray(array, firstIdx, secondIdx) {\r\n\r\n    const arraySize = array.length;\r\n\r\n    // first and second index both should be in range 0 to (arraySize - 1)\r\n    if (checkIfIndexOutOfBounds(firstIdx, arraySize) || checkIfIndexOutOfBounds(secondIdx, arraySize)) {\r\n        return array;\r\n    }\r\n\r\n    let temp = array[firstIdx];\r\n    array[firstIdx] = array[secondIdx];\r\n    array[secondIdx] = temp;\r\n\r\n    return array;\r\n}","/**\r\n * Returns the array with value inserted at given index\r\n * @param {Array} array Array in which value needs to be inserted\r\n * @param {Number} index Index at wich value gets inserted\r\n * @param {Number} replaceCounter Number of indices to replace after given index by the given value\r\n * @param {*} value Value which is to be inserted\r\n * @returns Array with value inserted at index \r\n */\r\nexport function setValueInArrayUsingSplice(array, index, replaceCounter, value) {\r\n    array.splice(index, replaceCounter, value);\r\n    return array;\r\n}","import { setValueInArrayUsingSplice, swapValuesInArray } from \"../utilities\";\r\n\r\nexport const array = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_ARRAY':\r\n            return action.payload;\r\n        case 'SWAP_VALUES':\r\n            return swapValuesInArray(state, action.payload.firstIdx, action.payload.secondIdx);\r\n        case 'SET_VALUE':\r\n            return setValueInArrayUsingSplice(state, action.payload.id, 1, action.payload.data);\r\n        default: return state;\r\n    }\r\n}","import { combineReducers } from \"redux\";\r\nimport { algorithm } from \"./algorithmRedcuer\";\r\nimport { array } from \"./arrayReducer\";\r\nimport { currentlyChecking } from \"./currenltyCheckingReducer\";\r\nimport { speed } from \"./speedReducer\";\r\nimport { pivot } from \"./pivotReducer\";\r\nimport { sortedArray } from \"./sortedArrayReducer\";\r\nimport { sortingRunStatus } from \"./sortingRunStatus\";\r\n\r\nconst rootReducer = combineReducers({\r\n    array,\r\n    algorithm,\r\n    speed,\r\n    currentlyChecking,\r\n    pivot,\r\n    sortedArray,\r\n    sortingRunStatus,\r\n});\r\n\r\nexport default rootReducer;","import { DEFAULT_SELECTED_SPEED } from \"../../defaults\";\r\n\r\nexport const speed = (state = DEFAULT_SELECTED_SPEED, action) => {\r\n    switch (action.type) {\r\n        case 'SET_SPEED':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","/**\r\n * It denotes the array of indices currently \r\n * being checked by the algorithm for sorting\r\n */\r\nexport const currentlyChecking = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_CURRENTLYCHECKING':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const pivot = (state = -1, action) => {\r\n    switch (action.type) {\r\n        case 'SET_PIVOT':\r\n            return action.payload;\r\n\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortedArray = (state = [], action) => {\r\n    switch (action.type) {\r\n        case 'SET_SORTEDARRAY':\r\n            return action.payload;\r\n        case 'ADD_TO_SORTEDARRAY':\r\n            return state.concat(action.payload);\r\n        default: return state;\r\n    }\r\n}","\r\nexport const sortingRunStatus = (state = 'NOT_RUNNING', action) => {\r\n    switch (action.type) {\r\n        case 'STARTED':\r\n            return 'STARTED';\r\n        case 'CONTINUED':\r\n            return 'CONTINUED';\r\n        case 'PAUSED':\r\n            return 'PAUSED';\r\n        case 'STOPPED':\r\n            return 'STOPPED';\r\n        case 'COMPLETED':\r\n            return 'COMPLETED';\r\n        case 'REFRESH':\r\n            return 'NOT_RUNNING';\r\n\r\n        default: return state;\r\n    }\r\n}","import rootReducer from \"../reducers\";\r\nimport { createStore } from \"redux\";\r\n\r\nexport const store = createStore(\r\n    rootReducer,\r\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\r\n);","export const setArray = (payload) => {\r\n    return {\r\n        type: 'SET_ARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * Swaps the value at firstIdx with secondIdx \r\n * in store's state Array\r\n * @param {number} firstIdx first index\r\n * @param {number} secondIdx second index\r\n */\r\nexport const swapValues = (firstIdx, secondIdx) => {\r\n    return {\r\n        type: 'SWAP_VALUES',\r\n        payload: {\r\n            firstIdx: firstIdx,\r\n            secondIdx: secondIdx\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sets value at specific index in store's State Array\r\n * @param {number} index Index at which value needs to be stored,\r\n * @param {*} value The value which needs to be inserted\r\n * @returns An action object with type and payload\r\n */\r\nexport const setValue = (index, value) => {\r\n    return {\r\n        type: 'SET_VALUE',\r\n        payload: {\r\n            id: index,\r\n            data: value\r\n        }\r\n    }\r\n}\r\n","export const setCurrentlyChecking = (payload) => {\r\n    return {\r\n        type: 'SET_CURRENTLYCHECKING',\r\n        payload: payload\r\n    }\r\n};\r\n","/**\r\n * Sets the sort array as provided array\r\n * @param {Array} payload takes an array to best set as sortedArray\r\n */\r\nexport const setSortedArray = (payload) => {\r\n    return {\r\n        type: 'SET_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n\r\n/**\r\n * Adds the given element to sortedArray\r\n * @param {*} payload element to be added in sortedArray\r\n */\r\nexport const addToSortedArray = (payload) => {\r\n    return {\r\n        type: 'ADD_TO_SORTEDARRAY',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\"\r\n\r\n/**\r\n * Returns the sortingRunStatus in store's state\r\n * @returns sortingRunStatus\r\n */\r\nfunction getCurrentSortingRunStatus() {\r\n    // Gets the current state object in store\r\n    const state = store.getState();\r\n\r\n    // Gets the sortingRunStatus from state object\r\n    const status = state.sortingRunStatus;\r\n    return status;\r\n}\r\n\r\nexport default getCurrentSortingRunStatus;","import getCurrentSortingRunStatus from \"./getSortingRunStatus\";\r\n\r\nasync function checkCurrentSortingRunStatus() {\r\n    if (getCurrentSortingRunStatus() === 'PAUSED') {\r\n        return new Promise((resolve, reject) => {\r\n            setInterval(() => {\r\n                if (getCurrentSortingRunStatus() === 'CONTINUED')\r\n                    resolve();\r\n                else if (getCurrentSortingRunStatus() === 'STOPPED')\r\n                    reject();\r\n            }, 10);\r\n\r\n        });\r\n    } else if (getCurrentSortingRunStatus() === 'STOPPED') {\r\n        return new Promise((resolve, reject) => reject());\r\n    } else {\r\n        return new Promise(resolve => resolve());\r\n    }\r\n}\r\n\r\nexport default checkCurrentSortingRunStatus;","import { store } from \"../../store\";\r\nimport { SORTING_SPEED_UPPER_LIMIT } from \"../../defaults\";\r\n\r\n/**\r\n * @returns the timedelay between each step,\r\n *          so if speed is 10 and speed range is 0-100\r\n *          timedelay will be of 90ms\r\n */\r\nfunction getTimeDelay() {\r\n    const state = store.getState();\r\n    const speed = state.speed;\r\n    return SORTING_SPEED_UPPER_LIMIT - speed;\r\n}\r\n\r\nexport default getTimeDelay;","import getTimeDelay from \"./getTimeDelay\";\r\n\r\nasync function sleep() {\r\n    await new Promise((resolve) => {\r\n        setTimeout(() => resolve(), getTimeDelay());\r\n    });\r\n}\r\n\r\nexport default sleep;","import checkCurrentSortingRunStatus from \"./checkCurrentStatus\";\r\nimport sleep from \"./sleep\";\r\n\r\n/**\r\n * Checks if not paused or stopped and moves when after delay time\r\n * @returns True for continuing, False for stopping\r\n */\r\nasync function continueAfterDelayIfNotStopped() {\r\n\r\n    // Checking if Paused or Stopped\r\n    let checkFurther = await checkCurrentSortingRunStatus()\r\n        .then(() => true)\r\n        .catch(() => false);\r\n    if (!checkFurther)\r\n        return false;\r\n\r\n    // Delaying accroding to selected speed\r\n    await sleep();\r\n\r\n    // Checking if Paused or Stopped\r\n    let finalCheckResult = await checkCurrentSortingRunStatus()\r\n        .then(() => true)\r\n        .catch(() => false);\r\n\r\n    return finalCheckResult;\r\n}\r\n\r\nexport default continueAfterDelayIfNotStopped;","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \".././helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * BUBBLE SORT : \r\n * \r\n * Bubble Sort is the simplest sorting algorithm that works by repeatedly \r\n * swapping the adjacent elements if they are in wrong order.\r\n * \r\n * It works on the principle of keeping the heaviest element(or bubble)\r\n * at last position in each iteration and working on remaining in next.\r\n */\r\n\r\n/**\r\n * Performs Bubble Sort on the store's Array\r\n */\r\nasync function bubbleSort() {\r\n\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // Bubble Sort Algorithm \r\n\r\n    // Outer loop\r\n    for (let outerLoopIterator = 0; outerLoopIterator < arraySize - 1; outerLoopIterator++) {\r\n        let innerLoopIterator = 0;\r\n\r\n        //Inner loop\r\n        for (innerLoopIterator = 0; innerLoopIterator < arraySize - outerLoopIterator - 1; innerLoopIterator++) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            // Setting the current indices which are being checked to currentlyChecking\r\n            store.dispatch(setCurrentlyChecking([innerLoopIterator, innerLoopIterator + 1]));\r\n\r\n            if (localArray[innerLoopIterator] > localArray[innerLoopIterator + 1]) {\r\n\r\n                // Check if stopped or paused - delay accoring to selected speed - again check\r\n                continueSort = await continueAfterDelayIfNotStopped();\r\n                // Return if stopped\r\n                if (!continueSort)\r\n                    return;\r\n\r\n                // Swaps the values in store's state Array\r\n                store.dispatch(swapValues(innerLoopIterator, innerLoopIterator + 1));\r\n            }\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n        }\r\n\r\n        // Adding the 'j' which has been sorted to sortedArray\r\n        store.dispatch(addToSortedArray(innerLoopIterator));\r\n    }\r\n\r\n    // Removing the first bar as currentlyChecking\r\n    store.dispatch(setCurrentlyChecking([]));\r\n\r\n    // First bar needs to be marked explicitly as \r\n    // it doesn't go inside inner loop\r\n    store.dispatch(addToSortedArray(0));\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default bubbleSort;","export const sortingStarted = () => {\r\n    return {\r\n        type: 'STARTED'\r\n    }\r\n};\r\n\r\nexport const sortingContinued = () => {\r\n    return {\r\n        type: 'CONTINUED'\r\n    }\r\n};\r\n\r\nexport const sortingPaused = () => {\r\n    return {\r\n        type: 'PAUSED'\r\n    }\r\n};\r\n\r\nexport const sortingStopped = () => {\r\n    return {\r\n        type: 'STOPPED'\r\n    }\r\n};\r\n\r\nexport const sortingCompleted = () => {\r\n    return {\r\n        type: 'COMPLETED'\r\n    }\r\n}\r\n\r\nexport const sortingRefresh = () => {\r\n    return {\r\n        type: 'REFRESH'\r\n    }\r\n}","import { setValue } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { setSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport { store } from \"../../store\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\nimport sleep from \"../helpers/sleep\";\r\n\r\n/**\r\n * MERGE_SORT (arr[] , l, r)\r\n * \r\n *   If r > l\r\n *      1. Find the middle point to divide the array into two halves:\r\n *          middle m = l + (r - l) / 2\r\n *      2. Call mergeSort for first half:\r\n *          Call mergeSort(arr, l, m)\r\n *      3. Call mergeSort for second half:\r\n *          Call mergeSort(arr, m + 1, r)\r\n *      4. Merge the two halves sorted in step 2 and 3:\r\n *          Call merge(arr, l, m, r)\r\n */\r\n\r\n/**\r\n * Merges two subarrays of localArray[].\r\n * First subarray is localArray[l..m]\r\n * Second subarray is localArray[m+1..r]\r\n * @param {*} localArray Original Array \r\n * @param {*} leftIdx Starting index for first subarray\r\n * @param {*} midxIdx Ending Index (inclusive) for first subarray\r\n * @param {*} rightIdx Ending Index (inclusive) for second subarray \r\n *                      which start from midIdx + 1\r\n */\r\nasync function merge(localArray, leftIdx, midIdx, rightIdx) {\r\n\r\n    // Sizes of two subarray\r\n    var n1 = midIdx - leftIdx + 1;\r\n    var n2 = rightIdx - midIdx;\r\n\r\n    // Creating temp arrays\r\n    var leftLocalArray = new Array(n1);\r\n    var rightLocalArray = new Array(n2);\r\n\r\n    // Copy data to temp arrays\r\n    for (let i = 0; i < n1; i++)\r\n        leftLocalArray[i] = localArray[[leftIdx + i]];\r\n    for (let j = 0; j < n2; j++)\r\n        rightLocalArray[j] = localArray[midIdx + 1 + j];\r\n\r\n    /**\r\n     *  ..................................................\r\n     *\r\n     *  MERGING THE TEMP ARRAYS BACK INTO localArray[l..r]\r\n     * (Using Merge-K-Sorted-LinkedLists Algorithm)\r\n     * \r\n     *  ..................................................\r\n     */\r\n\r\n    // Initial index of first subarray\r\n    let i = 0;\r\n\r\n    // Initial index of second subarray\r\n    let j = 0;\r\n\r\n    // Initial index of merged subarray\r\n    let k = leftIdx;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    while (i < n1 && j < n2) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * i : leftIdx + 1, j : midIdx + j + 1 because : \r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([leftIdx + i, midIdx + j + 1]));\r\n\r\n        if (leftLocalArray[i] <= rightLocalArray[j]) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            store.dispatch(setValue(k, leftLocalArray[i]));\r\n\r\n            i++;\r\n        }\r\n        else {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            store.dispatch(setValue(k, rightLocalArray[j]));\r\n\r\n            j++;\r\n        }\r\n\r\n        k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // leftLocalArray[], if there are any\r\n    while (i < n1) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Delays according to selected speed\r\n        await sleep();\r\n\r\n        /**\r\n         * i : leftIdx + 1 because : \r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([leftIdx + i]));\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        store.dispatch(setValue(k, leftLocalArray[i]));\r\n\r\n        i++;\r\n        k++;\r\n    }\r\n\r\n    // Copy the remaining elements of\r\n    // rightLocalArrau[], if there are any\r\n    while (j < n2) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * j : midIdx + j + 1 because : \r\n         * they are indices of left and right copy array\r\n         */\r\n        store.dispatch(setCurrentlyChecking([midIdx + j + 1]));\r\n\r\n        // Delays according to selected speed\r\n        await sleep();\r\n\r\n        store.dispatch(setValue(k, rightLocalArray[j]));\r\n\r\n        j++;\r\n        k++;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Sorts the array from leftIdx to rightIdx using MergeSort Algorithm\r\n * @param {*} localArray Original Array whose subarray is to be sorted\r\n * @param {*} leftIdx Starting index of subarray\r\n * @param {*} rightIdx Ending Index (inclusive) of subarray \r\n */\r\nasync function mergeSortRecursive(localArray, leftIdx, rightIdx) {\r\n    if (leftIdx >= rightIdx) {\r\n        return;//returns recursively\r\n    }\r\n\r\n    /**\r\n     * Middle index\r\n     */\r\n    const midIdx = leftIdx + parseInt((rightIdx - leftIdx) / 2);\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = await checkCurrentSortingRunStatus()\r\n        .then(async () => {\r\n            await mergeSortRecursive(localArray, leftIdx, midIdx)\r\n            await mergeSortRecursive(localArray, midIdx + 1, rightIdx);\r\n            await merge(localArray, leftIdx, midIdx, rightIdx);\r\n            return true;\r\n        })\r\n        .catch(() => false);\r\n\r\n    // Aborting and returing if Stopped\r\n    if (!continueSort)\r\n        return;\r\n}\r\n\r\n/**\r\n * Perform Merge Sort on the store's Array\r\n */\r\nasync function mergeSort() {\r\n\r\n    /** \r\n      * Gets current state object\r\n      */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    // Performing merge sort on the array\r\n    await mergeSortRecursive(localArray, 0, arraySize - 1);\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default mergeSort;","export const setPivot = (payload) => {\r\n    return {\r\n        type: 'SET_PIVOT',\r\n        payload: payload\r\n    }\r\n};\r\n","import { store } from \"../../store\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray, setSortedArray } from \"../../actions/sortedArray\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setPivot } from \"../../actions/pivot\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\n\r\n/**\r\n * QUICK SORT : \r\n * \r\n * QuickSort is a Divide and Conquer algorithm. It picks an element as pivot \r\n * and partitions the given array around the picked pivot.\r\n * \r\n * The key process in quickSort is partition(). Target of partitions is, given \r\n * an array and an element x of array as pivot, put x at its correct position \r\n * in sorted array and put all smaller elements (smaller than x) before x, and \r\n * put all greater elements (greater than x) after x. All this should be done \r\n * in linear time. \r\n * \r\n */\r\n\r\n/**\r\n * \r\n * @param {Array} localArray Copy of the array on which we want to we want to perform Quick Sort\r\n * @param {number} startIdx Starting index \r\n * @param {number} endIdx Ending index \r\n * @returns Pivot index\r\n */\r\nasync function partition(localArray, startIdx, endIdx) {\r\n\r\n    // Taking the last element as the pivot\r\n    /**\r\n     * Value at selected(last element) pivot\r\n     */\r\n    const pivotValue = localArray[endIdx];\r\n    store.dispatch(setPivot(endIdx));\r\n\r\n    /**\r\n     * Shows uptill where the value is smaller than pivotValue\r\n     */\r\n    let pivotIdx = startIdx;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    for (let idx = startIdx; idx < endIdx; idx++) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * Shows the indices of the first and second \r\n         * which are being compared currently\r\n         */\r\n        store.dispatch(setCurrentlyChecking([idx, pivotIdx]));\r\n\r\n        if (localArray[idx] <= pivotValue) {\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            // Swapping the value\r\n            store.dispatch(swapValues(idx, pivotIdx));\r\n\r\n            // Moving to next element\r\n            pivotIdx++;\r\n        }\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        /**\r\n         * Removing the marking on indices\r\n         */\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n\r\n    // Check if stopped or paused - delay accoring to selected speed - again check\r\n    continueSort = await continueAfterDelayIfNotStopped();\r\n    // Return if stopped\r\n    if (!continueSort)\r\n        return;\r\n\r\n    // Putting the pivot value in the middle\r\n    store.dispatch(swapValues(endIdx, pivotIdx));\r\n\r\n    return pivotIdx;\r\n};\r\n\r\nasync function quickSortRecursive(localArray, startIdx, endIdx) {\r\n    // Base case or terminating case\r\n    if (startIdx >= endIdx) {\r\n        return;\r\n    }\r\n\r\n    // Returns pivotIndex\r\n    const pivotIdx = await partition(localArray, startIdx, endIdx);\r\n\r\n    store.dispatch(addToSortedArray(pivotIdx));\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = await checkCurrentSortingRunStatus()\r\n        .then(async () => {\r\n            // Recursively apply the same logic to the left and right subarrays\r\n            store.dispatch(addToSortedArray(pivotIdx));\r\n            await quickSortRecursive(localArray, startIdx, pivotIdx - 1);\r\n            // Marking first index for this part as sorted\r\n            store.dispatch(addToSortedArray(startIdx));\r\n            await quickSortRecursive(localArray, pivotIdx + 1, endIdx);\r\n            // Marking first index for this part as sorted\r\n            store.dispatch(addToSortedArray(pivotIdx + 1));\r\n        })\r\n        .catch(() => false);\r\n    // Aborting and returing if Stopped\r\n    if (!continueSort)\r\n        return;\r\n}\r\n\r\n/**\r\n * Performs quick sort on the store's state array\r\n */\r\nasync function quickSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    // Performing quick sort on the array\r\n    await quickSortRecursive(localArray, 0, arraySize - 1);\r\n\r\n    // Remove the pivot regardless of whether sort was completed or stoped\r\n    store.dispatch(setPivot(null));\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default quickSort;","import { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray, setSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport { store } from \"../../store\";\r\nimport checkCurrentSortingRunStatus from \"../helpers/checkCurrentStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n\r\n/**\r\n * Since a Binary Heap is a Complete Binary Tree, it can be easily represented\r\n * as an array and the array-based representation is space-efficient.\r\n * If the parent node is stored at index I, the left child can be\r\n * calculated by 2 * I + 1 and the right child by 2 * I + 2\r\n * (assuming the indexing starts at 0).\r\n */\r\n\r\n/**\r\n * HEAP SORT Algorithm for sorting in increasing order:\r\n *  1. Build a max heap from the input data.\r\n *  2. At this point, the largest item is stored at the root of the heap.\r\n *     Replace it with the last item of the heap followed by reducing the\r\n *     size of heap by one. Finally, heapify the root of the tree.\r\n *  3. Repeat step 2 while the size of the heap is greater than 1.\r\n */\r\n\r\n/**\r\n * Heapifies a subtree rooted with node i which is\r\n * an index in localArray. arraySize is size of heap\r\n * @param {Array} localArray An array which represents heap\r\n * @param {Number} nodeIndex An index which represents root node of the subtree\r\n * @param {Number} arraySize Size of the heap array\r\n */\r\nasync function heapify(localArray, nodeIndex, arraySize) {\r\n    let largest = nodeIndex; // Initialize largest as root\r\n    const left = 2 * nodeIndex + 1; // left = 2*i + 1\r\n    const right = 2 * nodeIndex + 2; // right = 2*i + 2\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // If left child is larger than root\r\n    if (left < arraySize && localArray[left] > localArray[largest])\r\n        largest = left;\r\n\r\n    // If right child is larger than largest so far\r\n    if (right < arraySize && localArray[right] > localArray[largest])\r\n        largest = right;\r\n\r\n\r\n    // Check if stopped or paused - delay accoring to selected speed - again check\r\n    continueSort = await continueAfterDelayIfNotStopped();\r\n    // Return if stopped\r\n    if (!continueSort)\r\n        return;\r\n\r\n    /**\r\n     * left and right are being currently checked and also\r\n     * need to check to make sure currently checking doesn't \r\n     * show more than current heap size\r\n     */\r\n    store.dispatch(setCurrentlyChecking([largest, nodeIndex]));\r\n\r\n    // If largest is not root\r\n    if (largest !== nodeIndex) {\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Swaps the values in store's state Array\r\n        store.dispatch(swapValues(largest, nodeIndex));\r\n\r\n        // Recursively heapify the affected sub-tree\r\n        await heapify(localArray, largest, arraySize);\r\n    }\r\n}\r\n/**\r\n * Helpeer function for implementing heap sort on localArray\r\n * @param {Array} localArray An array which represents heap\r\n */\r\nasync function HeapSort(localArray) {\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = localArray.length;\r\n\r\n    // Build heap (rearrange localArray)\r\n    for (let nodeIndex = Math.floor(arraySize / 2) - 1; nodeIndex >= 0; nodeIndex--) {\r\n        /**\r\n         * Aborts the sort if value is false\r\n         */\r\n        let continueSort = await checkCurrentSortingRunStatus()\r\n            .then(async () => {\r\n                await heapify(localArray, nodeIndex, arraySize);\r\n                return true;\r\n            })\r\n            .catch(() => false);\r\n        // Aborting and returing if Stopped\r\n        if (!continueSort)\r\n            return;\r\n    }\r\n\r\n    // One by one extract an element from heap\r\n    for (let extractElementIterator = arraySize - 1; extractElementIterator > 0; extractElementIterator--) {\r\n\r\n        /**\r\n         * Aborts the sort if value is false\r\n         */\r\n        let continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Move current root to end\r\n        store.dispatch(swapValues(0, extractElementIterator));\r\n\r\n\r\n        // Emptying the currently checking array to prevent having a single bar as marked each time\r\n        store.dispatch(setCurrentlyChecking([]));\r\n\r\n        // Add the last moved bar to sorted Array\r\n        store.dispatch(addToSortedArray(extractElementIterator));\r\n\r\n        // Call max heapify on the reduced heap\r\n        continueSort = await checkCurrentSortingRunStatus()\r\n            .then(async () => {\r\n                await heapify(localArray, 0, extractElementIterator);\r\n                return true;\r\n            })\r\n            .catch(() => false);\r\n        // Aborting and returing if Stopped\r\n        if (!continueSort)\r\n            return;\r\n    }\r\n}\r\n\r\n/**\r\n * Performs Heap Sort on the store's Array\r\n */\r\nasync function heapSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    // We perform the Heap Sort on store's state array\r\n    await HeapSort(localArray);\r\n\r\n    /**\r\n     * After sorting sets the Sorting Running Status to COMPLETED\r\n     * it will automatically check and make them sorted colour\r\n     * \r\n     * Also check if sort was not stopped\r\n     */\r\n    let sortAborted = await checkCurrentSortingRunStatus()\r\n        .then(() => false)\r\n        .catch(() => true);\r\n\r\n    // If sort was stopped then empty the currentlyChecking and sortedArray\r\n    if (sortAborted) {\r\n        store.dispatch(setSortedArray([]));\r\n        store.dispatch(setCurrentlyChecking([]));\r\n    }\r\n    // Else sort was not aborted then mark sort as COMPLETED\r\n    else\r\n        store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default heapSort;","import { store } from \"../../store\";\r\nimport { swapValues } from \"../../actions/array\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking\";\r\nimport { addToSortedArray } from \"../../actions/sortedArray\";\r\nimport { sortingCompleted } from \"../../actions/sortingRunStatus\";\r\nimport continueAfterDelayIfNotStopped from \"../helpers/continueAfterDelayIfNotStopped\";\r\n\r\n/**\r\n * INSERTION SORT : \r\n * \r\n * Insertion sort is a simple sorting algorithm that works similar to the way \r\n * you sort playing cards in your hands. The array is virtually split into a \r\n * sorted and an unsorted part. Values from the unsorted part are picked and \r\n * placed at the correct position in the sorted part.\r\n * \r\n */\r\n\r\n/**\r\n * Performs insertion sort on the store's state array\r\n */\r\nasync function insertionSort() {\r\n\r\n    /** \r\n     * Gets current state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /** \r\n     * Store's state Array\r\n     */\r\n    const localArray = state.array;\r\n\r\n    /**\r\n     * length of array\r\n     */\r\n    const arraySize = state.array.length;\r\n\r\n    /**\r\n     * Aborts the sort if value is false\r\n     */\r\n    let continueSort = true;\r\n\r\n    // Insetion Sort Algorithm\r\n\r\n    for (let iterator = 0; iterator < arraySize; iterator++) {\r\n        /**\r\n         * Backward moving iterator for current element\r\n         */\r\n        let backwardIterator = iterator;\r\n\r\n        // Check if stopped or paused - delay accoring to selected speed - again check\r\n        continueSort = await continueAfterDelayIfNotStopped();\r\n        // Return if stopped\r\n        if (!continueSort)\r\n            return;\r\n\r\n        // Current element is marked\r\n        store.dispatch(setCurrentlyChecking([backwardIterator]));\r\n\r\n        /**\r\n         * Adding the current element's index to sortedArray as\r\n         * all array including this position is sorted\r\n         */\r\n        store.dispatch(addToSortedArray(iterator));\r\n\r\n        /**\r\n         * Keep swpping the current element with previous \r\n         * elements untill it reaches the correct position\r\n         * i.e. previous element is smaller or equal to it\r\n         */\r\n        while (backwardIterator > 0 && localArray[backwardIterator - 1] > localArray[backwardIterator]) {\r\n\r\n            // Check if stopped or paused - delay accoring to selected speed - again check\r\n            continueSort = await continueAfterDelayIfNotStopped();\r\n            // Return if stopped\r\n            if (!continueSort)\r\n                return;\r\n\r\n            /**\r\n             * Swapping the currentElement with \r\n             * previous element as it is bigger\r\n             */\r\n            store.dispatch(swapValues(backwardIterator - 1, backwardIterator));\r\n\r\n            // Current element is marked as it has now moved to one previous postition\r\n            store.dispatch(setCurrentlyChecking([backwardIterator - 1]));\r\n\r\n            backwardIterator--;\r\n        }\r\n    }\r\n\r\n    // After sorting sets the Sorting Running Status to COMPLETED\r\n    store.dispatch(sortingCompleted());\r\n}\r\n\r\nexport default insertionSort;\r\n","import bubbleSort from \"./allAlgorithms/bubbleSort\";\r\nimport mergeSort from \"./allAlgorithms/mergeSort\";\r\nimport quickSort from \"./allAlgorithms/quickSort\";\r\nimport heapSort from \"./allAlgorithms/heapSort\";\r\nimport insertionSort from \"./allAlgorithms/insertionSort\";\r\n\r\n/**\r\n * An array of objects where each \r\n * object is a sorting algorithm\r\n */\r\nconst ALGORITHMS = [\r\n    {\r\n        id: 0,\r\n        name: 'Merge Sort',\r\n        value: 'MERGE_SORT',\r\n        function: mergeSort\r\n    },\r\n    {\r\n        id: 1,\r\n        name: 'Bubble Sort',\r\n        value: 'BUBBLE_SORT',\r\n        function: bubbleSort\r\n    },\r\n    {\r\n        id: 2,\r\n        name: 'Heap Sort',\r\n        value: 'HEAP_SORT',\r\n        function: heapSort\r\n    },\r\n    {\r\n        id: 3,\r\n        name: 'Insertion Sort',\r\n        value: 'INSERTION_SORT',\r\n        function: insertionSort\r\n    },\r\n    {\r\n        id: 4,\r\n        name: 'Quick Sort',\r\n        value: 'QUICK_SORT',\r\n        function: quickSort\r\n    },\r\n    {\r\n        id: 5,\r\n        name: 'Selection Sort',\r\n        value: 'SELECTION_SORT',\r\n        // function: ()\r\n    }\r\n]\r\n\r\nexport default ALGORITHMS;","import ALGORITHMS from \"./ALGORITHMS\";\r\n\r\n/**\r\n * Return algorithm object of specified Id\r\n * @param {*} algorithmId Algorithm Id\r\n * @returns Algorithm object\r\n */\r\nfunction getAlgorithmById(algorithmId) {\r\n\r\n    // If valid algorithm is selected, return its object\r\n    for (let algorithmsIterator = 0; algorithmsIterator < ALGORITHMS.length; algorithmsIterator++) {\r\n        if (ALGORITHMS[algorithmsIterator].id === algorithmId) {\r\n            return ALGORITHMS[algorithmsIterator];\r\n        }\r\n    }\r\n\r\n    // If algorithm Id doesn't match with any present Ids\r\n    console.log('No matching algorithm found with Id : \"' + algorithmId + '\"');\r\n    return {};\r\n}\r\n\r\nexport default getAlgorithmById;","import { store } from \"../store\";\r\nimport { sortingStarted } from \"../actions/sortingRunStatus\";\r\nimport ALGORITHMS from \"./ALGORITHMS\";\r\nimport getAlgorithmById from \"./getAlgorithmById\";\r\n\r\n/**\r\n * Starts the sorting process\r\n */\r\nfunction sort() {\r\n    /**\r\n     * Store's state object\r\n     */\r\n    const state = store.getState();\r\n\r\n    /**\r\n     * Algorithm object in store's state\r\n     */\r\n    let algorithm = state.algorithm;\r\n\r\n    /**\r\n     * As when default is selected, it only has id in its object,\r\n     * so we can get the whole object by this id\r\n     */\r\n    algorithm = getAlgorithmById(algorithm.id);\r\n\r\n    if (ALGORITHMS.includes(algorithm)) {\r\n        // If valid algorithm is selected, call its function\r\n        store.dispatch(sortingStarted());\r\n        algorithm.function();\r\n    } else {\r\n        // If not valid algorithm, show error\r\n        console.error(\"No sorting algorithm selected, can't sort\");\r\n        return;\r\n    }\r\n}\r\n\r\nexport default sort;","import ControlBar from \"./ControlBar.jsx\";\r\nimport { connect } from \"react-redux\";\r\nimport { ARRAY_MIN_VALUE, ARRAY_MAX_VALUE, DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults/index.js\";\r\nimport { ALGORITHMS, getAlgorithmById, sort } from \"../../algorithms\"\r\nimport { setArray } from \"../../actions/array\";\r\nimport { setSpeed } from \"../../actions/speed/index.js\";\r\nimport { setSortedArray } from \"../../actions/sortedArray/index.js\";\r\nimport { setAlgorithm } from \"../../actions/algorithm\";\r\nimport { setCurrentlyChecking } from \"../../actions/currentlyChecking/index.js\";\r\nimport { sortingContinued, sortingPaused, sortingRefresh, sortingStopped } from \"../../actions/sortingRunStatus/index.js\";\r\n\r\n/**\r\n * Return a random value in specified range\r\n * @param {*} lowerLimit Least possible random number\r\n * @param {*} upperLimit Maximum possible random number\r\n * @returns A random number between lowerLimit and UpperLimit (both inclusive)\r\n */\r\nconst getRandomValue = (lowerLimit, upperLimit) => {\r\n    return Math.floor(Math.random() * (upperLimit + 1)) + lowerLimit;\r\n}\r\n\r\n/**\r\n * Returns a random array pf specified Length\r\n * @param {*} arraySize Length of the array to be formed\r\n * @returns A random values array of length = arraySize\r\n */\r\nconst generateRandomArray = (arraySize) => {\r\n    const array = [];\r\n    const lowerLimit = ARRAY_MIN_VALUE;\r\n    const upperLimit = ARRAY_MAX_VALUE;\r\n    for (var i = 0; i < arraySize; i++) {\r\n        array.push(getRandomValue(lowerLimit, upperLimit));\r\n    }\r\n    return array;\r\n}\r\n\r\n/**\r\n * Takes the dispatch method as argument \r\n * and dispatches the methods for reseting \r\n * sortedArray and currentlyChecking array\r\n */\r\nconst empty_CurrentlyArray_and_SortedArray = (dispatch) => {\r\n    dispatch(setCurrentlyChecking([]));\r\n    dispatch(setSortedArray([]));\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    const array = state.array;\r\n    const algorithm = state.algorithm;\r\n    const sortingRunStatus = state.sortingRunStatus;\r\n    const algorithms = ALGORITHMS;\r\n    const defaultAlgorithm = getAlgorithmById(DEFAULT_SELECTED_ALGORITHM_ID);\r\n    return { array, algorithm, sortingRunStatus, algorithms, defaultAlgorithm };\r\n}\r\n\r\nconst mapDispatchToProps = () => dispatch => ({\r\n\r\n    /**\r\n     * Generats a random array of given size and sets it through dispatch\r\n     * @param {*} arraySize Length of the array to be generated\r\n     */\r\n    generateArray: (arraySize) => {\r\n        const randomGeneratedArray = generateRandomArray(arraySize);\r\n        dispatch(setArray(randomGeneratedArray));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Changes the algorithm through dispatch\r\n     * @param {*} selectedAlgo New algorithm to be set \r\n     */\r\n    changeAlgorithm: (selectedAlgo) => {\r\n        dispatch(setAlgorithm(selectedAlgo));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Changes the sorting display speed of algorithm\r\n     * @param {*} selectedSpeed Selected Speed\r\n     */\r\n    changeSpeed: (selectedSpeed) => {\r\n        dispatch(setSpeed(selectedSpeed));\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        dispatch(sortingRefresh());\r\n    },\r\n\r\n    /**\r\n     * Starts the sorting\r\n     */\r\n    startSorting: () => {\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n        sort();\r\n    },\r\n\r\n    /**\r\n     * Pauses the current sorting process\r\n     * by dispatching the sortingPaused\r\n     */\r\n    pauseSorting: () => {\r\n        dispatch(sortingPaused());\r\n    },\r\n\r\n    /**\r\n     * Continues the paused sorting process\r\n     * by dispatching sortingContinued\r\n     */\r\n    continueSorting: () => {\r\n        dispatch(sortingContinued());\r\n    },\r\n\r\n    /**\r\n     * Stops the current sorting process\r\n     * by dispatching sortingStopped\r\n     */\r\n    stopSorting: () => {\r\n        dispatch(sortingStopped());\r\n        empty_CurrentlyArray_and_SortedArray(dispatch);\r\n    }\r\n});\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(ControlBar);","import { getAlgorithmById } from \"../../algorithms\";\r\nimport { DEFAULT_SELECTED_ALGORITHM_ID } from \"../../defaults\";\r\n\r\nexport const setAlgorithm = (payload = getAlgorithmById(DEFAULT_SELECTED_ALGORITHM_ID)) => {\r\n    return {\r\n        type: 'SET_ALGORITHM',\r\n        payload: payload\r\n    }\r\n};\r\n","export const setSpeed = (payload) => {\r\n    return {\r\n        type: 'SET_SPEED',\r\n        payload: payload\r\n    }\r\n};\r\n","import React from \"react\";\r\nimport ArrayBars from \"../ArrayBars/ArrayBars\";\r\nimport ControlBar from \"../ControlBar/ControlBar\";\r\n\r\nfunction SortingVisualizer() {\r\n    return (\r\n        <div>\r\n            <ControlBar />\r\n            <ArrayBars />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default SortingVisualizer;","import React from \"react\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <SortingVisualizer />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport { store } from './store';\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n\n  // Wrapping the app around store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n\n  document.getElementById('root')\n);\n"],"sourceRoot":""}